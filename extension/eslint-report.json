[
  {
    "filePath": "E:\\projects\\ado-git-repo-insights\\extension\\ui\\artifact-client.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 53,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 53,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1495, 1498], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1495, 1498], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 83,
        "column": 14,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 83,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2222, 2225], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2222, 2225], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 133,
        "column": 14,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 133,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3463, 3466], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3463, 3466], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 137,
        "column": 41,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 137,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3605, 3608], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3605, 3608], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 156,
        "column": 14,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 156,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4000, 4003], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4000, 4003], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 166,
        "column": 47,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 166,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4289, 4292], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4289, 4292], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 208,
        "column": 48,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 208,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5448, 5451], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5448, 5451], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 279,
        "column": 21,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 279,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7482, 7485], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7482, 7485], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 280,
        "column": 23,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 280,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7523, 7526], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7523, 7526], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 281,
        "column": 41,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 281,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7582, 7585], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7582, 7585], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 282,
        "column": 47,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 282,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7636, 7639], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7636, 7639], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 294,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 294,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7894, 7897], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7894, 7897], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 308,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 308,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8301, 8304], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8301, 8304], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 336,
        "column": 35,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 336,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9176, 9179], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9176, 9179], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 346,
        "column": 67,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 346,
        "endColumn": 70,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9490, 9493], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9490, 9493], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 350,
        "column": 20,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 350,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9650, 9653], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9650, 9653], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 359,
        "column": 26,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 359,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9879, 9882], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9879, 9882], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 360,
        "column": 51,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 360,
        "endColumn": 54,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9933, 9936], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9933, 9936], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 380,
        "column": 67,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 380,
        "endColumn": 70,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10441, 10444], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10441, 10444], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 385,
        "column": 20,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 385,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10625, 10628], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10625, 10628], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 395,
        "column": 26,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 395,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10919, 10922], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10919, 10922], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 396,
        "column": 50,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 396,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10972, 10975], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10972, 10975], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 442,
        "column": 18,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 442,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12293, 12296], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12293, 12296], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 443,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 443,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12328, 12331], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12328, 12331], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 447,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 447,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12420, 12423], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12420, 12423], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 450,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 450,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12505, 12508], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12505, 12508], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 452,
        "column": 44,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 452,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12565, 12568], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12565, 12568], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 467,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 467,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12999, 13002], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12999, 13002], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 469,
        "column": 44,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 469,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [13059, 13062], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [13059, 13062], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 491,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 491,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [13668, 13671], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [13668, 13671], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 493,
        "column": 40,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 493,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [13714, 13717], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [13714, 13717], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 505,
        "column": 14,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 505,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [13943, 13946], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [13943, 13946], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 522,
        "column": 48,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 522,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [14424, 14427], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [14424, 14427], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 530,
        "column": 51,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 530,
        "endColumn": 54,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [14648, 14651], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [14648, 14651], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 34,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Artifact Client for PR Insights Hub\n *\n * Provides authenticated access to Azure DevOps pipeline artifacts.\n * Uses the ADO Extension SDK for proper authentication.\n *\n * IMPORTANT: In ADO extension context, plain fetch() will return 401.\n * We must use the SDK's auth token service.\n */\n\nimport { type IDatasetLoader } from \"./dataset-loader\";\nimport { createPermissionDeniedError } from \"./error-types\";\nimport { getErrorMessage } from \"./types\";\n\n/**\n * Client for accessing pipeline artifacts with authentication.\n */\nexport class ArtifactClient {\n  public readonly projectId: string;\n  private collectionUri: string | null = null;\n  private authToken: string | null = null;\n  private initialized: boolean = false;\n\n  /**\n   * Create a new ArtifactClient.\n   *\n   * @param projectId - Azure DevOps project ID\n   */\n  constructor(projectId: string) {\n    this.projectId = projectId;\n  }\n\n  /**\n   * Initialize the client with ADO SDK auth.\n   * MUST be called after VSS.ready() and before any other methods.\n   *\n   * @returns This client instance\n   */\n  async initialize(): Promise<ArtifactClient> {\n    if (this.initialized) {\n      return this;\n    }\n\n    // Get web context for collection URI\n    const webContext = VSS.getWebContext();\n    this.collectionUri = webContext.collection.uri;\n\n    // Get auth token from SDK\n    const tokenResult = await VSS.getAccessToken();\n    this.authToken =\n      typeof tokenResult === \"string\"\n        ? tokenResult\n        : (tokenResult as any).token;\n\n    this.initialized = true;\n    return this;\n  }\n\n  /**\n   * Ensure the client is initialized.\n   */\n  private _ensureInitialized(): void {\n    if (!this.initialized) {\n      throw new Error(\n        \"ArtifactClient not initialized. Call initialize() first.\",\n      );\n    }\n  }\n\n  /**\n   * Fetch a file from a build artifact.\n   *\n   * @param buildId - Build ID\n   * @param artifactName - Artifact name (e.g., 'aggregates')\n   * @param filePath - Path within artifact (e.g., 'dataset-manifest.json')\n   * @returns Parsed JSON content\n   * @throws {PrInsightsError} On permission denied or not found\n   */\n  async getArtifactFile(\n    buildId: number,\n    artifactName: string,\n    filePath: string,\n  ): Promise<any> {\n    this._ensureInitialized();\n\n    const url = this._buildFileUrl(buildId, artifactName, filePath);\n    const response = await this._authenticatedFetch(url);\n\n    if (response.status === 401 || response.status === 403) {\n      throw createPermissionDeniedError(\"read artifact files\");\n    }\n\n    if (response.status === 404) {\n      throw new Error(\n        `File '${filePath}' not found in artifact '${artifactName}'`,\n      );\n    }\n\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch artifact file: ${response.status} ${response.statusText}`,\n      );\n    }\n\n    return response.json();\n  }\n\n  /**\n   * Check if a specific file exists in an artifact.\n   */\n  async hasArtifactFile(\n    buildId: number,\n    artifactName: string,\n    filePath: string,\n  ): Promise<boolean> {\n    this._ensureInitialized();\n\n    try {\n      const url = this._buildFileUrl(buildId, artifactName, filePath);\n      const response = await this._authenticatedFetch(url, { method: \"HEAD\" });\n      return response.ok;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get artifact metadata by looking it up from the artifacts list.\n   */\n  async getArtifactMetadata(\n    buildId: number,\n    artifactName: string,\n  ): Promise<any | null> {\n    this._ensureInitialized();\n\n    const artifacts = await this.getArtifacts(buildId);\n    const artifact = artifacts.find((a: any) => a.name === artifactName);\n\n    if (!artifact) {\n      console.log(\n        `[getArtifactMetadata] Artifact '${artifactName}' not found in build ${buildId}`,\n      );\n      return null;\n    }\n\n    return artifact;\n  }\n\n  /**\n   * Get artifact content via SDK approach.\n   */\n  async getArtifactFileViaSdk(\n    buildId: number,\n    artifactName: string,\n    filePath: string,\n  ): Promise<any> {\n    this._ensureInitialized();\n\n    const artifact = await this.getArtifactMetadata(buildId, artifactName);\n    if (!artifact) {\n      throw new Error(\n        `Artifact '${artifactName}' not found in build ${buildId}`,\n      );\n    }\n\n    const downloadUrl = (artifact.resource as any)?.downloadUrl;\n    if (!downloadUrl) {\n      throw new Error(\n        `No downloadUrl available for artifact '${artifactName}'`,\n      );\n    }\n\n    const normalizedPath = filePath.startsWith(\"/\") ? filePath : \"/\" + filePath;\n\n    let url: string;\n    if (downloadUrl.includes(\"format=\")) {\n      url = downloadUrl.replace(/format=\\w+/, \"format=file\");\n    } else {\n      const separator = downloadUrl.includes(\"?\") ? \"&\" : \"?\";\n      url = `${downloadUrl}${separator}format=file`;\n    }\n    url += `&subPath=${encodeURIComponent(normalizedPath)}`;\n\n    const response = await this._authenticatedFetch(url);\n\n    if (response.status === 404) {\n      throw new Error(\n        `File '${filePath}' not found in artifact '${artifactName}'`,\n      );\n    }\n\n    if (response.status === 401 || response.status === 403) {\n      throw createPermissionDeniedError(\"read artifact file\");\n    }\n\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch file: ${response.status} ${response.statusText}`,\n      );\n    }\n\n    return response.json();\n  }\n\n  /**\n   * Get list of artifacts for a build.\n   */\n  async getArtifacts(buildId: number): Promise<any[]> {\n    this._ensureInitialized();\n\n    const url = `${this.collectionUri}${this.projectId}/_apis/build/builds/${buildId}/artifacts?api-version=7.1`;\n    const response = await this._authenticatedFetch(url);\n\n    if (response.status === 401 || response.status === 403) {\n      throw createPermissionDeniedError(\"list build artifacts\");\n    }\n\n    if (!response.ok) {\n      throw new Error(`Failed to list artifacts: ${response.status}`);\n    }\n\n    const data = await response.json();\n    return data.value || [];\n  }\n\n  /**\n   * Create a DatasetLoader that uses this client for authenticated requests.\n   */\n  createDatasetLoader(\n    buildId: number,\n    artifactName: string,\n  ): AuthenticatedDatasetLoader {\n    return new AuthenticatedDatasetLoader(this, buildId, artifactName);\n  }\n\n  /**\n   * Build the URL for accessing a file within an artifact.\n   */\n  private _buildFileUrl(\n    buildId: number,\n    artifactName: string,\n    filePath: string,\n  ): string {\n    const normalizedPath = filePath.startsWith(\"/\") ? filePath : \"/\" + filePath;\n\n    return (\n      `${this.collectionUri}${this.projectId}/_apis/build/builds/${buildId}/artifacts` +\n      `?artifactName=${encodeURIComponent(artifactName)}` +\n      `&%24format=file` +\n      `&subPath=${encodeURIComponent(normalizedPath)}` +\n      `&api-version=7.1`\n    );\n  }\n\n  /**\n   * Perform an authenticated fetch using the ADO auth token.\n   */\n  protected async _authenticatedFetch(\n    url: string,\n    options: RequestInit = {},\n  ): Promise<Response> {\n    const headers: HeadersInit = {\n      Authorization: `Bearer ${this.authToken}`,\n      Accept: \"application/json\",\n      ...(options.headers || {}),\n    };\n\n    return fetch(url, { ...options, headers });\n  }\n}\n\n/**\n * DatasetLoader that uses ArtifactClient for authenticated requests.\n */\nexport class AuthenticatedDatasetLoader implements IDatasetLoader {\n  private readonly artifactClient: ArtifactClient;\n  private readonly buildId: number;\n  private readonly artifactName: string;\n  private manifest: any | null = null;\n  private dimensions: any | null = null;\n  private rollupCache = new Map<string, any>();\n  private distributionCache = new Map<string, any>();\n\n  constructor(\n    artifactClient: ArtifactClient,\n    buildId: number,\n    artifactName: string,\n  ) {\n    this.artifactClient = artifactClient;\n    this.buildId = buildId;\n    this.artifactName = artifactName;\n  }\n\n  async loadManifest(): Promise<any> {\n    try {\n      this.manifest = await this.artifactClient.getArtifactFileViaSdk(\n        this.buildId,\n        this.artifactName,\n        \"dataset-manifest.json\",\n      );\n      this.validateManifest(this.manifest);\n      return this.manifest;\n    } catch (error: unknown) {\n      throw new Error(`Failed to load dataset manifest: ${getErrorMessage(error)}`);\n    }\n  }\n\n  validateManifest(manifest: any): void {\n    const SUPPORTED_MANIFEST_VERSION = 1;\n    const SUPPORTED_DATASET_VERSION = 1;\n    const SUPPORTED_AGGREGATES_VERSION = 1;\n\n    if (!manifest.manifest_schema_version) {\n      throw new Error(\"Invalid manifest: missing schema version\");\n    }\n\n    if (manifest.manifest_schema_version > SUPPORTED_MANIFEST_VERSION) {\n      throw new Error(\n        `Manifest version ${manifest.manifest_schema_version} not supported.`,\n      );\n    }\n\n    if (manifest.dataset_schema_version > SUPPORTED_DATASET_VERSION) {\n      throw new Error(\n        `Dataset version ${manifest.dataset_schema_version} not supported.`,\n      );\n    }\n\n    if (manifest.aggregates_schema_version > SUPPORTED_AGGREGATES_VERSION) {\n      throw new Error(\n        `Aggregates version ${manifest.aggregates_schema_version} not supported.`,\n      );\n    }\n  }\n\n  async loadDimensions(): Promise<any> {\n    if (this.dimensions) return this.dimensions;\n    this.dimensions = await this.artifactClient.getArtifactFileViaSdk(\n      this.buildId,\n      this.artifactName,\n      \"aggregates/dimensions.json\",\n    );\n    return this.dimensions;\n  }\n\n  async getWeeklyRollups(startDate: Date, endDate: Date): Promise<any[]> {\n    if (!this.manifest) throw new Error(\"Manifest not loaded.\");\n\n    const neededWeeks = this.getWeeksInRange(startDate, endDate);\n    const results: any[] = [];\n\n    for (const weekStr of neededWeeks) {\n      if (this.rollupCache.has(weekStr)) {\n        results.push(this.rollupCache.get(weekStr));\n        continue;\n      }\n\n      const indexEntry = (\n        this.manifest as any\n      ).aggregate_index?.weekly_rollups?.find((r: any) => r.week === weekStr);\n\n      if (!indexEntry) continue;\n\n      try {\n        const rollup = await this.artifactClient.getArtifactFileViaSdk(\n          this.buildId,\n          this.artifactName,\n          indexEntry.path,\n        );\n        this.rollupCache.set(weekStr, rollup);\n        results.push(rollup);\n      } catch (e) {\n        console.warn(`Failed to load rollup for ${weekStr}:`, e);\n      }\n    }\n\n    return results;\n  }\n\n  async getDistributions(startDate: Date, endDate: Date): Promise<any[]> {\n    if (!this.manifest) throw new Error(\"Manifest not loaded.\");\n\n    const startYear = startDate.getFullYear();\n    const endYear = endDate.getFullYear();\n    const results: any[] = [];\n\n    for (let year = startYear; year <= endYear; year++) {\n      const yearStr = String(year);\n      if (this.distributionCache.has(yearStr)) {\n        results.push(this.distributionCache.get(yearStr));\n        continue;\n      }\n\n      const indexEntry = (\n        this.manifest as any\n      ).aggregate_index?.distributions?.find((d: any) => d.year === yearStr);\n\n      if (!indexEntry) continue;\n\n      try {\n        const dist = await this.artifactClient.getArtifactFileViaSdk(\n          this.buildId,\n          this.artifactName,\n          indexEntry.path,\n        );\n        this.distributionCache.set(yearStr, dist);\n        results.push(dist);\n      } catch (e) {\n        console.warn(`Failed to load distribution for ${yearStr}:`, e);\n      }\n    }\n\n    return results;\n  }\n\n  getWeeksInRange(startDate: Date, endDate: Date): string[] {\n    const weeks: string[] = [];\n    const current = new Date(startDate);\n    const day = current.getDay();\n    const diff = current.getDate() - day + (day === 0 ? -6 : 1);\n    current.setDate(diff);\n\n    while (current <= endDate) {\n      weeks.push(this.getISOWeek(current));\n      current.setDate(current.getDate() + 7);\n    }\n    return weeks;\n  }\n\n  getISOWeek(date: Date): string {\n    const d = new Date(\n      Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()),\n    );\n    d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));\n    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));\n    const weekNo = Math.ceil(\n      ((d.getTime() - yearStart.getTime()) / 86400000 + 1) / 7,\n    );\n    return `${d.getUTCFullYear()}-W${String(weekNo).padStart(2, \"0\")}`;\n  }\n\n  getCoverage(): any {\n    return (this.manifest as any)?.coverage || null;\n  }\n\n  getDefaultRangeDays(): number {\n    return (this.manifest as any)?.ui_defaults?.default_range_days || 90;\n  }\n\n  async loadPredictions(): Promise<any> {\n    try {\n      const indexEntry = (this.manifest as any)?.aggregate_index?.predictions;\n      if (!indexEntry) return { state: \"unavailable\" };\n\n      const data = await this.artifactClient.getArtifactFileViaSdk(\n        this.buildId,\n        this.artifactName,\n        indexEntry.path,\n      );\n      return { state: \"ok\", data };\n    } catch (e) {\n      console.warn(\"Failed to load predictions:\", e);\n      return { state: \"unavailable\" };\n    }\n  }\n\n  async loadInsights(): Promise<any> {\n    try {\n      const indexEntry = (this.manifest as any)?.aggregate_index?.ai_insights;\n      if (!indexEntry) return { state: \"unavailable\" };\n\n      const data = await this.artifactClient.getArtifactFileViaSdk(\n        this.buildId,\n        this.artifactName,\n        indexEntry.path,\n      );\n      return { state: \"ok\", data };\n    } catch (e) {\n      console.warn(\"Failed to load AI insights:\", e);\n      return { state: \"unavailable\" };\n    }\n  }\n}\n\n/**\n * Mock implementation for testing.\n */\nexport class MockArtifactClient {\n  public readonly projectId: string = \"mock-project\";\n  public initialized: boolean = true;\n  private mockData: Record<string, any>;\n\n  constructor(mockData: Record<string, any> = {}) {\n    this.mockData = mockData;\n  }\n\n  async initialize(): Promise<MockArtifactClient> {\n    return this;\n  }\n\n  async getArtifactFile(\n    buildId: number,\n    artifactName: string,\n    filePath: string,\n  ): Promise<any> {\n    const key = `${buildId}/${artifactName}/${filePath}`;\n    if (this.mockData[key]) {\n      return JSON.parse(JSON.stringify(this.mockData[key]));\n    }\n    throw new Error(`Mock: File not found: ${key}`);\n  }\n\n  async hasArtifactFile(\n    buildId: number,\n    artifactName: string,\n    filePath: string,\n  ): Promise<boolean> {\n    const key = `${buildId}/${artifactName}/${filePath}`;\n    return !!this.mockData[key];\n  }\n\n  async getArtifacts(buildId: number): Promise<any[]> {\n    return this.mockData[`${buildId}/artifacts`] || [];\n  }\n\n  createDatasetLoader(\n    buildId: number,\n    artifactName: string,\n  ): AuthenticatedDatasetLoader {\n    return new AuthenticatedDatasetLoader(this as any, buildId, artifactName);\n  }\n}\n\n// Browser global exports for runtime compatibility\nif (typeof window !== \"undefined\") {\n  window.ArtifactClient = ArtifactClient;\n  window.AuthenticatedDatasetLoader = AuthenticatedDatasetLoader;\n  window.MockArtifactClient = MockArtifactClient;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "E:\\projects\\ado-git-repo-insights\\extension\\ui\\dashboard.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 53,
        "column": 32,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 53,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1647, 1650], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1647, 1650], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 188,
        "column": 28,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 188,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5428, 5431], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5428, 5431], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 541,
        "column": 61,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 541,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [14651, 14654], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [14651, 14654], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 718,
        "column": 13,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 718,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [19432, 19435], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [19432, 19435], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 1013,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1013,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [27864, 27867], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [27864, 27867], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 1070,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1070,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [29468, 29471], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [29468, 29471], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 1546,
        "column": 49,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1546,
        "endColumn": 52,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [42678, 42681], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [42678, 42681], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 1807,
        "column": 25,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1807,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [51217, 51220], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [51217, 51220], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 1814,
        "column": 48,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1814,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [51505, 51508], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [51505, 51508], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 1829,
        "column": 45,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1829,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [52014, 52017], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [52014, 52017], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 1845,
        "column": 65,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1845,
        "endColumn": 68,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [52385, 52388], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [52385, 52388], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 1853,
        "column": 44,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1853,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [52643, 52646], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [52643, 52646], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 1866,
        "column": 15,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1866,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [53224, 53227], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [53224, 53227], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 1889,
        "column": 61,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1889,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [53975, 53978], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [53975, 53978], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 1903,
        "column": 48,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1903,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [54391, 54394], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [54391, 54394], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 1913,
        "column": 15,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1913,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [54791, 54794], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [54791, 54794], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-floating-promises",
        "severity": 1,
        "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
        "line": 1957,
        "column": 3,
        "nodeType": "ExpressionStatement",
        "messageId": "floatingVoid",
        "endLine": 1957,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "floatingFixVoid",
            "fix": { "range": [56251, 56251], "text": "void " },
            "desc": "Add void operator to ignore."
          },
          {
            "messageId": "floatingFixAwait",
            "fix": { "range": [56251, 56251], "text": "await " },
            "desc": "Add await operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-floating-promises",
        "severity": 1,
        "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
        "line": 1968,
        "column": 3,
        "nodeType": "ExpressionStatement",
        "messageId": "floatingVoid",
        "endLine": 1968,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "floatingFixVoid",
            "fix": { "range": [56565, 56565], "text": "void " },
            "desc": "Add void operator to ignore."
          },
          {
            "messageId": "floatingFixAwait",
            "fix": { "range": [56565, 56565], "text": "await " },
            "desc": "Add await operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 1998,
        "column": 46,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1998,
        "endColumn": 49,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [57663, 57666], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [57663, 57666], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 2005,
        "column": 44,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 2005,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [57972, 57975], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [57972, 57975], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 2021,
        "column": 37,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 2021,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [58640, 58643], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [58640, 58643], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-floating-promises",
        "severity": 1,
        "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
        "line": 2059,
        "column": 3,
        "nodeType": "ExpressionStatement",
        "messageId": "floatingVoid",
        "endLine": 2059,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "floatingFixVoid",
            "fix": { "range": [59711, 59711], "text": "void " },
            "desc": "Add void operator to ignore."
          },
          {
            "messageId": "floatingFixAwait",
            "fix": { "range": [59711, 59711], "text": "await " },
            "desc": "Add await operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-floating-promises",
        "severity": 1,
        "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
        "line": 2084,
        "column": 3,
        "nodeType": "ExpressionStatement",
        "messageId": "floatingVoid",
        "endLine": 2084,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "floatingFixVoid",
            "fix": { "range": [60273, 60273], "text": "void " },
            "desc": "Add void operator to ignore."
          },
          {
            "messageId": "floatingFixAwait",
            "fix": { "range": [60273, 60273], "text": "await " },
            "desc": "Add await operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-floating-promises",
        "severity": 1,
        "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
        "line": 2113,
        "column": 3,
        "nodeType": "ExpressionStatement",
        "messageId": "floatingVoid",
        "endLine": 2113,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "floatingFixVoid",
            "fix": { "range": [61180, 61180], "text": "void " },
            "desc": "Add void operator to ignore."
          },
          {
            "messageId": "floatingFixAwait",
            "fix": { "range": [61180, 61180], "text": "await " },
            "desc": "Add await operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-floating-promises",
        "severity": 1,
        "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
        "line": 2255,
        "column": 3,
        "nodeType": "ExpressionStatement",
        "messageId": "floatingVoid",
        "endLine": 2255,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "floatingFixVoid",
            "fix": { "range": [65220, 65220], "text": "void " },
            "desc": "Add void operator to ignore."
          },
          {
            "messageId": "floatingFixAwait",
            "fix": { "range": [65220, 65220], "text": "await " },
            "desc": "Add await operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-floating-promises",
        "severity": 1,
        "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
        "line": 2266,
        "column": 3,
        "nodeType": "ExpressionStatement",
        "messageId": "floatingVoid",
        "endLine": 2266,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "floatingFixVoid",
            "fix": { "range": [65476, 65476], "text": "void " },
            "desc": "Add void operator to ignore."
          },
          {
            "messageId": "floatingFixAwait",
            "fix": { "range": [65476, 65476], "text": "await " },
            "desc": "Add await operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 2426,
        "column": 47,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 2426,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [69755, 69758], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [69755, 69758], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 2488,
        "column": 38,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 2488,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [71414, 71417], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [71414, 71417], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-floating-promises",
        "severity": 1,
        "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
        "line": 2595,
        "column": 3,
        "nodeType": "ExpressionStatement",
        "messageId": "floatingVoid",
        "endLine": 2595,
        "endColumn": 10,
        "suggestions": [
          {
            "messageId": "floatingFixVoid",
            "fix": { "range": [74750, 74750], "text": "void " },
            "desc": "Add void operator to ignore."
          },
          {
            "messageId": "floatingFixAwait",
            "fix": { "range": [74750, 74750], "text": "await " },
            "desc": "Add await operator."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 29,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * PR Insights Dashboard\n *\n * Project-level hub that loads data from pipeline artifacts.\n * Uses Azure DevOps Extension SDK for authentication.\n *\n * Configuration precedence:\n * 1. ?dataset=<url> - Direct URL (DEV ONLY)\n * 2. ?pipelineId=<id> - Query parameter override\n * 3. Extension settings - User-scoped saved preference\n * 4. Auto-discovery - Find pipelines with 'aggregates' artifact\n */\n\nimport { DatasetLoader, type IDatasetLoader, type Rollup } from \"./dataset-loader\";\nimport { ArtifactClient } from \"./artifact-client\";\nimport {\n  PrInsightsError,\n  ErrorTypes,\n  createSetupRequiredError,\n  createNoSuccessfulBuildsError,\n  createArtifactsMissingError,\n  createInvalidConfigError,\n  type SetupRequiredDetails,\n  type MultiplePipelinesDetails,\n  type ArtifactsMissingDetails,\n} from \"./error-types\";\nimport { getErrorMessage } from \"./types\";\n\n// Dashboard state\nlet loader: IDatasetLoader | null = null;\nlet artifactClient: ArtifactClient | null = null;\nlet currentDateRange: { start: Date | null; end: Date | null } = {\n  start: null,\n  end: null,\n};\nlet currentFilters: { repos: string[]; teams: string[] } = {\n  repos: [],\n  teams: [],\n};\nlet comparisonMode = false;\nlet cachedRollups: Rollup[] = []; // Cache for export\nlet currentBuildId: number | null = null; // Store build ID for raw data download\nlet sdkInitialized = false;\n\n// Settings keys for extension data storage (must match settings.js)\nconst SETTINGS_KEY_PROJECT = \"pr-insights-source-project\";\nconst SETTINGS_KEY_PIPELINE = \"pr-insights-pipeline-id\";\n\n// Feature flags\nconst ENABLE_PHASE5_FEATURES = true;\n\n// DOM element cache\nconst elements: Record<string, any> = {};\n\n/**\n * Phase 4: Production-safe metrics collector\n */\nconst IS_PRODUCTION =\n  typeof window !== \"undefined\" &&\n  window.process?.env?.NODE_ENV === \"production\";\nconst DEBUG_ENABLED =\n  !IS_PRODUCTION &&\n  ((typeof window !== \"undefined\" && window.__DASHBOARD_DEBUG__) ||\n    (typeof window !== \"undefined\" &&\n      new URLSearchParams(window.location.search).has(\"debug\")));\n\ninterface PerformanceMetric {\n  name: string;\n  duration: number;\n  timestamp: number;\n}\n\nconst metricsCollector = DEBUG_ENABLED\n  ? {\n    marks: new Map<string, number>(),\n    measures: [] as PerformanceMetric[],\n    mark(name: string) {\n      if (!performance || !performance.mark) return;\n      try {\n        performance.mark(name);\n        this.marks.set(name, performance.now());\n      } catch (_e) {\n        /* ignore */\n      }\n    },\n    measure(name: string, startMark: string, endMark: string) {\n      if (!performance || !performance.measure) return;\n      try {\n        performance.measure(name, startMark, endMark);\n        const entries = performance.getEntriesByName(name, \"measure\");\n        if (entries.length > 0) {\n          const lastEntry = entries[entries.length - 1];\n          if (lastEntry) {\n            this.measures.push({\n              name,\n              duration: lastEntry.duration,\n              timestamp: Date.now(),\n            });\n          }\n        }\n      } catch (_e) {\n        /* ignore */\n      }\n    },\n    getMetrics() {\n      return {\n        marks: Array.from(this.marks.entries()).map(([name, time]) => ({\n          name,\n          time,\n        })),\n        measures: [...this.measures],\n      };\n    },\n    reset() {\n      this.marks.clear();\n      this.measures = [];\n      if (performance && performance.clearMarks) performance.clearMarks();\n      if (performance && performance.clearMeasures)\n        performance.clearMeasures();\n    },\n  }\n  : null;\n\nif (DEBUG_ENABLED && typeof window !== \"undefined\") {\n  window.__dashboardMetrics = metricsCollector;\n}\n\n// ============================================================================\n// Security Utilities\n// ============================================================================\n\n/**\n * Escape HTML to prevent XSS attacks.\n * SECURITY: Use this for any user-controlled or external data before innerHTML.\n */\nfunction escapeHtml(text: string): string {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\n\n// ============================================================================\n// SDK Initialization\n// ============================================================================\n\n/**\n * Initialize Azure DevOps Extension SDK.\n */\nasync function initializeAdoSdk(): Promise<void> {\n  if (sdkInitialized) return;\n\n  return new Promise((resolve, reject) => {\n    const timeout = setTimeout(() => {\n      reject(new Error(\"Azure DevOps SDK initialization timed out\"));\n    }, 10000);\n\n    VSS.init({\n      explicitNotifyLoaded: true,\n      usePlatformScripts: true,\n      usePlatformStyles: true,\n    });\n\n    VSS.ready(() => {\n      clearTimeout(timeout);\n      sdkInitialized = true;\n\n      // Update project name in UI\n      const webContext = VSS.getWebContext();\n      const projectNameEl = document.getElementById(\"current-project-name\");\n      if (projectNameEl && webContext?.project?.name) {\n        projectNameEl.textContent = webContext.project.name;\n      }\n\n      VSS.notifyLoadSucceeded();\n      resolve();\n    });\n  });\n}\n\n// ============================================================================\n// Configuration Resolution\n// ============================================================================\n\n/**\n * Parse and validate query parameters.\n */\nfunction parseQueryParams():\n  | { mode: string; value: any; warning?: string | null }\n  | PrInsightsError {\n  const params = new URLSearchParams(window.location.search);\n\n  const datasetUrl = params.get(\"dataset\");\n  const pipelineIdStr = params.get(\"pipelineId\");\n\n  // Check for dataset URL (highest priority)\n  if (datasetUrl) {\n    // Validate URL\n    if (!datasetUrl.startsWith(\"https://\")) {\n      return createInvalidConfigError(\n        \"dataset\",\n        datasetUrl,\n        \"Must be a valid HTTPS URL\",\n      );\n    }\n\n    // Security warning for non-ADO domains\n    const IS_DEV =\n      window.location.hostname === \"localhost\" || params.has(\"devMode\");\n\n    if (!IS_DEV) {\n      try {\n        const urlHost = new URL(datasetUrl).hostname;\n        const isAdoDomain =\n          urlHost.endsWith(\"dev.azure.com\") ||\n          urlHost.endsWith(\".visualstudio.com\") ||\n          urlHost.endsWith(\".azure.com\");\n        if (!isAdoDomain) {\n          console.warn(\n            `SECURITY: ?dataset= URL \"${urlHost}\" is not an Azure DevOps domain. ` +\n            `This parameter is intended for development only.`,\n          );\n        }\n      } catch (_e) {\n        return createInvalidConfigError(\n          \"dataset\",\n          datasetUrl,\n          \"Invalid URL format\",\n        );\n      }\n    }\n\n    let warning: string | null = null;\n    if (pipelineIdStr) {\n      warning = \"Both dataset and pipelineId specified; using dataset\";\n      console.warn(warning);\n    }\n\n    return { mode: \"direct\", value: datasetUrl, warning };\n  }\n\n  // Check for pipelineId\n  if (pipelineIdStr) {\n    const pipelineId = parseInt(pipelineIdStr, 10);\n    if (isNaN(pipelineId) || pipelineId <= 0) {\n      return createInvalidConfigError(\n        \"pipelineId\",\n        pipelineIdStr,\n        \"Must be a positive integer\",\n      );\n    }\n    return { mode: \"explicit\", value: pipelineId };\n  }\n\n  return { mode: \"discover\", value: null };\n}\n\n/**\n * Get source configuration from extension settings.\n */\nasync function getSourceConfig(): Promise<{\n  projectId: string | null;\n  pipelineId: number | null;\n}> {\n  const result: { projectId: string | null; pipelineId: number | null } = {\n    projectId: null,\n    pipelineId: null,\n  };\n  try {\n    const dataService = await VSS.getService<IExtensionDataService>(\n      VSS.ServiceIds.ExtensionData,\n    );\n\n    // Get source project ID\n    const savedProjectId = await dataService.getValue<string>(\n      SETTINGS_KEY_PROJECT,\n      { scopeType: \"User\" },\n    );\n    if (\n      savedProjectId &&\n      typeof savedProjectId === \"string\" &&\n      savedProjectId.trim()\n    ) {\n      result.projectId = savedProjectId.trim();\n    }\n\n    // Get pipeline definition ID\n    const savedPipelineId = await dataService.getValue<number>(\n      SETTINGS_KEY_PIPELINE,\n      { scopeType: \"User\" },\n    );\n    if (\n      savedPipelineId &&\n      typeof savedPipelineId === \"number\" &&\n      savedPipelineId > 0\n    ) {\n      result.pipelineId = savedPipelineId;\n    }\n  } catch (e) {\n    console.log(\"Could not read extension settings:\", e);\n  }\n  return result;\n}\n\n/**\n * Clear stale pipeline ID setting.\n */\nasync function clearStalePipelineSetting(): Promise<void> {\n  try {\n    const dataService = await VSS.getService<IExtensionDataService>(\n      VSS.ServiceIds.ExtensionData,\n    );\n    await dataService.setValue(SETTINGS_KEY_PIPELINE, null, {\n      scopeType: \"User\",\n    });\n    console.log(\"Cleared stale pipeline setting to re-enable auto-discovery\");\n  } catch (e) {\n    console.warn(\"Could not clear stale pipeline setting:\", e);\n  }\n}\n\n/**\n * Resolve configuration using precedence rules.\n */\nasync function resolveConfiguration(): Promise<{\n  buildId?: number;\n  artifactName?: string;\n  directUrl?: string;\n}> {\n  const queryResult = parseQueryParams();\n\n  // Check for parsing error\n  if (queryResult instanceof PrInsightsError) {\n    throw queryResult;\n  }\n\n  // Mode: direct URL\n  if (queryResult.mode === \"direct\") {\n    return { directUrl: queryResult.value };\n  }\n\n  // Get current project context\n  const webContext = VSS.getWebContext();\n  const currentProjectId = webContext.project?.id;\n  if (!currentProjectId) {\n    throw new Error(\"No project context available\");\n  }\n\n  // Get configured source from settings\n  const sourceConfig = await getSourceConfig();\n\n  // Determine which project to use for artifact access\n  const targetProjectId = sourceConfig.projectId || currentProjectId;\n\n  console.log(\n    `Source project: ${targetProjectId}${sourceConfig.projectId ? \" (from settings)\" : \" (current context)\"}`,\n  );\n\n  // Initialize artifact client with target project\n  artifactClient = new ArtifactClient(targetProjectId);\n  await artifactClient.initialize();\n\n  // Mode: explicit pipelineId from query\n  if (queryResult.mode === \"explicit\") {\n    return await resolveFromPipelineId(queryResult.value, targetProjectId);\n  }\n\n  // Check settings for pipeline ID\n  if (sourceConfig.pipelineId) {\n    console.log(\n      `Using pipeline definition ID from settings: ${sourceConfig.pipelineId}`,\n    );\n    try {\n      return await resolveFromPipelineId(\n        sourceConfig.pipelineId,\n        targetProjectId,\n      );\n    } catch (error: unknown) {\n      console.warn(\n        `Saved pipeline ${sourceConfig.pipelineId} is invalid, falling back to auto-discovery:`,\n        getErrorMessage(error),\n      );\n      await clearStalePipelineSetting();\n    }\n  }\n\n  // Mode: discovery in target project\n  return await discoverAndResolve(targetProjectId);\n}\n\n/**\n * Resolve artifact info from a specific pipeline ID.\n */\nasync function resolveFromPipelineId(\n  pipelineId: number,\n  projectId: string,\n): Promise<{ buildId: number; artifactName: string }> {\n  // Get Build REST client\n  const buildClient = await getBuildClient();\n\n  // Get latest successful build\n  const builds = await buildClient.getBuilds(\n    projectId,\n    [pipelineId],\n    undefined,\n    undefined,\n    undefined,\n    undefined,\n    undefined,\n    undefined, // reasonFilter\n    2, // statusFilter: Completed\n    6, // resultFilter: Succeeded (2) | PartiallySucceeded (4)\n    undefined,\n    undefined,\n    1, // top\n  );\n\n  if (!builds || builds.length === 0) {\n    const definitions = await buildClient.getDefinitions(\n      projectId,\n      undefined,\n      undefined,\n      undefined,\n      2,\n      undefined,\n      undefined,\n      undefined,\n      [pipelineId],\n    );\n    const name = definitions?.[0]?.name || `ID ${pipelineId}`;\n    throw createNoSuccessfulBuildsError(name);\n  }\n\n  const latestBuild = builds[0];\n  if (!latestBuild) throw new Error(\"Failed to retrieve latest build\");\n\n  // Check for aggregates artifact\n  if (!artifactClient) throw new Error(\"ArtifactClient not initialized\");\n  const artifacts = await artifactClient.getArtifacts(latestBuild.id);\n  const hasAggregates = artifacts.some((a) => a.name === \"aggregates\");\n\n  if (!hasAggregates) {\n    const definitions = await buildClient.getDefinitions(\n      projectId,\n      undefined,\n      undefined,\n      undefined,\n      2,\n      undefined,\n      undefined,\n      undefined,\n      [pipelineId],\n    );\n    const name = definitions?.[0]?.name || `ID ${pipelineId}`;\n    throw createArtifactsMissingError(name, latestBuild.id);\n  }\n\n  return { buildId: latestBuild.id, artifactName: \"aggregates\" };\n}\n\n/**\n * Discover pipelines with aggregates and resolve.\n */\nasync function discoverAndResolve(\n  projectId: string,\n): Promise<{ buildId: number; artifactName: string }> {\n  const matches = await discoverInsightsPipelines(projectId);\n\n  if (matches.length === 0) {\n    throw createSetupRequiredError();\n  }\n\n  const firstMatch = matches[0];\n  if (!firstMatch) throw createSetupRequiredError();\n\n  return { buildId: firstMatch.buildId, artifactName: \"aggregates\" };\n}\n\n/**\n * Discover pipelines with aggregates artifact.\n */\nasync function discoverInsightsPipelines(\n  projectId: string,\n): Promise<Array<{ id: number; name: string; buildId: number }>> {\n  const buildClient = await getBuildClient();\n  const matches: Array<{ id: number; name: string; buildId: number }> = [];\n\n  const definitions = await buildClient.getDefinitions(\n    projectId,\n    undefined,\n    undefined,\n    undefined,\n    2,\n    50,\n  );\n\n  for (const def of definitions) {\n    const builds = await buildClient.getBuilds(\n      projectId,\n      [def.id],\n      undefined,\n      undefined,\n      undefined,\n      undefined,\n      undefined,\n      undefined,\n      2,\n      6,\n      undefined,\n      undefined,\n      1,\n    );\n\n    if (!builds || builds.length === 0) continue;\n\n    const latestBuild = builds[0];\n    if (!latestBuild) continue;\n\n    try {\n      if (!artifactClient) throw new Error(\"ArtifactClient not initialized\");\n      const artifacts = await artifactClient.getArtifacts(latestBuild.id);\n      if (!artifacts.some((a) => a.name === \"aggregates\")) continue;\n\n      matches.push({\n        id: def.id,\n        name: def.name,\n        buildId: latestBuild.id,\n      });\n    } catch (e) {\n      console.debug(`Skipping pipeline ${def.name}:`, e);\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Get Build REST client from SDK.\n */\nasync function getBuildClient(): Promise<IBuildRestClient> {\n  return new Promise((resolve) => {\n    VSS.require([\"TFS/Build/RestClient\"], (BuildRestClient: any) => {\n      resolve(BuildRestClient.getClient());\n    });\n  });\n}\n\n// ============================================================================\n// Main Initialization\n// ============================================================================\n\n/**\n * Check if running in local dashboard mode.\n */\nfunction isLocalMode(): boolean {\n  return (\n    typeof window !== \"undefined\" &&\n    window.LOCAL_DASHBOARD_MODE === true\n  );\n}\n\n/**\n * Get local dataset path from window config.\n */\nfunction getLocalDatasetPath(): string {\n  return (\n    (typeof window !== \"undefined\" && window.DATASET_PATH) ||\n    \"./dataset\"\n  );\n}\n\n/**\n * Initialize the dashboard.\n */\nasync function init(): Promise<void> {\n  if (metricsCollector) metricsCollector.mark(\"dashboard-init\");\n\n  cacheElements();\n  setupEventListeners();\n  initializePhase5Features();\n\n  try {\n    if (isLocalMode()) {\n      console.log(\"[Dashboard] Running in local mode\");\n      const datasetPath = getLocalDatasetPath();\n      loader = new DatasetLoader(datasetPath);\n      currentBuildId = null;\n\n      const projectNameEl = document.getElementById(\"current-project-name\");\n      if (projectNameEl) {\n        projectNameEl.textContent = \"Local Dashboard\";\n      }\n\n      const exportRawZip = document.getElementById(\"export-raw-zip\");\n      if (exportRawZip) {\n        exportRawZip.style.display = \"none\";\n      }\n\n      await loadDataset();\n      return;\n    }\n\n    await initializeAdoSdk();\n    const config = await resolveConfiguration();\n\n    if (config.directUrl) {\n      loader = new DatasetLoader(config.directUrl);\n      currentBuildId = null;\n    } else if (config.buildId && config.artifactName && artifactClient) {\n      loader = artifactClient.createDatasetLoader(\n        config.buildId,\n        config.artifactName,\n      );\n      currentBuildId = config.buildId;\n    } else {\n      throw new Error(\"Failed to resolve configuration\");\n    }\n\n    await loadDataset();\n  } catch (error: unknown) {\n    console.error(\"Dashboard initialization failed:\", error);\n    handleError(error);\n  }\n}\n\n/**\n * Handle errors with appropriate UI panels.\n */\nfunction handleError(error: unknown): void {\n  hideAllPanels();\n\n  if (error instanceof PrInsightsError) {\n    switch (error.type) {\n      case ErrorTypes.SETUP_REQUIRED:\n        showSetupRequired(error);\n        break;\n      case ErrorTypes.MULTIPLE_PIPELINES:\n        showMultiplePipelines(error);\n        break;\n      case ErrorTypes.ARTIFACTS_MISSING:\n        showArtifactsMissing(error);\n        break;\n      case ErrorTypes.PERMISSION_DENIED:\n        showPermissionDenied(error);\n        break;\n      default:\n        showGenericError(error.title, error.message);\n        break;\n    }\n  } else {\n    showGenericError(\"Error\", getErrorMessage(error) || \"An unexpected error occurred\");\n  }\n}\n\n/**\n * Hide all error/setup panels.\n */\nfunction hideAllPanels(): void {\n  [\n    \"setup-required\",\n    \"multiple-pipelines\",\n    \"artifacts-missing\",\n    \"permission-denied\",\n    \"error-state\",\n    \"loading-state\",\n    \"main-content\",\n  ].forEach((id) => {\n    document.getElementById(id)?.classList.add(\"hidden\");\n  });\n}\n\n/**\n * Show setup required panel.\n */\nfunction showSetupRequired(error: PrInsightsError): void {\n  const panel = document.getElementById(\"setup-required\");\n  if (!panel) return showGenericError(error.title, error.message);\n\n  const messageEl = document.getElementById(\"setup-message\");\n  if (messageEl) messageEl.textContent = error.message;\n\n  const details = error.details as SetupRequiredDetails;\n  if (details?.instructions && Array.isArray(details.instructions)) {\n    const stepsList = document.getElementById(\"setup-steps\");\n    if (stepsList) {\n      // SECURITY: Escape instructions to prevent XSS\n      stepsList.innerHTML = details.instructions\n        .map((s: string) => `<li>${escapeHtml(s)}</li>`)\n        .join(\"\");\n    }\n  }\n\n  if (details?.docsUrl) {\n    const docsLink = document.getElementById(\n      \"docs-link\",\n    ) as HTMLAnchorElement | null;\n    if (docsLink) docsLink.href = String(details.docsUrl);\n  }\n\n  panel.classList.remove(\"hidden\");\n}\n\n/**\n * Show multiple pipelines panel.\n */\nfunction showMultiplePipelines(error: PrInsightsError): void {\n  const panel = document.getElementById(\"multiple-pipelines\");\n  if (!panel) return showGenericError(error.title, error.message);\n\n  const messageEl = document.getElementById(\"multiple-message\");\n  if (messageEl) messageEl.textContent = error.message;\n\n  const listEl = document.getElementById(\"pipeline-list\");\n  const details = error.details as MultiplePipelinesDetails;\n  if (listEl && details?.matches && Array.isArray(details.matches)) {\n    // SECURITY: Escape pipeline names to prevent XSS\n    listEl.innerHTML = details.matches\n      .map(\n        (m: any) => `\n                <a href=\"?pipelineId=${escapeHtml(String(m.id))}\" class=\"pipeline-option\">\n                    <strong>${escapeHtml(m.name)}</strong>\n                    <span class=\"pipeline-id\">ID: ${escapeHtml(String(m.id))}</span>\n                </a>\n            `,\n      )\n      .join(\"\");\n  }\n\n  panel.classList.remove(\"hidden\");\n}\n\n/**\n * Show permission denied panel.\n */\nfunction showPermissionDenied(error: PrInsightsError): void {\n  const panel = document.getElementById(\"permission-denied\");\n  if (!panel) return showGenericError(error.title, error.message);\n\n  const messageEl = document.getElementById(\"permission-message\");\n  if (messageEl) messageEl.textContent = error.message;\n\n  panel.classList.remove(\"hidden\");\n}\n\n/**\n * Show generic error state.\n */\nfunction showGenericError(title: string, message: string): void {\n  const panel = document.getElementById(\"error-state\");\n  if (!panel) return;\n\n  const titleEl = document.getElementById(\"error-title\");\n  const messageEl = document.getElementById(\"error-message\");\n\n  if (titleEl) titleEl.textContent = title;\n  if (messageEl) messageEl.textContent = message;\n\n  panel.classList.remove(\"hidden\");\n}\n\n/**\n * Show artifacts missing panel.\n */\nfunction showArtifactsMissing(error: PrInsightsError): void {\n  const panel = document.getElementById(\"artifacts-missing\");\n  if (!panel) return showGenericError(error.title, error.message);\n\n  const messageEl = document.getElementById(\"missing-message\");\n  if (messageEl) messageEl.textContent = error.message;\n\n  const details = error.details as ArtifactsMissingDetails;\n  if (details?.instructions && Array.isArray(details.instructions)) {\n    const stepsList = document.getElementById(\"missing-steps\");\n    if (stepsList) {\n      stepsList.innerHTML = details.instructions\n        .map((s: string) => `<li>${s}</li>`)\n        .join(\"\");\n    }\n  }\n\n  panel.classList.remove(\"hidden\");\n}\n\n// ============================================================================\n// DOM and Event Handling\n// ============================================================================\n\n/**\n * Cache DOM elements for performance.\n */\nfunction cacheElements(): void {\n  const ids = [\n    \"app\",\n    \"loading-state\",\n    \"error-state\",\n    \"main-content\",\n    \"error-title\",\n    \"error-message\",\n    \"run-info\",\n    \"date-range\",\n    \"custom-dates\",\n    \"start-date\",\n    \"end-date\",\n    \"retry-btn\",\n    \"total-prs\",\n    \"cycle-p50\",\n    \"cycle-p90\",\n    \"authors-count\",\n    \"reviewers-count\",\n    \"throughput-chart\",\n    \"cycle-distribution\",\n    \"total-prs-delta\",\n    \"cycle-p50-delta\",\n    \"cycle-p90-delta\",\n    \"authors-delta\",\n    \"reviewers-delta\",\n    \"repo-filter\",\n    \"team-filter\",\n    \"repo-filter-group\",\n    \"team-filter-group\",\n    \"clear-filters\",\n    \"active-filters\",\n    \"filter-chips\",\n    \"total-prs-sparkline\",\n    \"cycle-p50-sparkline\",\n    \"cycle-p90-sparkline\",\n    \"authors-sparkline\",\n    \"reviewers-sparkline\",\n    \"cycle-time-trend\",\n    \"reviewer-activity\",\n    \"compare-toggle\",\n    \"comparison-banner\",\n    \"current-period-dates\",\n    \"previous-period-dates\",\n    \"exit-compare\",\n    \"export-btn\",\n    \"export-menu\",\n    \"export-csv\",\n    \"export-link\",\n    \"export-raw-zip\",\n  ];\n\n  ids.forEach((id) => {\n    elements[id] = document.getElementById(id);\n  });\n\n  elements.tabs = document.querySelectorAll(\".tab\");\n}\n\n/**\n * Initialize Phase 5 features.\n */\nfunction initializePhase5Features(): void {\n  const phase5Tabs = document.querySelectorAll(\".phase5-tab\");\n\n  if (ENABLE_PHASE5_FEATURES) {\n    phase5Tabs.forEach((tab) => tab.classList.remove(\"hidden\"));\n    console.log(\"Phase 5 features enabled\");\n  } else {\n    console.log(\"Phase 5 features disabled\");\n  }\n}\n\n/**\n * Set up event listeners.\n */\nfunction setupEventListeners(): void {\n  elements[\"date-range\"]?.addEventListener(\"change\", handleDateRangeChange);\n  document\n    .getElementById(\"apply-dates\")\n    ?.addEventListener(\"click\", applyCustomDates);\n\n  elements.tabs?.forEach((tab: HTMLElement) => {\n    tab.addEventListener(\"click\", () => {\n      const tabId = tab.dataset[\"tab\"];\n      if (tabId) switchTab(tabId);\n    });\n  });\n\n  elements[\"retry-btn\"]?.addEventListener(\"click\", () => init());\n  document\n    .getElementById(\"setup-retry-btn\")\n    ?.addEventListener(\"click\", () => init());\n  document\n    .getElementById(\"permission-retry-btn\")\n    ?.addEventListener(\"click\", () => init());\n\n  elements[\"repo-filter\"]?.addEventListener(\"change\", handleFilterChange);\n  elements[\"team-filter\"]?.addEventListener(\"change\", handleFilterChange);\n  elements[\"clear-filters\"]?.addEventListener(\"click\", clearAllFilters);\n\n  elements[\"compare-toggle\"]?.addEventListener(\"click\", toggleComparisonMode);\n  elements[\"exit-compare\"]?.addEventListener(\"click\", exitComparisonMode);\n\n  elements[\"export-btn\"]?.addEventListener(\"click\", toggleExportMenu);\n  elements[\"export-csv\"]?.addEventListener(\"click\", exportToCsv);\n  elements[\"export-link\"]?.addEventListener(\"click\", copyShareableLink);\n  elements[\"export-raw-zip\"]?.addEventListener(\"click\", downloadRawDataZip);\n\n  document.addEventListener(\"click\", (e: MouseEvent) => {\n    const target = e.target as HTMLElement;\n    if (!target.closest(\".export-dropdown\")) {\n      elements[\"export-menu\"]?.classList.add(\"hidden\");\n    }\n  });\n}\n\n// ============================================================================\n// Data Loading and Rendering\n// ============================================================================\n\n/**\n * Load the dataset.\n */\nasync function loadDataset(): Promise<void> {\n  showLoading();\n\n  try {\n    if (!loader) throw new Error(\"Loader not initialized\");\n\n    // Load manifest first\n    const manifest = await loader.loadManifest();\n\n    // Load dimensions\n    const dimensions = await loader.loadDimensions();\n\n    // Populate filter dropdowns from dimensions\n    populateFilterDropdowns(dimensions);\n\n    // Show dataset info\n    updateDatasetInfo(manifest);\n\n    // Restore state from URL if present\n    restoreStateFromUrl();\n\n    // Set initial date range from manifest defaults\n    setInitialDateRange();\n\n    // Load and render metrics\n    await refreshMetrics();\n\n    // Update feature tabs based on manifest\n    await updateFeatureTabs();\n\n    showContent();\n  } catch (error) {\n    console.error(\"Failed to load dataset:\", error);\n    handleError(error);\n  }\n}\n\n/**\n * Set initial date range from manifest defaults.\n */\nfunction setInitialDateRange(): void {\n  // Skip if already restored from URL\n  if (currentDateRange.start && currentDateRange.end) return;\n  if (!loader) return;\n\n  const coverage = loader.getCoverage() || null;\n  const defaultDays = loader.getDefaultRangeDays() || 90;\n\n  if (coverage?.date_range?.max) {\n    const endDate = new Date(coverage.date_range.max);\n    const startDate = new Date(endDate);\n    startDate.setDate(startDate.getDate() - defaultDays);\n\n    currentDateRange = { start: startDate, end: endDate };\n\n    if (elements[\"start-date\"]) {\n      elements[\"start-date\"].value = startDate.toISOString().split(\"T\")[0];\n    }\n    if (elements[\"end-date\"]) {\n      elements[\"end-date\"].value = endDate.toISOString().split(\"T\")[0];\n    }\n  }\n}\n\n/**\n * Calculate the previous period date range for comparison.\n */\nfunction getPreviousPeriod(start: Date, end: Date): { start: Date; end: Date } {\n  const durationMs = end.getTime() - start.getTime();\n  const prevEnd = new Date(start.getTime() - 1); // Day before current start\n  const prevStart = new Date(prevEnd.getTime() - durationMs);\n  return { start: prevStart, end: prevEnd };\n}\n\n/**\n * Apply dimension filters to rollups data.\n * Uses by_repository slices when available for accurate filtering.\n */\nfunction applyFiltersToRollups(\n  rollups: Rollup[],\n  filters: { repos: string[]; teams: string[] },\n): Rollup[] {\n  // No filters active - return original data\n  if (!filters.repos.length && !filters.teams.length) {\n    return rollups;\n  }\n\n  return rollups.map((rollup) => {\n    // If we have by_repository slices and repo filter is active, use them\n    if (filters.repos.length && rollup.by_repository) {\n      const selectedRepos = filters.repos\n        .map((repoId) => {\n          const repoData = rollup.by_repository![repoId];\n          if (repoData) return repoData;\n\n          return Object.entries(rollup.by_repository!).find(\n            ([name]) => name === repoId,\n          )?.[1];\n        })\n        .filter(Boolean) as any[];\n\n      if (selectedRepos.length === 0) {\n        return {\n          ...rollup,\n          pr_count: 0,\n          cycle_time_p50: null,\n          cycle_time_p90: null,\n          authors_count: 0,\n          reviewers_count: 0,\n        };\n      }\n\n      // Aggregate metrics\n      const totalPrCount = selectedRepos.reduce(\n        (sum, r) => sum + (r.pr_count || 0),\n        0,\n      );\n      const p50Values = selectedRepos\n        .map((r) => r.cycle_time_p50)\n        .filter((v) => v != null);\n      const p90Values = selectedRepos\n        .map((r) => r.cycle_time_p90)\n        .filter((v) => v != null);\n\n      const avgP50 =\n        p50Values.length > 0\n          ? p50Values.reduce((a, b) => a + b, 0) / p50Values.length\n          : null;\n      const avgP90 =\n        p90Values.length > 0\n          ? p90Values.reduce((a, b) => a + b, 0) / p90Values.length\n          : null;\n\n      const totalAuthors = selectedRepos.reduce(\n        (sum, r) => sum + (r.authors_count || 0),\n        0,\n      );\n      const totalReviewers = selectedRepos.reduce(\n        (sum, r) => sum + (r.reviewers_count || 0),\n        0,\n      );\n\n      return {\n        ...rollup,\n        pr_count: totalPrCount,\n        cycle_time_p50: avgP50,\n        cycle_time_p90: avgP90,\n        authors_count: totalAuthors,\n        reviewers_count: totalReviewers,\n      } as Rollup;\n    }\n\n    // If we have by_team slices and team filter is active, use them\n    if (filters.teams.length && rollup.by_team) {\n      const selectedTeams = filters.teams\n        .map((teamId) => rollup.by_team![teamId])\n        .filter(Boolean) as any[];\n\n      if (selectedTeams.length === 0) {\n        return {\n          ...rollup,\n          pr_count: 0,\n          cycle_time_p50: null,\n          cycle_time_p90: null,\n          authors_count: 0,\n          reviewers_count: 0,\n        };\n      }\n\n      const totalPrCount = selectedTeams.reduce(\n        (sum, t) => sum + (t.pr_count || 0),\n        0,\n      );\n      const p50Values = selectedTeams\n        .map((t) => t.cycle_time_p50)\n        .filter((v) => v != null);\n      const avgP50 =\n        p50Values.length > 0\n          ? p50Values.reduce((a, b) => a + b, 0) / p50Values.length\n          : null;\n\n      return {\n        ...rollup,\n        pr_count: totalPrCount,\n        cycle_time_p50: avgP50,\n      } as Rollup;\n    }\n\n    return rollup;\n  });\n}\n\n/**\n * Refresh metrics for current date range.\n */\nasync function refreshMetrics(): Promise<void> {\n  if (!currentDateRange.start || !currentDateRange.end || !loader) return;\n\n  // Load current period data\n  const rawRollups = await loader.getWeeklyRollups(\n    currentDateRange.start,\n    currentDateRange.end,\n  );\n\n  const distributions = await loader.getDistributions(\n    currentDateRange.start,\n    currentDateRange.end,\n  );\n\n  // Apply dimension filters to rollups\n  const rollups = applyFiltersToRollups(rawRollups, currentFilters);\n\n  // Load previous period data for comparison\n  const prevPeriod = getPreviousPeriod(\n    currentDateRange.start,\n    currentDateRange.end,\n  );\n  let prevRollups: Rollup[] = [];\n  try {\n    const rawPrevRollups = await loader.getWeeklyRollups(\n      prevPeriod.start,\n      prevPeriod.end,\n    );\n    prevRollups = applyFiltersToRollups(rawPrevRollups, currentFilters);\n  } catch (e) {\n    console.debug(\"Previous period data not available:\", e);\n  }\n\n  // Cache filtered rollups for export\n  cachedRollups = rollups;\n\n  renderSummaryCards(rollups, prevRollups);\n  renderThroughputChart(rollups);\n  renderCycleTimeTrend(rollups);\n  renderReviewerActivity(rollups);\n  renderCycleDistribution(distributions);\n\n  // Update comparison banner if in comparison mode\n  if (comparisonMode) {\n    updateComparisonBanner();\n  }\n}\n\ninterface CalculatedMetrics {\n  totalPrs: number;\n  cycleP50: number | null;\n  cycleP90: number | null;\n  avgAuthors: number;\n  avgReviewers: number;\n}\n\n/**\n * Calculate metrics from rollups data.\n */\nfunction calculateMetrics(rollups: Rollup[]): CalculatedMetrics {\n  if (!rollups || !rollups.length) {\n    return {\n      totalPrs: 0,\n      cycleP50: null,\n      cycleP90: null,\n      avgAuthors: 0,\n      avgReviewers: 0,\n    };\n  }\n\n  const totalPrs = rollups.reduce((sum, r) => sum + (r.pr_count || 0), 0);\n\n  const p50Values = rollups\n    .map((r) => r.cycle_time_p50)\n    .filter((v): v is number => v !== null && v !== undefined);\n  const p90Values = rollups\n    .map((r) => r.cycle_time_p90)\n    .filter((v): v is number => v !== null && v !== undefined);\n\n  const authorsSum = rollups.reduce(\n    (sum, r) => sum + (r.authors_count || 0),\n    0,\n  );\n  const reviewersSum = rollups.reduce(\n    (sum, r) => sum + (r.reviewers_count || 0),\n    0,\n  );\n\n  return {\n    totalPrs,\n    cycleP50: p50Values.length ? median(p50Values) : null,\n    cycleP90: p90Values.length ? median(p90Values) : null,\n    avgAuthors:\n      rollups.length > 0 ? Math.round(authorsSum / rollups.length) : 0,\n    avgReviewers:\n      rollups.length > 0 ? Math.round(reviewersSum / rollups.length) : 0,\n  };\n}\n\n/**\n * Calculate percentage change between two values.\n */\nfunction calculatePercentChange(\n  current: number | null | undefined,\n  previous: number | null | undefined,\n): number | null {\n  if (previous === null || previous === undefined || previous === 0) {\n    return null;\n  }\n  if (current === null || current === undefined) {\n    return null;\n  }\n  return ((current - previous) / previous) * 100;\n}\n\n/**\n * Render a delta indicator element.\n */\nfunction renderDelta(\n  element: HTMLElement | null,\n  percentChange: number | null,\n  inverse = false,\n): void {\n  if (!element) return;\n\n  if (percentChange === null) {\n    element.innerHTML = \"\";\n    element.className = \"metric-delta\";\n    return;\n  }\n\n  const isNeutral = Math.abs(percentChange) < 2; // Within 2% is neutral\n  const isPositive = percentChange > 0;\n  const absChange = Math.abs(percentChange);\n\n  let cssClass = \"metric-delta \";\n  let arrow = \"\";\n\n  if (isNeutral) {\n    cssClass += \"delta-neutral\";\n    arrow = \"~\";\n  } else if (isPositive) {\n    cssClass += inverse ? \"delta-negative-inverse\" : \"delta-positive\";\n    arrow = \"&#9650;\"; // Up arrow\n  } else {\n    cssClass += inverse ? \"delta-positive-inverse\" : \"delta-negative\";\n    arrow = \"&#9660;\"; // Down arrow\n  }\n\n  const sign = isPositive ? \"+\" : \"\";\n  element.className = cssClass;\n  element.innerHTML = `<span class=\"delta-arrow\">${arrow}</span> ${sign}${absChange.toFixed(0)}% <span class=\"delta-label\">vs prev</span>`;\n}\n\n/**\n * Render a sparkline SVG from data points.\n */\nfunction renderSparkline(element: HTMLElement | null, values: number[]): void {\n  if (!element || !values || values.length < 2) {\n    if (element) element.innerHTML = \"\";\n    return;\n  }\n\n  // Take last 8 values for sparkline\n  const data = values.slice(-8);\n  const width = 60;\n  const height = 24;\n  const padding = 2;\n\n  const minVal = Math.min(...data);\n  const maxVal = Math.max(...data);\n  const range = maxVal - minVal || 1;\n\n  // Calculate points\n  const points = data.map((val, i) => {\n    const x = padding + (i / (data.length - 1)) * (width - padding * 2);\n    const y =\n      height - padding - ((val - minVal) / range) * (height - padding * 2);\n    return { x, y };\n  });\n\n  // Create path\n  const pathD = points\n    .map((p, i) => `${i === 0 ? \"M\" : \"L\"} ${p.x.toFixed(1)} ${p.y.toFixed(1)}`)\n    .join(\" \");\n\n  // Create area path (closed)\n  const areaD =\n    pathD +\n    ` L ${points[points.length - 1]!.x.toFixed(1)} ${height - padding} L ${points[0]!.x.toFixed(1)} ${height - padding} Z`;\n\n  // Last point for dot\n  const lastPoint = points[points.length - 1]!;\n\n  element.innerHTML = `\n        <svg viewBox=\"0 0 ${width} ${height}\" preserveAspectRatio=\"none\">\n            <path class=\"sparkline-area\" d=\"${areaD}\"/>\n            <path class=\"sparkline-line\" d=\"${pathD}\"/>\n            <circle class=\"sparkline-dot\" cx=\"${lastPoint.x.toFixed(1)}\" cy=\"${lastPoint.y.toFixed(1)}\" r=\"2\"/>\n        </svg>\n    `;\n}\n\n/**\n * Extract sparkline data from rollups.\n */\nfunction extractSparklineData(rollups: Rollup[]): {\n  prCounts: number[];\n  p50s: number[];\n  p90s: number[];\n  authors: number[];\n  reviewers: number[];\n} {\n  if (!rollups || !rollups.length) {\n    return { prCounts: [], p50s: [], p90s: [], authors: [], reviewers: [] };\n  }\n\n  return {\n    prCounts: rollups.map((r) => r.pr_count || 0),\n    p50s: rollups\n      .map((r) => r.cycle_time_p50)\n      .filter((v): v is number => v !== null && v !== undefined),\n    p90s: rollups\n      .map((r) => r.cycle_time_p90)\n      .filter((v): v is number => v !== null && v !== undefined),\n    authors: rollups.map((r) => r.authors_count || 0),\n    reviewers: rollups.map((r) => r.reviewers_count || 0),\n  };\n}\n\n/**\n * Render summary metric cards.\n */\nfunction renderSummaryCards(\n  rollups: Rollup[],\n  prevRollups: Rollup[] = [],\n): void {\n  if (metricsCollector) metricsCollector.mark(\"render-summary-cards-start\");\n\n  const current = calculateMetrics(rollups);\n  const previous = calculateMetrics(prevRollups);\n\n  // Render metric values\n  if (elements[\"total-prs\"])\n    elements[\"total-prs\"].textContent = current.totalPrs.toLocaleString();\n  if (elements[\"cycle-p50\"])\n    elements[\"cycle-p50\"].textContent =\n      current.cycleP50 !== null ? formatDuration(current.cycleP50) : \"-\";\n  if (elements[\"cycle-p90\"])\n    elements[\"cycle-p90\"].textContent =\n      current.cycleP90 !== null ? formatDuration(current.cycleP90) : \"-\";\n  if (elements[\"authors-count\"])\n    elements[\"authors-count\"].textContent = current.avgAuthors.toLocaleString();\n  if (elements[\"reviewers-count\"]) {\n    elements[\"reviewers-count\"].textContent =\n      current.avgReviewers.toLocaleString();\n  }\n\n  // Render sparklines\n  const sparklineData = extractSparklineData(rollups);\n  renderSparkline(elements[\"total-prs-sparkline\"], sparklineData.prCounts);\n  renderSparkline(elements[\"cycle-p50-sparkline\"], sparklineData.p50s);\n  renderSparkline(elements[\"cycle-p90-sparkline\"], sparklineData.p90s);\n  renderSparkline(elements[\"authors-sparkline\"], sparklineData.authors);\n  renderSparkline(elements[\"reviewers-sparkline\"], sparklineData.reviewers);\n\n  // Render deltas (only if we have previous period data)\n  if (prevRollups && prevRollups.length > 0) {\n    renderDelta(\n      elements[\"total-prs-delta\"],\n      calculatePercentChange(current.totalPrs, previous.totalPrs),\n      false,\n    );\n    renderDelta(\n      elements[\"cycle-p50-delta\"],\n      calculatePercentChange(current.cycleP50, previous.cycleP50),\n      true,\n    ); // Inverse: lower is better\n    renderDelta(\n      elements[\"cycle-p90-delta\"],\n      calculatePercentChange(current.cycleP90, previous.cycleP90),\n      true,\n    ); // Inverse: lower is better\n    renderDelta(\n      elements[\"authors-delta\"],\n      calculatePercentChange(current.avgAuthors, previous.avgAuthors),\n      false,\n    );\n    renderDelta(\n      elements[\"reviewers-delta\"],\n      calculatePercentChange(current.avgReviewers, previous.avgReviewers),\n      false,\n    );\n  } else {\n    // Clear deltas if no previous data\n    [\n      \"total-prs-delta\",\n      \"cycle-p50-delta\",\n      \"cycle-p90-delta\",\n      \"authors-delta\",\n      \"reviewers-delta\",\n    ].forEach((id) => {\n      const el = elements[id];\n      if (el) {\n        el.innerHTML = \"\";\n        el.className = \"metric-delta\";\n      }\n    });\n  }\n\n  if (metricsCollector) {\n    metricsCollector.mark(\"render-summary-cards-end\");\n    metricsCollector.mark(\"first-meaningful-paint\");\n    metricsCollector.measure(\n      \"init-to-fmp\",\n      \"dashboard-init\",\n      \"first-meaningful-paint\",\n    );\n  }\n}\n\n/**\n * Calculate moving average for trend line.\n */\nfunction calculateMovingAverage(\n  values: number[],\n  window = 4,\n): (number | null)[] {\n  const result: (number | null)[] = [];\n  for (let i = 0; i < values.length; i++) {\n    if (i < window - 1) {\n      result.push(null);\n    } else {\n      const sum = values\n        .slice(i - window + 1, i + 1)\n        .reduce((a, b) => a + b, 0);\n      result.push(sum / window);\n    }\n  }\n  return result;\n}\n\n/**\n * Render throughput chart with trend line overlay.\n */\nfunction renderThroughputChart(rollups: Rollup[]): void {\n  const chartEl = elements[\"throughput-chart\"];\n  if (!chartEl) return;\n\n  if (!rollups || !rollups.length) {\n    chartEl.innerHTML = '<p class=\"no-data\">No data for selected range</p>';\n    return;\n  }\n\n  const prCounts = rollups.map((r) => r.pr_count || 0);\n  const maxCount = Math.max(...prCounts);\n  const movingAvg = calculateMovingAverage(prCounts, 4);\n\n  // Render bar chart\n  const barsHtml = rollups\n    .map((r) => {\n      const height = maxCount > 0 ? ((r.pr_count || 0) / maxCount) * 100 : 0;\n      return `\n            <div class=\"bar-container\" title=\"${r.week}: ${r.pr_count || 0} PRs\">\n                <div class=\"bar\" style=\"height: ${height}%\"></div>\n                <div class=\"bar-label\">${r.week.split(\"-W\")[1]}</div>\n            </div>\n        `;\n    })\n    .join(\"\");\n\n  // Render trend line SVG overlay\n  let trendLineHtml = \"\";\n  if (rollups.length >= 4) {\n    const validPoints = movingAvg\n      .map((val, i) => ({ val, i }))\n      .filter((p): p is { val: number; i: number } => p.val !== null);\n\n    if (validPoints.length >= 2) {\n      const chartHeight = 200;\n      const chartPadding = 8;\n\n      // Calculate SVG path points\n      const points = validPoints.map((p) => {\n        const x = (p.i / (rollups.length - 1)) * 100;\n        const y =\n          maxCount > 0\n            ? chartHeight -\n            chartPadding -\n            (p.val / maxCount) * (chartHeight - chartPadding * 2)\n            : chartHeight / 2;\n        return { x, y };\n      });\n\n      const pathD = points\n        .map(\n          (pt, i) =>\n            `${i === 0 ? \"M\" : \"L\"} ${pt.x.toFixed(1)}% ${pt.y.toFixed(1)}`,\n        )\n        .join(\" \");\n\n      trendLineHtml = `\n                <div class=\"trend-line-overlay\">\n                    <svg viewBox=\"0 0 100 ${chartHeight}\" preserveAspectRatio=\"none\">\n                        <path class=\"trend-line\" d=\"${pathD}\" vector-effect=\"non-scaling-stroke\"/>\n                    </svg>\n                </div>\n            `;\n    }\n  }\n\n  // Legend\n  const legendHtml = `\n        <div class=\"chart-legend\">\n            <div class=\"legend-item\">\n                <span class=\"legend-bar\"></span>\n                <span>Weekly PRs</span>\n            </div>\n            <div class=\"legend-item\">\n                <span class=\"legend-line\"></span>\n                <span>4-week avg</span>\n            </div>\n        </div>\n    `;\n\n  chartEl.innerHTML = `\n        <div class=\"chart-with-trend\">\n            <div class=\"bar-chart\">${barsHtml}</div>\n            ${trendLineHtml}\n        </div>\n        ${legendHtml}\n    `;\n}\n\n/**\n * Render cycle time distribution.\n */\nfunction renderCycleDistribution(distributions: any[]): void {\n  const distEl = elements[\"cycle-distribution\"];\n  if (!distEl) return;\n\n  if (!distributions || !distributions.length) {\n    distEl.innerHTML = '<p class=\"no-data\">No data for selected range</p>';\n    return;\n  }\n\n  const buckets: Record<string, number> = {\n    \"0-1h\": 0,\n    \"1-4h\": 0,\n    \"4-24h\": 0,\n    \"1-3d\": 0,\n    \"3-7d\": 0,\n    \"7d+\": 0,\n  };\n  distributions.forEach((d) => {\n    Object.entries(d.cycle_time_buckets || {}).forEach(([key, val]) => {\n      buckets[key] = (buckets[key] || 0) + (val as number);\n    });\n  });\n\n  const total = Object.values(buckets).reduce((a, b) => a + b, 0);\n  if (total === 0) {\n    distEl.innerHTML = '<p class=\"no-data\">No cycle time data</p>';\n    return;\n  }\n\n  const html = Object.entries(buckets)\n    .map(([label, count]) => {\n      const pct = ((count / total) * 100).toFixed(1);\n      return `\n            <div class=\"dist-row\">\n                <span class=\"dist-label\">${label}</span>\n                <div class=\"dist-bar-bg\">\n                    <div class=\"dist-bar\" style=\"width: ${pct}%\"></div>\n                </div>\n                <span class=\"dist-value\">${count} (${pct}%)</span>\n            </div>\n        `;\n    })\n    .join(\"\");\n\n  distEl.innerHTML = html;\n}\n\n/**\n * Render cycle time trend chart (line chart with P50 and P90).\n */\nfunction renderCycleTimeTrend(rollups: Rollup[]): void {\n  const trendEl = elements[\"cycle-time-trend\"];\n  if (!trendEl) return;\n\n  if (!rollups || rollups.length < 2) {\n    trendEl.innerHTML = '<p class=\"no-data\">Not enough data for trend</p>';\n    return;\n  }\n\n  const p50Data = rollups\n    .map((r) => ({ week: r.week, value: r.cycle_time_p50 }))\n    .filter((d): d is { week: string; value: number } => d.value !== null);\n  const p90Data = rollups\n    .map((r) => ({ week: r.week, value: r.cycle_time_p90 }))\n    .filter((d): d is { week: string; value: number } => d.value !== null);\n\n  if (p50Data.length < 2 && p90Data.length < 2) {\n    trendEl.innerHTML = '<p class=\"no-data\">No cycle time data available</p>';\n    return;\n  }\n\n  const allValues = [\n    ...p50Data.map((d) => d.value),\n    ...p90Data.map((d) => d.value),\n  ];\n  const maxVal = Math.max(...allValues);\n  const minVal = Math.min(...allValues);\n  const range = maxVal - minVal || 1;\n\n  const width = 100;\n  const height = 180;\n  const padding = { top: 10, right: 10, bottom: 25, left: 40 };\n  const chartWidth = width - padding.left - padding.right;\n  const chartHeight = height - padding.top - padding.bottom;\n\n  // Generate paths\n  const generatePath = (data: { week: string; value: number }[]) => {\n    const points = data.map((d) => {\n      const dataIndex = rollups.findIndex((r) => r.week === d.week);\n      const x = padding.left + (dataIndex / (rollups.length - 1)) * chartWidth;\n      const y =\n        padding.top + chartHeight - ((d.value - minVal) / range) * chartHeight;\n      return { x, y, week: d.week, value: d.value };\n    });\n    const pathD = points\n      .map(\n        (p, i) => `${i === 0 ? \"M\" : \"L\"} ${p.x.toFixed(1)} ${p.y.toFixed(1)}`,\n      )\n      .join(\" \");\n    return { pathD, points };\n  };\n\n  const p50Path = p50Data.length >= 2 ? generatePath(p50Data) : null;\n  const p90Path = p90Data.length >= 2 ? generatePath(p90Data) : null;\n\n  // Y-axis labels\n  const yLabels = [minVal, (minVal + maxVal) / 2, maxVal];\n\n  const svgContent = `\n        <svg viewBox=\"0 0 ${width} ${height}\" preserveAspectRatio=\"xMidYMid meet\">\n            <!-- Grid lines -->\n            ${yLabels\n      .map((val, i) => {\n        const y =\n          padding.top +\n          chartHeight -\n          (i / (yLabels.length - 1)) * chartHeight;\n        return `<line class=\"line-chart-grid\" x1=\"${padding.left}\" y1=\"${y}\" x2=\"${width - padding.right}\" y2=\"${y}\"/>`;\n      })\n      .join(\"\")}\n\n            <!-- Y-axis labels -->\n            ${yLabels\n      .map((val, i) => {\n        const y =\n          padding.top +\n          chartHeight -\n          (i / (yLabels.length - 1)) * chartHeight;\n        return `<text class=\"line-chart-axis\" x=\"${padding.left - 4}\" y=\"${y + 3}\" text-anchor=\"end\">${formatDuration(val)}</text>`;\n      })\n      .join(\"\")}\n\n            <!-- Lines -->\n            ${p90Path ? `<path class=\"line-chart-p90\" d=\"${p90Path.pathD}\" vector-effect=\"non-scaling-stroke\"/>` : \"\"}\n            ${p50Path ? `<path class=\"line-chart-p50\" d=\"${p50Path.pathD}\" vector-effect=\"non-scaling-stroke\"/>` : \"\"}\n\n            <!-- Dots -->\n            ${p90Path ? p90Path.points.map((p) => `<circle class=\"line-chart-dot\" cx=\"${p.x}\" cy=\"${p.y}\" r=\"3\" fill=\"var(--warning)\" data-week=\"${p.week}\" data-value=\"${p.value}\" data-metric=\"P90\"/>`).join(\"\") : \"\"}\n            ${p50Path ? p50Path.points.map((p) => `<circle class=\"line-chart-dot\" cx=\"${p.x}\" cy=\"${p.y}\" r=\"3\" fill=\"var(--primary)\" data-week=\"${p.week}\" data-value=\"${p.value}\" data-metric=\"P50\"/>`).join(\"\") : \"\"}\n        </svg>\n    `;\n\n  const legendHtml = `\n        <div class=\"chart-legend\">\n            <div class=\"legend-item\">\n                <span class=\"chart-tooltip-dot legend-p50\"></span>\n                <span>P50 (Median)</span>\n            </div>\n            <div class=\"legend-item\">\n                <span class=\"chart-tooltip-dot legend-p90\"></span>\n                <span>P90</span>\n            </div>\n        </div>\n    `;\n\n  trendEl.innerHTML = `<div class=\"line-chart\">${svgContent}</div>${legendHtml}`;\n\n  // Add tooltip interactions\n  addChartTooltips(trendEl, (dot: HTMLElement) => {\n    const week = dot.dataset[\"week\"];\n    const value = parseFloat(dot.dataset[\"value\"] || \"0\");\n    const metric = dot.dataset[\"metric\"];\n    return `\n            <div class=\"chart-tooltip-title\">${week}</div>\n            <div class=\"chart-tooltip-row\">\n                <span class=\"chart-tooltip-label\">\n                    <span class=\"chart-tooltip-dot ${metric === \"P50\" ? \"legend-p50\" : \"legend-p90\"}\"></span>\n                    ${metric}\n                </span>\n                <span>${formatDuration(value)}</span>\n            </div>\n        `;\n  });\n}\n\n/**\n * Render reviewer activity chart (horizontal bar chart).\n */\nfunction renderReviewerActivity(rollups: Rollup[]): void {\n  const revEl = elements[\"reviewer-activity\"];\n  if (!revEl) return;\n\n  if (!rollups || !rollups.length) {\n    revEl.innerHTML = '<p class=\"no-data\">No reviewer data available</p>';\n    return;\n  }\n\n  // Take last 8 weeks for display\n  const recentRollups = rollups.slice(-8);\n  const maxReviewers = Math.max(\n    ...recentRollups.map((r) => r.reviewers_count || 0),\n  );\n\n  if (maxReviewers === 0) {\n    revEl.innerHTML = '<p class=\"no-data\">No reviewer data available</p>';\n    return;\n  }\n\n  const barsHtml = recentRollups\n    .map((r) => {\n      const count = r.reviewers_count || 0;\n      const pct = (count / maxReviewers) * 100;\n      const weekLabel = r.week.split(\"-W\")[1];\n      return `\n            <div class=\"h-bar-row\" title=\"${r.week}: ${count} reviewers\">\n                <span class=\"h-bar-label\">W${weekLabel}</span>\n                <div class=\"h-bar-container\">\n                    <div class=\"h-bar\" style=\"width: ${pct}%\"></div>\n                </div>\n                <span class=\"h-bar-value\">${count}</span>\n            </div>\n        `;\n    })\n    .join(\"\");\n\n  revEl.innerHTML = `<div class=\"horizontal-bar-chart\">${barsHtml}</div>`;\n}\n\n/**\n * Add tooltip interactions to a chart.\n */\nfunction addChartTooltips(\n  container: HTMLElement,\n  contentFn: (dot: HTMLElement) => string,\n): void {\n  const dots = container.querySelectorAll(\".line-chart-dot\");\n  let tooltip: HTMLElement | null = null;\n\n  dots.forEach((dotNode) => {\n    const dot = dotNode as HTMLElement;\n    dot.addEventListener(\"mouseenter\", () => {\n      if (!tooltip) {\n        tooltip = document.createElement(\"div\");\n        tooltip.className = \"chart-tooltip\";\n        container.appendChild(tooltip);\n      }\n      tooltip.innerHTML = contentFn(dot);\n      tooltip.style.display = \"block\";\n\n      // Position tooltip\n      const rect = container.getBoundingClientRect();\n      const dotRect = dot.getBoundingClientRect();\n      tooltip.style.left = `${dotRect.left - rect.left + 10}px`;\n      tooltip.style.top = `${dotRect.top - rect.top - 40}px`;\n    });\n\n    dot.addEventListener(\"mouseleave\", () => {\n      if (tooltip) {\n        tooltip.style.display = \"none\";\n      }\n    });\n  });\n}\n\n/**\n * Update feature tabs based on manifest.\n */\nasync function updateFeatureTabs(): Promise<void> {\n  if (!loader) return;\n\n  // Check if loader supports loadPredictions/loadInsights\n  if (typeof (loader as any).loadPredictions !== \"function\") return;\n\n  const predictionsContent = document.getElementById(\"tab-predictions\");\n  const predictionsUnavailable = document.getElementById(\n    \"predictions-unavailable\",\n  );\n  if (predictionsContent) {\n    const predictionsResult = await (loader as any).loadPredictions();\n\n    if (\n      predictionsResult?.state === \"ok\" &&\n      predictionsResult.data?.forecasts?.length > 0\n    ) {\n      renderPredictions(predictionsContent, predictionsResult.data);\n    } else if (predictionsUnavailable) {\n      predictionsUnavailable.classList.remove(\"hidden\");\n    }\n  }\n\n  const aiContent = document.getElementById(\"tab-ai-insights\");\n  const aiUnavailable = document.getElementById(\"ai-unavailable\");\n  if (aiContent) {\n    const insightsResult = await (loader as any).loadInsights();\n\n    if (\n      insightsResult?.state === \"ok\" &&\n      insightsResult.data?.insights?.length > 0\n    ) {\n      renderAIInsights(aiContent, insightsResult.data);\n    } else if (aiUnavailable) {\n      aiUnavailable.classList.remove(\"hidden\");\n    }\n  }\n}\n\n/**\n * Render predictions.\n */\nfunction renderPredictions(container: HTMLElement, predictions: any): void {\n  const content = document.createElement(\"div\");\n  content.className = \"predictions-content\";\n\n  if (predictions.is_stub) {\n    content.innerHTML += `<div class=\"stub-warning\"> Demo data</div>`;\n  }\n\n  predictions.forecasts.forEach((forecast: any) => {\n    const label = forecast.metric\n      .replace(/_/g, \" \")\n      .replace(/\\b\\w/g, (c: string) => c.toUpperCase());\n    // SECURITY: Escape all user-controlled data to prevent XSS\n    content.innerHTML += `\n            <div class=\"forecast-section\">\n                <h4>${escapeHtml(label)} (${escapeHtml(String(forecast.unit))})</h4>\n                <table class=\"forecast-table\">\n                    <thead><tr><th>Week</th><th>Predicted</th><th>Range</th></tr></thead>\n                    <tbody>\n                        ${forecast.values\n        .map(\n          (v: any) => `\n                            <tr>\n                                <td>${escapeHtml(String(v.period_start))}</td>\n                                <td>${escapeHtml(String(v.predicted))}</td>\n                                <td>${escapeHtml(String(v.lower_bound))} - ${escapeHtml(String(v.upper_bound))}</td>\n                            </tr>\n                        `,\n        )\n        .join(\"\")}\n                    </tbody>\n                </table>\n            </div>\n        `;\n  });\n\n  const unavailable = container.querySelector(\".feature-unavailable\");\n  if (unavailable) unavailable.classList.add(\"hidden\");\n  container.appendChild(content);\n}\n\n/**\n * Render AI insights.\n */\nfunction renderAIInsights(container: HTMLElement, insights: any): void {\n  const content = document.createElement(\"div\");\n  content.className = \"insights-content\";\n\n  if (insights.is_stub) {\n    content.innerHTML += `<div class=\"stub-warning\"> Demo data</div>`;\n  }\n\n  const icons: Record<string, string> = {\n    critical: \"\",\n    warning: \"\",\n    info: \"\",\n  };\n  [\"critical\", \"warning\", \"info\"].forEach((severity) => {\n    const items = insights.insights.filter((i: any) => i.severity === severity);\n    if (!items.length) return;\n\n    // SECURITY: Escape all user-controlled data to prevent XSS\n    content.innerHTML += `\n            <div class=\"severity-section\">\n                <h4>${icons[severity]} ${severity.charAt(0).toUpperCase() + severity.slice(1)}</h4>\n                <div class=\"insight-cards\">\n                    ${items\n        .map(\n          (i: any) => `\n                        <div class=\"insight-card ${escapeHtml(String(i.severity))}\">\n                            <div class=\"insight-category\">${escapeHtml(String(i.category))}</div>\n                            <h5>${escapeHtml(String(i.title))}</h5>\n                            <p>${escapeHtml(String(i.description))}</p>\n                        </div>\n                    `,\n        )\n        .join(\"\")}\n                </div>\n            </div>\n        `;\n  });\n\n  const unavailable = container.querySelector(\".feature-unavailable\");\n  if (unavailable) unavailable.classList.add(\"hidden\");\n  container.appendChild(content);\n}\n\n// ============================================================================\n// Event Handlers\n// ============================================================================\n\nfunction handleDateRangeChange(e: Event): void {\n  const target = e.target as HTMLSelectElement;\n  const value = target.value;\n\n  if (value === \"custom\") {\n    elements[\"custom-dates\"]?.classList.remove(\"hidden\");\n    return;\n  }\n\n  elements[\"custom-dates\"]?.classList.add(\"hidden\");\n\n  const days = parseInt(value, 10);\n  const coverage = loader?.getCoverage() || null;\n  const endDate = coverage?.date_range?.max\n    ? new Date(coverage.date_range.max)\n    : new Date();\n  const startDate = new Date(endDate);\n  startDate.setDate(startDate.getDate() - days);\n\n  currentDateRange = { start: startDate, end: endDate };\n  updateUrlState();\n  refreshMetrics();\n}\n\nfunction applyCustomDates(): void {\n  const start = (elements[\"start-date\"] as HTMLInputElement)?.value;\n  const end = (elements[\"end-date\"] as HTMLInputElement)?.value;\n\n  if (!start || !end) return;\n\n  currentDateRange = { start: new Date(start), end: new Date(end) };\n  updateUrlState();\n  refreshMetrics();\n}\n\nfunction switchTab(tabId: string): void {\n  elements.tabs?.forEach((tab: HTMLElement) => {\n    tab.classList.toggle(\"active\", tab.dataset[\"tab\"] === tabId);\n  });\n\n  document.querySelectorAll(\".tab-content\").forEach((content) => {\n    content.classList.toggle(\"active\", content.id === `tab-${tabId}`);\n    content.classList.toggle(\"hidden\", content.id !== `tab-${tabId}`);\n  });\n\n  updateUrlState();\n}\n\n// ============================================================================\n// Filter Management\n// ============================================================================\n\n/**\n * Populate filter dropdowns from loaded dimensions.\n *\n * IMPORTANT: The dimensions from aggregators.py use these property names:\n * - Repositories: repository_id, repository_name, project_name, organization_name\n * - Teams: team_id, team_name, project_name, organization_name, member_count\n *\n * The filter values MUST use repository_name/team_name because that's how\n * the by_repository and by_team slices in weekly rollups are keyed.\n */\nfunction populateFilterDropdowns(dimensions: any): void {\n  if (!dimensions) return;\n\n  // Populate repository filter\n  const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;\n  if (repoFilter && dimensions.repositories?.length > 0) {\n    repoFilter.innerHTML = '<option value=\"\">All</option>';\n    dimensions.repositories.forEach((repo: any) => {\n      const option = document.createElement(\"option\");\n      // Use repository_name as value (matches by_repository keys in rollups)\n      option.value = repo.repository_name;\n      option.textContent = repo.repository_name;\n      repoFilter.appendChild(option);\n    });\n    elements[\"repo-filter-group\"]?.classList.remove(\"hidden\");\n  } else {\n    elements[\"repo-filter-group\"]?.classList.add(\"hidden\");\n  }\n\n  // Populate team filter\n  const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;\n  if (teamFilter && dimensions.teams?.length > 0) {\n    teamFilter.innerHTML = '<option value=\"\">All</option>';\n    dimensions.teams.forEach((team: any) => {\n      const option = document.createElement(\"option\");\n      // Use team_name as value (matches by_team keys in rollups)\n      option.value = team.team_name;\n      option.textContent = team.team_name;\n      teamFilter.appendChild(option);\n    });\n    elements[\"team-filter-group\"]?.classList.remove(\"hidden\");\n  } else {\n    elements[\"team-filter-group\"]?.classList.add(\"hidden\");\n  }\n\n  // Restore filter state from URL\n  restoreFiltersFromUrl();\n}\n\n/**\n * Handle filter dropdown change.\n */\nfunction handleFilterChange(): void {\n  const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;\n  const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;\n\n  const repoValues = repoFilter\n    ? Array.from(repoFilter.selectedOptions)\n      .map((o) => o.value)\n      .filter((v) => v)\n    : [];\n  const teamValues = teamFilter\n    ? Array.from(teamFilter.selectedOptions)\n      .map((o) => o.value)\n      .filter((v) => v)\n    : [];\n\n  currentFilters = { repos: repoValues, teams: teamValues };\n\n  updateFilterUI();\n  updateUrlState();\n  refreshMetrics();\n}\n\n/**\n * Clear all filters.\n */\nfunction clearAllFilters(): void {\n  currentFilters = { repos: [], teams: [] };\n\n  const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;\n  const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;\n\n  if (repoFilter) {\n    Array.from(repoFilter.options).forEach(\n      (o) => (o.selected = o.value === \"\"),\n    );\n  }\n  if (teamFilter) {\n    Array.from(teamFilter.options).forEach(\n      (o) => (o.selected = o.value === \"\"),\n    );\n  }\n\n  updateFilterUI();\n  updateUrlState();\n  refreshMetrics();\n}\n\n/**\n * Remove a specific filter.\n */\nfunction removeFilter(type: string, value: string): void {\n  if (type === \"repo\") {\n    currentFilters.repos = currentFilters.repos.filter((v) => v !== value);\n    const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;\n    if (repoFilter) {\n      const option = repoFilter.querySelector(\n        `option[value=\"${value}\"]`,\n      ) as HTMLOptionElement | null;\n      if (option) option.selected = false;\n    }\n  } else if (type === \"team\") {\n    currentFilters.teams = currentFilters.teams.filter((v) => v !== value);\n    const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;\n    if (teamFilter) {\n      const option = teamFilter.querySelector(\n        `option[value=\"${value}\"]`,\n      ) as HTMLOptionElement | null;\n      if (option) option.selected = false;\n    }\n  }\n\n  updateFilterUI();\n  updateUrlState();\n  refreshMetrics();\n}\n\n/**\n * Update filter UI.\n */\nfunction updateFilterUI(): void {\n  const hasFilters =\n    currentFilters.repos.length > 0 || currentFilters.teams.length > 0;\n\n  if (elements[\"clear-filters\"]) {\n    elements[\"clear-filters\"].classList.toggle(\"hidden\", !hasFilters);\n  }\n\n  if (elements[\"active-filters\"] && elements[\"filter-chips\"]) {\n    elements[\"active-filters\"].classList.toggle(\"hidden\", !hasFilters);\n\n    if (hasFilters) {\n      renderFilterChips();\n    } else {\n      elements[\"filter-chips\"].innerHTML = \"\";\n    }\n  }\n}\n\n/**\n * Render filter chips for active filters.\n */\nfunction renderFilterChips(): void {\n  const chipsEl = elements[\"filter-chips\"] as HTMLElement | null;\n  if (!chipsEl) return;\n\n  const chips: string[] = [];\n\n  currentFilters.repos.forEach((value) => {\n    const label = getFilterLabel(\"repo\", value);\n    chips.push(createFilterChip(\"repo\", value, label));\n  });\n\n  currentFilters.teams.forEach((value) => {\n    const label = getFilterLabel(\"team\", value);\n    chips.push(createFilterChip(\"team\", value, label));\n  });\n\n  chipsEl.innerHTML = chips.join(\"\");\n\n  chipsEl.querySelectorAll(\".filter-chip-remove\").forEach((btnNode) => {\n    const btn = btnNode as HTMLElement;\n    btn.addEventListener(\"click\", () => {\n      const type = btn.dataset[\"type\"];\n      const val = btn.dataset[\"value\"];\n      if (type && val) removeFilter(type, val);\n    });\n  });\n}\n\n/**\n * Get display label for a filter value.\n */\nfunction getFilterLabel(type: string, value: string): string {\n  if (type === \"repo\") {\n    const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;\n    const option = repoFilter?.querySelector(`option[value=\"${value}\"]`);\n    return option?.textContent || value;\n  }\n  if (type === \"team\") {\n    const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;\n    const option = teamFilter?.querySelector(`option[value=\"${value}\"]`);\n    return option?.textContent || value;\n  }\n  return value;\n}\n\n/**\n * Create HTML for a filter chip.\n */\nfunction createFilterChip(type: string, value: string, label: string): string {\n  const prefix = type === \"repo\" ? \"repo\" : \"team\";\n  return `\n        <span class=\"filter-chip\">\n            <span class=\"filter-chip-label\">${prefix}: ${label}</span>\n            <span class=\"filter-chip-remove\" data-type=\"${type}\" data-value=\"${value}\">&times;</span>\n        </span>\n    `;\n}\n\n/**\n * Restore filters from URL parameters.\n */\nfunction restoreFiltersFromUrl(): void {\n  const params = new URLSearchParams(window.location.search);\n\n  const reposParam = params.get(\"repos\");\n  const teamsParam = params.get(\"teams\");\n\n  if (reposParam) {\n    currentFilters.repos = reposParam.split(\",\").filter((v) => v);\n    const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;\n    if (repoFilter) {\n      currentFilters.repos.forEach((value) => {\n        const option = repoFilter.querySelector(\n          `option[value=\"${value}\"]`,\n        ) as HTMLOptionElement | null;\n        if (option) option.selected = true;\n      });\n    }\n  }\n\n  if (teamsParam) {\n    currentFilters.teams = teamsParam.split(\",\").filter((v) => v);\n    const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;\n    if (teamFilter) {\n      currentFilters.teams.forEach((value) => {\n        const option = teamFilter.querySelector(\n          `option[value=\"${value}\"]`,\n        ) as HTMLOptionElement | null;\n        if (option) option.selected = true;\n      });\n    }\n  }\n\n  updateFilterUI();\n}\n\n// ============================================================================\n// Comparison Mode\n// ============================================================================\n\n/**\n * Toggle comparison mode on/off.\n */\nfunction toggleComparisonMode(): void {\n  comparisonMode = !comparisonMode;\n\n  elements[\"compare-toggle\"]?.classList.toggle(\"active\", comparisonMode);\n  elements[\"comparison-banner\"]?.classList.toggle(\"hidden\", !comparisonMode);\n\n  if (comparisonMode) {\n    updateComparisonBanner();\n  }\n\n  updateUrlState();\n  refreshMetrics();\n}\n\n/**\n * Exit comparison mode.\n */\nfunction exitComparisonMode(): void {\n  comparisonMode = false;\n  elements[\"compare-toggle\"]?.classList.remove(\"active\");\n  elements[\"comparison-banner\"]?.classList.add(\"hidden\");\n  updateUrlState();\n  refreshMetrics();\n}\n\n/**\n * Update the comparison banner with date ranges.\n */\nfunction updateComparisonBanner(): void {\n  if (!currentDateRange.start || !currentDateRange.end) return;\n\n  const formatDate = (date: Date) =>\n    date.toLocaleDateString(\"en-US\", {\n      month: \"short\",\n      day: \"numeric\",\n      year: \"numeric\",\n    });\n\n  // Current period\n  const currentStart = formatDate(currentDateRange.start);\n  const currentEnd = formatDate(currentDateRange.end);\n  if (elements[\"current-period-dates\"]) {\n    elements[\"current-period-dates\"].textContent =\n      `${currentStart} - ${currentEnd}`;\n  }\n\n  // Previous period\n  const prevPeriod = getPreviousPeriod(\n    currentDateRange.start,\n    currentDateRange.end,\n  );\n  const prevStart = formatDate(prevPeriod.start);\n  const prevEnd = formatDate(prevPeriod.end);\n  if (elements[\"previous-period-dates\"]) {\n    elements[\"previous-period-dates\"].textContent = `${prevStart} - ${prevEnd}`;\n  }\n}\n\n// ============================================================================\n// Export Functions\n// ============================================================================\n\n/**\n * Toggle export menu visibility.\n */\nfunction toggleExportMenu(e: Event): void {\n  e.stopPropagation();\n  elements[\"export-menu\"]?.classList.toggle(\"hidden\");\n}\n\n/**\n * Export current data to CSV.\n */\nfunction exportToCsv(): void {\n  elements[\"export-menu\"]?.classList.add(\"hidden\");\n\n  if (!cachedRollups || cachedRollups.length === 0) {\n    showToast(\"No data to export\", \"error\");\n    return;\n  }\n\n  // Build CSV content\n  const headers = [\n    \"Week\",\n    \"Start Date\",\n    \"End Date\",\n    \"PR Count\",\n    \"Cycle Time P50 (min)\",\n    \"Cycle Time P90 (min)\",\n    \"Authors\",\n    \"Reviewers\",\n  ];\n  const rows = cachedRollups.map((r) => [\n    r.week,\n    r.start_date || \"\",\n    r.end_date || \"\",\n    r.pr_count || 0,\n    r.cycle_time_p50 != null ? r.cycle_time_p50.toFixed(1) : \"\",\n    r.cycle_time_p90 != null ? r.cycle_time_p90.toFixed(1) : \"\",\n    r.authors_count || 0,\n    r.reviewers_count || 0,\n  ]);\n\n  const csvContent = [headers, ...rows]\n    .map((row) => row.map((cell) => `\"${cell}\"`).join(\",\"))\n    .join(\"\\n\");\n\n  // Download file\n  const blob = new Blob([csvContent], { type: \"text/csv;charset=utf-8;\" });\n  const url = URL.createObjectURL(blob);\n  const link = document.createElement(\"a\");\n  link.href = url;\n\n  const dateStr = new Date().toISOString().split(\"T\")[0];\n  link.download = `pr-insights-${dateStr}.csv`;\n\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n  URL.revokeObjectURL(url);\n\n  showToast(\"CSV exported successfully\", \"success\");\n}\n\n/**\n * Copy shareable link to clipboard.\n */\nasync function copyShareableLink(): Promise<void> {\n  elements[\"export-menu\"]?.classList.add(\"hidden\");\n\n  try {\n    await navigator.clipboard.writeText(window.location.href);\n    showToast(\"Link copied to clipboard\", \"success\");\n  } catch (_err) {\n    // Fallback\n    const textArea = document.createElement(\"textarea\");\n    textArea.value = window.location.href;\n    document.body.appendChild(textArea);\n    textArea.select();\n    document.execCommand(\"copy\");\n    document.body.removeChild(textArea);\n    showToast(\"Link copied to clipboard\", \"success\");\n  }\n}\n\n/**\n * Download raw CSV data as a ZIP file.\n */\nasync function downloadRawDataZip(): Promise<void> {\n  elements[\"export-menu\"]?.classList.add(\"hidden\");\n\n  if (!currentBuildId || !artifactClient) {\n    showToast(\"Raw data not available in direct URL mode\", \"error\");\n    return;\n  }\n\n  try {\n    showToast(\"Preparing download...\", \"success\");\n\n    const artifact = await artifactClient.getArtifactMetadata(\n      currentBuildId,\n      \"csv-output\",\n    );\n\n    if (!artifact) {\n      showToast(\"Raw CSV artifact not found in this pipeline run\", \"error\");\n      return;\n    }\n\n    const downloadUrl = artifact.resource?.downloadUrl;\n    if (!downloadUrl) {\n      showToast(\"Download URL not available\", \"error\");\n      return;\n    }\n\n    let zipUrl = downloadUrl;\n    if (!zipUrl.includes(\"format=zip\")) {\n      const separator = zipUrl.includes(\"?\") ? \"&\" : \"?\";\n      zipUrl = `${zipUrl}${separator}format=zip`;\n    }\n\n    // Use the protected method from ArtifactClient\n    const response = await (artifactClient as any)._authenticatedFetch(zipUrl);\n\n    if (!response.ok) {\n      if (response.status === 403 || response.status === 401) {\n        showToast(\"Permission denied to download artifacts\", \"error\");\n      } else {\n        showToast(`Download failed: ${response.statusText}`, \"error\");\n      }\n      return;\n    }\n\n    const blob = await response.blob();\n    const url = URL.createObjectURL(blob);\n    const link = document.createElement(\"a\");\n    link.href = url;\n\n    const dateStr = new Date().toISOString().split(\"T\")[0];\n    link.download = `pr-insights-raw-data-${dateStr}.zip`;\n\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    URL.revokeObjectURL(url);\n\n    showToast(\"Download started\", \"success\");\n  } catch (err) {\n    console.error(\"Failed to download raw data:\", err);\n    showToast(\"Failed to download raw data\", \"error\");\n  }\n}\n\n/**\n * Show a toast notification.\n */\nfunction showToast(\n  message: string,\n  type: \"success\" | \"error\" = \"success\",\n): void {\n  const toast = document.createElement(\"div\");\n  toast.className = `toast ${type}`;\n  toast.textContent = message;\n  document.body.appendChild(toast);\n\n  setTimeout(() => {\n    toast.remove();\n  }, 3000);\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\nfunction showLoading(): void {\n  hideAllPanels();\n  elements[\"loading-state\"]?.classList.remove(\"hidden\");\n}\n\nfunction showContent(): void {\n  hideAllPanels();\n  elements[\"main-content\"]?.classList.remove(\"hidden\");\n}\n\nfunction updateDatasetInfo(manifest: any): void {\n  const generatedAt = manifest?.generated_at\n    ? new Date(manifest.generated_at).toLocaleString()\n    : \"Unknown\";\n  const runId = manifest?.run_id || \"\";\n\n  const runInfo = elements[\"run-info\"];\n  if (runInfo) {\n    runInfo.textContent = `Generated: ${generatedAt}`;\n    if (runId) runInfo.textContent += ` | Run: ${runId.slice(0, 8)}`;\n  }\n}\n\nfunction formatDuration(minutes: number): string {\n  if (minutes < 60) return `${Math.round(minutes)}m`;\n  if (minutes < 1440) return `${(minutes / 60).toFixed(1)}h`;\n  return `${(minutes / 1440).toFixed(1)}d`;\n}\n\nfunction median(arr: number[]): number {\n  const sorted = [...arr].sort((a, b) => a - b);\n  const mid = Math.floor(sorted.length / 2);\n  return sorted.length % 2\n    ? sorted[mid]!\n    : (sorted[mid - 1]! + sorted[mid]!) / 2;\n}\n\nfunction updateUrlState(): void {\n  const params = new URLSearchParams(window.location.search);\n  const newParams = new URLSearchParams();\n\n  // Preserve config params\n  if (params.get(\"dataset\")) newParams.set(\"dataset\", params.get(\"dataset\")!);\n  if (params.get(\"pipelineId\"))\n    newParams.set(\"pipelineId\", params.get(\"pipelineId\")!);\n\n  // Add date range\n  if (currentDateRange.start) {\n    newParams.set(\"start\", currentDateRange.start.toISOString().split(\"T\")[0]!);\n  }\n  if (currentDateRange.end) {\n    newParams.set(\"end\", currentDateRange.end.toISOString().split(\"T\")[0]!);\n  }\n\n  // Add active tab\n  const activeTab = document.querySelector(\".tab.active\") as HTMLElement | null;\n  if (activeTab && activeTab.dataset[\"tab\"] !== \"metrics\") {\n    newParams.set(\"tab\", activeTab.dataset[\"tab\"]!);\n  }\n\n  // Add filters\n  if (currentFilters.repos.length > 0) {\n    newParams.set(\"repos\", currentFilters.repos.join(\",\"));\n  }\n  if (currentFilters.teams.length > 0) {\n    newParams.set(\"teams\", currentFilters.teams.join(\",\"));\n  }\n\n  // Add comparison mode\n  if (comparisonMode) {\n    newParams.set(\"compare\", \"1\");\n  }\n\n  window.history.replaceState(\n    {},\n    \"\",\n    `${window.location.pathname}?${newParams.toString()}`,\n  );\n}\n\nfunction restoreStateFromUrl(): void {\n  const params = new URLSearchParams(window.location.search);\n\n  const startParam = params.get(\"start\");\n  const endParam = params.get(\"end\");\n  if (startParam && endParam) {\n    currentDateRange = { start: new Date(startParam), end: new Date(endParam) };\n    const dateRangeEl = elements[\"date-range\"] as HTMLSelectElement | null;\n    if (dateRangeEl) {\n      dateRangeEl.value = \"custom\";\n      elements[\"custom-dates\"]?.classList.remove(\"hidden\");\n    }\n    if (elements[\"start-date\"]) elements[\"start-date\"].value = startParam;\n    if (elements[\"end-date\"]) elements[\"end-date\"].value = endParam;\n  }\n\n  const tabParam = params.get(\"tab\");\n  if (tabParam) {\n    setTimeout(() => switchTab(tabParam), 0);\n  }\n\n  // Restore comparison mode\n  const compareParam = params.get(\"compare\");\n  if (compareParam === \"1\") {\n    comparisonMode = true;\n    elements[\"compare-toggle\"]?.classList.add(\"active\");\n    elements[\"comparison-banner\"]?.classList.remove(\"hidden\");\n  }\n}\n\n// ============================================================================\n// Initialize\n// ============================================================================\n\nif (document.readyState === \"loading\") {\n  document.addEventListener(\"DOMContentLoaded\", init);\n} else {\n  init();\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "E:\\projects\\ado-git-repo-insights\\extension\\ui\\dataset-loader.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 72,
        "column": 41,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 72,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2325, 2328], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2325, 2328], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 101,
        "column": 43,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 101,
        "endColumn": 46,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3418, 3421], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3418, 3421], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 178,
        "column": 21,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 178,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4989, 4992], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4989, 4992], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 179,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 179,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5020, 5023], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5020, 5023], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 195,
        "column": 14,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 195,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5471, 5474], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5471, 5474], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 211,
        "column": 21,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 211,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5797, 5800], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5797, 5800], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 249,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 249,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6667, 6670], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6667, 6670], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 315,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 315,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8000, 8003], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8000, 8003], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 316,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 316,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8034, 8037], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8034, 8037], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 318,
        "column": 61,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 318,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8171, 8174], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8171, 8174], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 319,
        "column": 18,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 319,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8196, 8199], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8196, 8199], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 321,
        "column": 31,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 321,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8264, 8267], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8264, 8267], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 322,
        "column": 28,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 322,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8297, 8300], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8297, 8300], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 331,
        "column": 23,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 331,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8522, 8525], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8522, 8525], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 332,
        "column": 25,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 332,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8565, 8568], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8565, 8568], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 334,
        "column": 49,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 334,
        "endColumn": 52,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8701, 8704], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8701, 8704], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 383,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 383,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10279, 10282], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10279, 10282], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 412,
        "column": 40,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 412,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11055, 11058], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11055, 11058], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 443,
        "column": 35,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 443,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12041, 12044], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12041, 12044], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 479,
        "column": 13,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 479,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [13074, 13077], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [13074, 13077], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 533,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 533,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [14542, 14545], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [14542, 14545], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 542,
        "column": 12,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 542,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [14934, 14937], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [14934, 14937], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 583,
        "column": 15,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 583,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [16141, 16144], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [16141, 16144], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 628,
        "column": 61,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 628,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [17554, 17557], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [17554, 17557], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 651,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 651,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [18038, 18041], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [18038, 18041], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 652,
        "column": 14,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 652,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [18056, 18059], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [18056, 18059], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 656,
        "column": 70,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 656,
        "endColumn": 73,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [18219, 18222], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [18219, 18222], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 721,
        "column": 67,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 721,
        "endColumn": 70,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [20193, 20196], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [20193, 20196], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 728,
        "column": 20,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 728,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [20418, 20421], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [20418, 20421], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 742,
        "column": 13,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 742,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [20795, 20798], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [20795, 20798], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 772,
        "column": 18,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 772,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [21444, 21447], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [21444, 21447], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 787,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 787,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [21766, 21769], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [21766, 21769], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 836,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 836,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [23130, 23133], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [23130, 23133], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 885,
        "column": 52,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 885,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [24481, 24484], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [24481, 24484], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 919,
        "column": 46,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 919,
        "endColumn": 49,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [25463, 25466], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [25463, 25466], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 35,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Dataset Loader Module\n *\n * Implements the dataset-contract.md specification.\n * This module is the ONLY data layer - fully dataset-driven,\n * usable by both extension UI and future CLI dashboard.\n */\n\nimport { getErrorMessage } from \"./types\";\n\n// Supported schema versions (from dataset-contract.md)\nconst SUPPORTED_MANIFEST_VERSION = 1;\nconst SUPPORTED_DATASET_VERSION = 1;\nconst SUPPORTED_AGGREGATES_VERSION = 1;\n\n/**\n * Candidate paths to search for dataset-manifest.json.\n * CRITICAL: Only flat layout supported (manifest at root OR in aggregates/).\n * Double-nesting (aggregates/aggregates) is DEPRECATED and will hard-fail.\n * Order matters: first match wins.\n */\nexport const DATASET_CANDIDATE_PATHS = [\n  \"\", // Root of provided base URL (preferred)\n  \"aggregates\", // Single nesting (legacy ADO artifact download)\n];\n\n/**\n * Error message for deprecated double-nested layout.\n */\nexport const DEPRECATED_LAYOUT_ERROR =\n  \"Deprecated dataset layout detected (aggregates/aggregates nesting). \" +\n  \"This layout is no longer supported. Please re-run the pipeline with the \" +\n  \"updated YAML configuration and re-stage artifacts.\";\n\n/**\n * Interface for Rollup data structure.\n */\nexport interface Rollup {\n  week: string;\n  pr_count: number;\n  cycle_time_p50: number | null;\n  cycle_time_p90: number | null;\n  authors_count: number;\n  reviewers_count: number;\n  by_repository: Record<string, number> | null;\n  by_team: Record<string, number> | null;\n  [key: string]: unknown; // Allow for extra fields preserved during normalization\n}\n\n/**\n * Version Adapter Pattern (Phase 7.4)\n *\n * Normalizes rollup data across schema versions, providing sensible defaults\n * for missing fields in older datasets. This ensures backward compatibility\n * when loading datasets generated by older versions of the pipeline.\n */\nexport const ROLLUP_FIELD_DEFAULTS = {\n  pr_count: 0,\n  cycle_time_p50: null,\n  cycle_time_p90: null,\n  authors_count: 0,\n  reviewers_count: 0,\n  by_repository: null, // null indicates feature not available\n  by_team: null, // null indicates feature not available\n} as const;\n\n/**\n * Normalize a single rollup object to ensure all expected fields exist.\n * @param rollup - Raw rollup data from JSON\n * @returns Normalized rollup with all expected fields\n */\nexport function normalizeRollup(rollup: any): Rollup {\n  if (!rollup || typeof rollup !== \"object\") {\n    return { week: \"unknown\", ...ROLLUP_FIELD_DEFAULTS };\n  }\n\n  return {\n    // Preserve all existing fields\n    ...rollup,\n    // Ensure required fields have defaults (don't override if already set)\n    pr_count: rollup.pr_count ?? ROLLUP_FIELD_DEFAULTS.pr_count,\n    cycle_time_p50:\n      rollup.cycle_time_p50 ?? ROLLUP_FIELD_DEFAULTS.cycle_time_p50,\n    cycle_time_p90:\n      rollup.cycle_time_p90 ?? ROLLUP_FIELD_DEFAULTS.cycle_time_p90,\n    authors_count: rollup.authors_count ?? ROLLUP_FIELD_DEFAULTS.authors_count,\n    reviewers_count:\n      rollup.reviewers_count ?? ROLLUP_FIELD_DEFAULTS.reviewers_count,\n    // by_repository and by_team are optional features - preserve null if missing\n    by_repository:\n      rollup.by_repository !== undefined ? rollup.by_repository : null,\n    by_team: rollup.by_team !== undefined ? rollup.by_team : null,\n  };\n}\n\n/**\n * Normalize an array of rollup objects.\n * @param rollups - Array of raw rollup data\n * @returns Normalized rollups\n */\nexport function normalizeRollups(rollups: any[] | null | undefined): Rollup[] {\n  if (!Array.isArray(rollups)) {\n    return [];\n  }\n  return rollups.map(normalizeRollup);\n}\n\n/**\n * Semaphore for bounded concurrent fetching (Phase 4).\n * All fetches and retries MUST acquire through this singleton.\n */\nexport const fetchSemaphore = {\n  maxConcurrent: 4,\n  maxRetries: 1,\n  retryDelayMs: 200,\n  active: 0,\n  queue: [] as Array<() => void>,\n\n  /**\n   * Acquire a semaphore slot. Blocks until slot available.\n   * @returns {Promise<void>}\n   */\n  acquire(): Promise<void> {\n    return new Promise((resolve) => {\n      if (this.active < this.maxConcurrent) {\n        this.active++;\n        resolve();\n      } else {\n        this.queue.push(resolve);\n      }\n    });\n  },\n\n  /**\n   * Release a semaphore slot. Unblocks next waiter if any.\n   */\n  release(): void {\n    const next = this.queue.shift();\n    if (next) {\n      next();\n    } else {\n      this.active--;\n    }\n  },\n\n  /**\n   * Get current state (for testing).\n   * @returns {{ active: number, queued: number }}\n   */\n  getState(): { active: number; queued: number } {\n    return { active: this.active, queued: this.queue.length };\n  },\n\n  /**\n   * Reset semaphore state (for testing).\n   */\n  reset(): void {\n    this.active = 0;\n    this.queue = [];\n  },\n};\n\n/**\n * LRU Cache interface.\n */\nexport interface RollupCache {\n  maxSize: number;\n  ttlMs: number;\n  clock: () => number;\n  makeKey(params: {\n    week: string;\n    org: string;\n    project: string;\n    repo: string;\n    branch?: string;\n    apiVersion?: string;\n  }): string;\n  get(key: string): any;\n  set(key: string, value: any): void;\n  has(key: string): boolean;\n  clear(): void;\n  size(): number;\n}\n\n/**\n * Create an LRU cache with TTL and bounded size (Phase 4).\n * @param clock - Injected time source (default: Date.now)\n * @returns Cache instance\n */\nexport function createRollupCache(clock: () => number = Date.now): RollupCache {\n  const maxSize = 52; // 1 year of weeks\n  const ttlMs = 5 * 60 * 1000; // 5 minutes\n  const entries = new Map<\n    string,\n    { value: any; createdAt: number; touchedAt: number }\n  >();\n\n  /**\n   * Required fields for cache key.\n   */\n  const requiredKeyFields = [\"week\", \"org\", \"project\", \"repo\"] as const;\n\n  return {\n    maxSize,\n    ttlMs,\n    clock,\n\n    /**\n     * Build composite cache key. Throws if required params missing.\n     */\n    makeKey(params: any) {\n      for (const field of requiredKeyFields) {\n        if (!params[field]) {\n          throw new Error(`Cache key missing required field: ${field}`);\n        }\n      }\n      const {\n        week,\n        org,\n        project,\n        repo,\n        branch = \"\",\n        apiVersion = \"1\",\n      } = params;\n      return `${week}|${org}|${project}|${repo}|${branch}|${apiVersion}`;\n    },\n\n    /**\n     * Get cached value if valid.\n     */\n    get(key: string) {\n      const entry = entries.get(key);\n      if (!entry) return undefined;\n\n      const now = clock();\n      if (now - entry.createdAt > ttlMs) {\n        entries.delete(key);\n        return undefined;\n      }\n\n      // Update LRU touch time\n      entry.touchedAt = now;\n      return entry.value;\n    },\n\n    /**\n     * Set cache value, evicting oldest if at capacity.\n     */\n    set(key: string, value: any) {\n      const now = clock();\n\n      // Evict oldest by touchedAt if at capacity\n      if (entries.size >= maxSize && !entries.has(key)) {\n        let oldestKey: string | null = null;\n        let oldestTime = Infinity;\n        for (const [k, v] of entries) {\n          if (v.touchedAt < oldestTime) {\n            oldestTime = v.touchedAt;\n            oldestKey = k;\n          }\n        }\n        if (oldestKey) entries.delete(oldestKey);\n      }\n\n      entries.set(key, {\n        value,\n        createdAt: now,\n        touchedAt: now,\n      });\n    },\n\n    /**\n     * Check if key exists and is not expired.\n     */\n    has(key: string) {\n      return this.get(key) !== undefined;\n    },\n\n    /**\n     * Clear all entries.\n     */\n    clear() {\n      entries.clear();\n    },\n\n    /**\n     * Get cache size.\n     */\n    size() {\n      return entries.size;\n    },\n  };\n}\n\nexport interface ProgressEvent {\n  loaded: number;\n  total: number;\n  currentWeek: string | null;\n}\n\nexport interface RollupResult {\n  data: Rollup[];\n  missingWeeks: string[];\n  failedWeeks: string[];\n  partial: boolean;\n  authError: boolean;\n  degraded: boolean;\n}\n\n/**\n * Core interface for data loading.\n * Shared by both direct (fetch-based) and authenticated (ADO artifact-based) loaders.\n */\nexport interface IDatasetLoader {\n  loadManifest(): Promise<any>;\n  loadDimensions(): Promise<any>;\n  getWeeklyRollups(startDate: Date, endDate: Date): Promise<Rollup[]>;\n  getDistributions(startDate: Date, endDate: Date): Promise<any[]>;\n  getCoverage(): any;\n  getDefaultRangeDays(): number;\n  loadPredictions?(): Promise<any>;\n  loadInsights?(): Promise<any>;\n}\n\n/**\n * Dataset loader state\n */\nexport class DatasetLoader implements IDatasetLoader {\n  protected baseUrl: string;\n  protected effectiveBaseUrl: string | null = null; // Resolved after probing\n  protected manifest: any | null = null;\n  protected dimensions: any | null = null;\n  protected rollupCache = new Map<string, Rollup>(); // week -> data\n  protected distributionCache = new Map<string, any>(); // year -> data\n\n  constructor(baseUrl?: string) {\n    this.baseUrl = baseUrl || \"\";\n    this.effectiveBaseUrl = null; // Will be resolved on first manifest load\n  }\n\n  /**\n   * Resolve the dataset root by probing candidate paths for manifest.\n   * Caches the result for subsequent path resolutions.\n   * @returns The effective base URL or null if not found\n   */\n  async resolveDatasetRoot(): Promise<string | null> {\n    if (this.effectiveBaseUrl !== null) {\n      return this.effectiveBaseUrl || null;\n    }\n\n    for (const candidate of DATASET_CANDIDATE_PATHS) {\n      const candidateBase = candidate\n        ? `${this.baseUrl}/${candidate}`\n        : this.baseUrl;\n      const manifestUrl = candidateBase\n        ? `${candidateBase}/dataset-manifest.json`\n        : \"dataset-manifest.json\";\n\n      try {\n        const response = await fetch(manifestUrl, { method: \"HEAD\" });\n        if (response.ok) {\n          console.log(`[DatasetLoader] Found manifest at: ${manifestUrl}`);\n          this.effectiveBaseUrl = candidateBase;\n          return candidateBase;\n        }\n      } catch {\n        // Continue to next candidate on network error\n      }\n    }\n\n    // No manifest found in any candidate path - fall back to original baseUrl\n    console.warn(\n      \"[DatasetLoader] No manifest found in candidate paths, using baseUrl as fallback\",\n    );\n    this.effectiveBaseUrl = this.baseUrl;\n    return null;\n  }\n\n  /**\n   * Load and validate the dataset manifest.\n   * Automatically resolves nested dataset root before loading.\n   */\n  async loadManifest(): Promise<any> {\n    // Resolve dataset root if not already done\n    if (this.effectiveBaseUrl === null) {\n      await this.resolveDatasetRoot();\n    }\n\n    const url = this.resolvePath(\"dataset-manifest.json\");\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      if (response.status === 404) {\n        throw new Error(\n          \"Dataset not found. Ensure the analytics pipeline has run successfully.\",\n        );\n      }\n      throw new Error(\n        `Failed to load manifest: ${response.status} ${response.statusText}`,\n      );\n    }\n\n    const manifest = await response.json();\n    this.validateManifest(manifest);\n    this.manifest = manifest;\n    return manifest;\n  }\n\n  /**\n   * Validate manifest schema versions.\n   */\n  protected validateManifest(manifest: any): void {\n    if (!manifest.manifest_schema_version) {\n      throw new Error(\"Invalid manifest: missing schema version\");\n    }\n\n    if (manifest.manifest_schema_version > SUPPORTED_MANIFEST_VERSION) {\n      throw new Error(\n        `Manifest version ${manifest.manifest_schema_version} not supported. ` +\n        `Maximum supported: ${SUPPORTED_MANIFEST_VERSION}. ` +\n        `Please update the extension.`,\n      );\n    }\n\n    if (manifest.dataset_schema_version > SUPPORTED_DATASET_VERSION) {\n      throw new Error(\n        `Dataset version ${manifest.dataset_schema_version} not supported. ` +\n        `Please update the extension.`,\n      );\n    }\n\n    if (manifest.aggregates_schema_version > SUPPORTED_AGGREGATES_VERSION) {\n      throw new Error(\n        `Aggregates version ${manifest.aggregates_schema_version} not supported. ` +\n        `Please update the extension.`,\n      );\n    }\n  }\n\n  /**\n   * Load dimensions (filter values).\n   */\n  async loadDimensions(): Promise<any> {\n    if (this.dimensions) return this.dimensions;\n\n    const url = this.resolvePath(\"aggregates/dimensions.json\");\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new Error(`Failed to load dimensions: ${response.status}`);\n    }\n\n    this.dimensions = await response.json();\n    return this.dimensions;\n  }\n\n  /**\n   * Get weekly rollups for a date range.\n   * Implements lazy loading with caching.\n   */\n  async getWeeklyRollups(startDate: Date, endDate: Date): Promise<Rollup[]> {\n    if (!this.manifest) {\n      throw new Error(\"Manifest not loaded. Call loadManifest() first.\");\n    }\n\n    const neededWeeks = this.getWeeksInRange(startDate, endDate);\n    const results: Rollup[] = [];\n\n    for (const weekStr of neededWeeks) {\n      // Check cache first\n      const cached = this.rollupCache.get(weekStr);\n      if (cached) {\n        results.push(cached);\n        continue;\n      }\n\n      // Find in index\n      const indexEntry = this.manifest.aggregate_index.weekly_rollups.find(\n        (r: any) => r.week === weekStr,\n      );\n\n      if (!indexEntry) {\n        // No data for this week, skip\n        continue;\n      }\n\n      // Fetch and cache\n      const url = this.resolvePath(indexEntry.path);\n      const response = await fetch(url);\n\n      if (response.ok) {\n        const rawData = await response.json();\n        // Apply version adapter to normalize rollup data\n        const data = normalizeRollup(rawData);\n        this.rollupCache.set(weekStr, data);\n        results.push(data);\n      }\n    }\n\n    return results.sort((a, b) => a.week.localeCompare(b.week));\n  }\n\n  /**\n   * Get weekly rollups with concurrent fetching, progress reporting, and caching (Phase 4).\n   */\n  async getWeeklyRollupsWithProgress(\n    startDate: Date,\n    endDate: Date,\n    context: {\n      org: string;\n      project: string;\n      repo: string;\n      branch?: string;\n      apiVersion?: string;\n    },\n    onProgress: (event: ProgressEvent) => void = () => { },\n    cache: RollupCache | null = null,\n  ): Promise<RollupResult> {\n    if (!this.manifest) {\n      throw new Error(\"Manifest not loaded. Call loadManifest() first.\");\n    }\n\n    const allWeeks = this.getWeeksInRange(startDate, endDate);\n    const data: Rollup[] = [];\n    const missingWeeks: string[] = [];\n    const failedWeeks: string[] = [];\n    let authError = false;\n\n    // Use provided cache or default simple cache\n    const useCache: RollupCache =\n      cache ||\n      ({\n        makeKey: (params: any) => params.week,\n        get: (key: string) => this.rollupCache.get(key),\n        set: (key: string, value: Rollup) => this.rollupCache.set(key, value),\n        has: (key: string) => this.rollupCache.has(key),\n        maxSize: Infinity,\n        ttlMs: Infinity,\n        clock: Date.now,\n        clear: () => this.rollupCache.clear(),\n        size: () => this.rollupCache.size,\n      } as any);\n\n    // Separate cache hits from fetch needed\n    const cachedResults: Rollup[] = [];\n    const weeksToFetch: string[] = [];\n\n    for (const weekStr of allWeeks) {\n      try {\n        const cacheKey = useCache.makeKey({ week: weekStr, ...context });\n        const cached = useCache.get(cacheKey);\n        if (cached !== undefined) {\n          cachedResults.push(cached);\n        } else {\n          weeksToFetch.push(weekStr);\n        }\n      } catch {\n        // Cache key failed, need to fetch\n        weeksToFetch.push(weekStr);\n      }\n    }\n\n    // Batch concurrent fetches with semaphore\n    const batches: string[][] = [];\n    for (\n      let i = 0;\n      i < weeksToFetch.length;\n      i += fetchSemaphore.maxConcurrent\n    ) {\n      batches.push(weeksToFetch.slice(i, i + fetchSemaphore.maxConcurrent));\n    }\n\n    let loaded = 0;\n    const total = weeksToFetch.length;\n\n    for (const batch of batches) {\n      const batchPromises = batch.map(async (weekStr) => {\n        // Progress: report week being requested\n        onProgress({ loaded, total, currentWeek: weekStr });\n\n        // Find in index\n        const indexEntry = this.manifest.aggregate_index.weekly_rollups.find(\n          (r: any) => r.week === weekStr,\n        );\n\n        if (!indexEntry) {\n          return { week: weekStr, status: \"missing\" as const };\n        }\n\n        // Fetch with semaphore and retry\n        return await this._fetchWeekWithRetry(\n          weekStr,\n          indexEntry,\n          context,\n          useCache,\n        );\n      });\n\n      const results = await Promise.allSettled(batchPromises);\n\n      for (const result of results) {\n        loaded++;\n        if (result.status === \"fulfilled\") {\n          const outcome = result.value;\n          if (outcome.status === \"ok\") {\n            data.push(outcome.data);\n          } else if (outcome.status === \"missing\") {\n            missingWeeks.push(outcome.week);\n          } else if (outcome.status === \"auth\") {\n            authError = true;\n          } else if (outcome.status === \"failed\") {\n            failedWeeks.push(outcome.week);\n          }\n        } else {\n          // Promise rejected - shouldn't happen with our error handling\n          failedWeeks.push(\"unknown\");\n        }\n      }\n    }\n\n    // Combine cached and fetched\n    const allData = [...cachedResults, ...data];\n    const partial = missingWeeks.length > 0 || failedWeeks.length > 0;\n    const degraded = partial || authError;\n\n    // INVARIANT: auth error with no data = hard fail\n    if (authError && allData.length === 0) {\n      const error = new Error(\"Authentication required\") as any;\n      error.code = \"AUTH_REQUIRED\";\n      throw error;\n    }\n\n    // Final progress\n    onProgress({ loaded: total, total, currentWeek: null });\n\n    return {\n      data: allData.sort((a, b) => a.week.localeCompare(b.week)),\n      missingWeeks,\n      failedWeeks,\n      partial,\n      authError,\n      degraded,\n    };\n  }\n\n  /**\n   * Fetch a single week with semaphore control and bounded retry.\n   */\n  protected async _fetchWeekWithRetry(\n    weekStr: string,\n    indexEntry: any,\n    context: any,\n    cache: RollupCache,\n  ): Promise<\n    | { week: string; status: \"ok\"; data: Rollup }\n    | { week: string; status: \"auth\" | \"missing\" | \"failed\"; error?: any }\n  > {\n    let retries = 0;\n\n    while (retries <= fetchSemaphore.maxRetries) {\n      await fetchSemaphore.acquire();\n      try {\n        const url = this.resolvePath(indexEntry.path);\n        const response = await fetch(url);\n\n        if (response.ok) {\n          const rawData = await response.json();\n          // Apply version adapter to normalize rollup data\n          const data = normalizeRollup(rawData);\n          try {\n            const cacheKey = cache.makeKey({ week: weekStr, ...context });\n            cache.set(cacheKey, data);\n          } catch {\n            // Cache key error, still return data\n          }\n          return { week: weekStr, status: \"ok\", data };\n        }\n\n        if (response.status === 401 || response.status === 403) {\n          return { week: weekStr, status: \"auth\" };\n        }\n\n        if (response.status === 404) {\n          return { week: weekStr, status: \"missing\" };\n        }\n\n        // 5xx - retry once\n        if (response.status >= 500 && retries < fetchSemaphore.maxRetries) {\n          retries++;\n          await this._delay(fetchSemaphore.retryDelayMs);\n          continue;\n        }\n\n        return { week: weekStr, status: \"failed\", error: response.status };\n      } catch (err: unknown) {\n        // Network error - retry once\n        if (retries < fetchSemaphore.maxRetries) {\n          retries++;\n          await this._delay(fetchSemaphore.retryDelayMs);\n          continue;\n        }\n        return { week: weekStr, status: \"failed\", error: getErrorMessage(err) };\n      } finally {\n        fetchSemaphore.release();\n      }\n    }\n\n    return { week: weekStr, status: \"failed\", error: \"max retries exceeded\" };\n  }\n\n  /**\n   * Delay helper for retry backoff.\n   */\n  protected _delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Get yearly distributions for a date range.\n   */\n  async getDistributions(startDate: Date, endDate: Date): Promise<any[]> {\n    if (!this.manifest) {\n      throw new Error(\"Manifest not loaded. Call loadManifest() first.\");\n    }\n\n    const startYear = startDate.getFullYear();\n    const endYear = endDate.getFullYear();\n    const results: any[] = [];\n\n    for (let year = startYear; year <= endYear; year++) {\n      const yearStr = year.toString();\n\n      // Check cache\n      const cached = this.distributionCache.get(yearStr);\n      if (cached) {\n        results.push(cached);\n        continue;\n      }\n\n      // Find in index\n      const indexEntry = this.manifest.aggregate_index.distributions.find(\n        (d: any) => d.year === yearStr,\n      );\n\n      if (!indexEntry) continue;\n\n      // Fetch and cache\n      const url = this.resolvePath(indexEntry.path);\n      const response = await fetch(url);\n\n      if (response.ok) {\n        const data = await response.json();\n        this.distributionCache.set(yearStr, data);\n        results.push(data);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Check if a feature is enabled in the dataset.\n   */\n  isFeatureEnabled(feature: string): boolean {\n    if (!this.manifest) return false;\n    return this.manifest.features?.[feature] === true;\n  }\n\n  /**\n   * Get dataset coverage info.\n   */\n  getCoverage(): any {\n    if (!this.manifest) return null;\n    return this.manifest.coverage;\n  }\n\n  /**\n   * Get default date range days.\n   */\n  getDefaultRangeDays(): number {\n    return this.manifest?.defaults?.default_date_range_days || 90;\n  }\n\n  /**\n   * Load predictions data (Phase 3.5).\n   */\n  async loadPredictions(): Promise<any> {\n    if (!this.isFeatureEnabled(\"predictions\")) {\n      return { state: \"disabled\" };\n    }\n\n    try {\n      const url = this.resolvePath(\"predictions/trends.json\");\n      const response = await fetch(url);\n\n      if (!response.ok) {\n        if (response.status === 404) {\n          return { state: \"missing\" };\n        }\n        if (response.status === 401 || response.status === 403) {\n          return { state: \"auth\" };\n        }\n        return {\n          state: \"error\",\n          error: \"PRED_003\",\n          message: `HTTP ${response.status}`,\n        };\n      }\n\n      const predictions = await response.json();\n\n      // Validate schema version\n      const validationResult = this.validatePredictionsSchema(predictions);\n      if (!validationResult.valid) {\n        console.error(\n          \"[DatasetLoader] Invalid predictions schema:\",\n          validationResult.error,\n        );\n        return {\n          state: \"invalid\",\n          error: \"PRED_001\",\n          message: validationResult.error,\n        };\n      }\n\n      return { state: \"ok\", data: predictions };\n    } catch (err: unknown) {\n      console.error(\"[DatasetLoader] Error loading predictions:\", err);\n      return { state: \"error\", error: \"PRED_002\", message: getErrorMessage(err) };\n    }\n  }\n\n  /**\n   * Load AI insights data (Phase 3.5).\n   */\n  async loadInsights(): Promise<any> {\n    if (!this.isFeatureEnabled(\"ai_insights\")) {\n      return { state: \"disabled\" };\n    }\n\n    try {\n      const url = this.resolvePath(\"insights/summary.json\");\n      const response = await fetch(url);\n\n      if (!response.ok) {\n        if (response.status === 404) {\n          return { state: \"missing\" };\n        }\n        if (response.status === 401 || response.status === 403) {\n          return { state: \"auth\" };\n        }\n        return {\n          state: \"error\",\n          error: \"AI_003\",\n          message: `HTTP ${response.status}`,\n        };\n      }\n\n      const insights = await response.json();\n\n      // Validate schema version\n      const validationResult = this.validateInsightsSchema(insights);\n      if (!validationResult.valid) {\n        console.error(\n          \"[DatasetLoader] Invalid insights schema:\",\n          validationResult.error,\n        );\n        return {\n          state: \"invalid\",\n          error: \"AI_001\",\n          message: validationResult.error,\n        };\n      }\n\n      return { state: \"ok\", data: insights };\n    } catch (err: unknown) {\n      console.error(\"[DatasetLoader] Error loading insights:\", err);\n      return { state: \"error\", error: \"AI_002\", message: getErrorMessage(err) };\n    }\n  }\n\n  /**\n   * Validate predictions schema.\n   */\n  protected validatePredictionsSchema(predictions: any): {\n    valid: boolean;\n    error?: string;\n  } {\n    if (!predictions)\n      return { valid: false, error: \"Missing predictions data\" };\n    if (typeof predictions.schema_version !== \"number\") {\n      return { valid: false, error: \"Missing schema_version\" };\n    }\n    if (predictions.schema_version > 1) {\n      return {\n        valid: false,\n        error: `Unsupported schema version: ${predictions.schema_version}`,\n      };\n    }\n    if (!Array.isArray(predictions.forecasts)) {\n      return { valid: false, error: \"Missing forecasts array\" };\n    }\n    // Validate each forecast has required fields\n    for (const forecast of predictions.forecasts) {\n      if (\n        !forecast.metric ||\n        !forecast.unit ||\n        !Array.isArray(forecast.values)\n      ) {\n        return { valid: false, error: \"Invalid forecast structure\" };\n      }\n    }\n    return { valid: true };\n  }\n\n  /**\n   * Validate insights schema.\n   */\n  protected validateInsightsSchema(insights: any): {\n    valid: boolean;\n    error?: string;\n  } {\n    if (!insights) return { valid: false, error: \"Missing insights data\" };\n    if (typeof insights.schema_version !== \"number\") {\n      return { valid: false, error: \"Missing schema_version\" };\n    }\n    if (insights.schema_version > 1) {\n      return {\n        valid: false,\n        error: `Unsupported schema version: ${insights.schema_version}`,\n      };\n    }\n    if (!Array.isArray(insights.insights)) {\n      return { valid: false, error: \"Missing insights array\" };\n    }\n    // Validate each insight has required fields\n    for (const insight of insights.insights) {\n      if (\n        !insight.id ||\n        !insight.category ||\n        !insight.severity ||\n        !insight.title\n      ) {\n        return { valid: false, error: \"Invalid insight structure\" };\n      }\n    }\n    return { valid: true };\n  }\n\n  /**\n   * Resolve a relative path to full URL.\n   * Uses effectiveBaseUrl if resolved, otherwise falls back to baseUrl.\n   */\n  protected resolvePath(relativePath: string): string {\n    // Use effective base URL if resolved (supports nested layouts)\n    const base =\n      this.effectiveBaseUrl !== null ? this.effectiveBaseUrl : this.baseUrl;\n    if (base) {\n      return `${base}/${relativePath}`;\n    }\n    return relativePath;\n  }\n\n  /**\n   * Get ISO week strings for a date range.\n   */\n  getWeeksInRange(start: Date, end: Date): string[] {\n    const weeks: string[] = [];\n    const current = new Date(start);\n\n    while (current <= end) {\n      const weekStr = this.getISOWeek(current);\n      if (!weeks.includes(weekStr)) {\n        weeks.push(weekStr);\n      }\n      current.setDate(current.getDate() + 7);\n    }\n\n    // Ensure we include the end date's week\n    const endWeek = this.getISOWeek(end);\n    if (!weeks.includes(endWeek)) {\n      weeks.push(endWeek);\n    }\n\n    return weeks;\n  }\n\n  /**\n   * Get ISO week string for a date.\n   */\n  getISOWeek(date: Date): string {\n    const d = new Date(\n      Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()),\n    );\n    const dayNum = d.getUTCDay() || 7;\n    d.setUTCDate(d.getUTCDate() + 4 - dayNum);\n    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));\n    const weekNo = Math.ceil(\n      ((d.getTime() - yearStart.getTime()) / 86400000 + 1) / 7,\n    );\n    return `${d.getUTCFullYear()}-W${weekNo.toString().padStart(2, \"0\")}`;\n  }\n}\n\n// Browser global exports for runtime compatibility\nif (typeof window !== \"undefined\") {\n  window.DatasetLoader = DatasetLoader;\n  window.fetchSemaphore = fetchSemaphore;\n  window.createRollupCache = createRollupCache;\n  window.normalizeRollup = normalizeRollup;\n  window.normalizeRollups = normalizeRollups;\n  window.ROLLUP_FIELD_DEFAULTS = ROLLUP_FIELD_DEFAULTS;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "E:\\projects\\ado-git-repo-insights\\extension\\ui\\error-codes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "E:\\projects\\ado-git-repo-insights\\extension\\ui\\error-types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "E:\\projects\\ado-git-repo-insights\\extension\\ui\\settings.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 104,
        "column": 47,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 104,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2900, 2903], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2900, 2903], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 104,
        "column": 55,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 104,
        "endColumn": 58,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2908, 2911], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2908, 2911], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 138,
        "column": 51,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 138,
        "endColumn": 54,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3878, 3881], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3878, 3881], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 140,
        "column": 59,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 140,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3989, 3992], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3989, 3992], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 145,
        "column": 28,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 145,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4129, 4132], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4129, 4132], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 148,
        "column": 26,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 148,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4216, 4219], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4216, 4219], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 400,
        "column": 61,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 400,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11842, 11845], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11842, 11845], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 417,
        "column": 31,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 417,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12259, 12262], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12259, 12262], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 446,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 446,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [13088, 13091], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [13088, 13091], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 489,
        "column": 61,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 489,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [14375, 14378], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [14375, 14378], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 498,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 498,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [14647, 14650], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [14647, 14650], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 503,
        "column": 37,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 503,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [14833, 14836], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [14833, 14836], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 532,
        "column": 41,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 532,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [15705, 15708], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [15705, 15708], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-floating-promises",
        "severity": 1,
        "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
        "line": 661,
        "column": 9,
        "nodeType": "ExpressionStatement",
        "messageId": "floatingVoid",
        "endLine": 661,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "floatingFixVoid",
            "fix": { "range": [19593, 19593], "text": "void " },
            "desc": "Add void operator to ignore."
          },
          {
            "messageId": "floatingFixAwait",
            "fix": { "range": [19593, 19593], "text": "await " },
            "desc": "Add await operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-floating-promises",
        "severity": 1,
        "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
        "line": 668,
        "column": 9,
        "nodeType": "ExpressionStatement",
        "messageId": "floatingVoid",
        "endLine": 668,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "floatingFixVoid",
            "fix": { "range": [19768, 19768], "text": "void " },
            "desc": "Add void operator to ignore."
          },
          {
            "messageId": "floatingFixAwait",
            "fix": { "range": [19768, 19768], "text": "await " },
            "desc": "Add await operator."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-floating-promises",
        "severity": 1,
        "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
        "line": 677,
        "column": 3,
        "nodeType": "ExpressionStatement",
        "messageId": "floatingVoid",
        "endLine": 677,
        "endColumn": 10,
        "suggestions": [
          {
            "messageId": "floatingFixVoid",
            "fix": { "range": [19932, 19932], "text": "void " },
            "desc": "Add void operator to ignore."
          },
          {
            "messageId": "floatingFixAwait",
            "fix": { "range": [19932, 19932], "text": "await " },
            "desc": "Add await operator."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 16,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * PR Insights Settings Page\n *\n * Allows users to configure:\n * - Source project (for cross-project access)\n * - Pipeline definition ID\n *\n * Settings are user-scoped (not project-scoped) for privacy.\n *\n * Project selection uses graceful degradation:\n * - Shows dropdown when vso.project scope allows listing projects\n * - Falls back to text input when listing isn't available\n */\n\nimport { getErrorMessage, type VSSProject } from \"./types\";\n\n// Settings keys (must match dashboard.js)\nconst SETTINGS_KEY_PROJECT = \"pr-insights-source-project\";\nconst SETTINGS_KEY_PIPELINE = \"pr-insights-pipeline-id\";\n\n// State\nlet dataService: IExtensionDataService | null = null;\nlet projectDropdownAvailable = false;\nlet projectList: VSSProject[] = [];\n\n/**\n * Initialize Azure DevOps Extension SDK.\n */\nasync function initializeAdoSdk(): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const timeout = setTimeout(() => {\n      reject(new Error(\"Azure DevOps SDK initialization timed out\"));\n    }, 10000);\n\n    VSS.init({\n      explicitNotifyLoaded: true,\n      usePlatformScripts: true,\n      usePlatformStyles: true,\n    });\n\n    VSS.ready(() => {\n      clearTimeout(timeout);\n      VSS.notifyLoadSucceeded();\n      resolve();\n    });\n  });\n}\n\n/**\n * Initialize the settings page.\n */\nasync function init(): Promise<void> {\n  try {\n    await initializeAdoSdk();\n\n    // Get extension data service\n    dataService = await VSS.getService(VSS.ServiceIds.ExtensionData);\n\n    // Set current project as placeholder\n    const webContext = VSS.getWebContext();\n    const projectInput = document.getElementById(\n      \"project-id\",\n    ) as HTMLInputElement | null;\n    if (projectInput && webContext?.project?.name) {\n      projectInput.placeholder = `Current: ${webContext.project.name}`;\n    }\n\n    // Try to load project dropdown\n    await tryLoadProjectDropdown();\n\n    // Load saved settings\n    await loadSettings();\n\n    // Update status display\n    await updateStatus();\n\n    // Set up event listeners\n    setupEventListeners();\n  } catch (error: unknown) {\n    console.error(\"Settings initialization failed:\", error);\n    showStatus(\"Failed to initialize settings: \" + getErrorMessage(error), \"error\");\n  }\n}\n\n/**\n * Try to load project dropdown. Degrades gracefully to text input.\n */\nasync function tryLoadProjectDropdown(): Promise<void> {\n  const dropdown = document.getElementById(\n    \"project-select\",\n  ) as HTMLSelectElement;\n  const textInput = document.getElementById(\"project-id\") as HTMLInputElement;\n\n  try {\n    // Get projects using Core REST client\n    const projects = await getOrganizationProjects();\n\n    if (projects && projects.length > 0) {\n      projectList = projects;\n      projectDropdownAvailable = true;\n\n      // Populate dropdown\n      dropdown.innerHTML = '<option value=\"\">Current project (auto)</option>';\n      for (const project of projects.sort((a: any, b: any) =>\n        a.name.localeCompare(b.name),\n      )) {\n        const option = document.createElement(\"option\");\n        option.value = project.id;\n        option.textContent = `${project.name} (${project.id.substring(0, 8)}...)`;\n        dropdown.appendChild(option);\n      }\n\n      // Show dropdown, hide text input\n      dropdown.style.display = \"block\";\n      textInput.style.display = \"none\";\n\n      console.log(`Loaded ${projects.length} projects for dropdown`);\n    } else {\n      throw new Error(\"No projects returned\");\n    }\n  } catch (error: unknown) {\n    console.log(\n      \"Project dropdown unavailable, using text input:\",\n      getErrorMessage(error),\n    );\n    projectDropdownAvailable = false;\n\n    // Show text input, hide dropdown\n    dropdown.style.display = \"none\";\n    textInput.style.display = \"block\";\n  }\n}\n\n/**\n * Get list of projects in the organization.\n * Requires vso.project scope.\n */\nasync function getOrganizationProjects(): Promise<any[]> {\n  return new Promise((resolve, reject) => {\n    VSS.require([\"TFS/Core/RestClient\"], (CoreRestClient: any) => {\n      try {\n        const client = CoreRestClient.getClient();\n        client\n          .getProjects()\n          .then((projects: any[]) => {\n            resolve(projects || []);\n          })\n          .catch((error: any) => {\n            reject(error);\n          });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  });\n}\n\n/**\n * Load saved settings into form.\n */\nasync function loadSettings(): Promise<void> {\n  if (!dataService) return;\n\n  try {\n    const savedProjectId = await dataService.getValue<string>(\n      SETTINGS_KEY_PROJECT,\n      { scopeType: \"User\" },\n    );\n    const savedPipelineId = await dataService.getValue<number>(\n      SETTINGS_KEY_PIPELINE,\n      { scopeType: \"User\" },\n    );\n\n    // Set project\n    if (savedProjectId) {\n      if (projectDropdownAvailable) {\n        const dropdown = document.getElementById(\n          \"project-select\",\n        ) as HTMLSelectElement;\n        if (dropdown) dropdown.value = savedProjectId;\n      } else {\n        const textInput = document.getElementById(\n          \"project-id\",\n        ) as HTMLInputElement;\n        if (textInput) textInput.value = savedProjectId;\n      }\n    }\n\n    // Set pipeline ID\n    const pipelineInput = document.getElementById(\n      \"pipeline-id\",\n    ) as HTMLInputElement;\n    if (pipelineInput && savedPipelineId) {\n      pipelineInput.value = savedPipelineId.toString();\n    }\n  } catch (error) {\n    console.log(\"No saved settings found:\", error);\n  }\n}\n\n/**\n * Get the selected project ID from either dropdown or text input.\n */\nfunction getSelectedProjectId(): string | null {\n  if (projectDropdownAvailable) {\n    const dropdown = document.getElementById(\n      \"project-select\",\n    ) as HTMLSelectElement;\n    return dropdown.value || null;\n  } else {\n    const textInput = document.getElementById(\"project-id\") as HTMLInputElement;\n    const value = textInput.value.trim();\n    return value || null;\n  }\n}\n\n/**\n * Save settings from form.\n */\nasync function saveSettings(): Promise<void> {\n  if (!dataService) return;\n\n  const projectId = getSelectedProjectId();\n  const pipelineInput = document.getElementById(\n    \"pipeline-id\",\n  ) as HTMLInputElement | null;\n  const pipelineValue = pipelineInput?.value?.trim();\n\n  try {\n    // Save project ID\n    await dataService.setValue(SETTINGS_KEY_PROJECT, projectId, {\n      scopeType: \"User\",\n    });\n\n    // Save pipeline ID\n    if (pipelineValue) {\n      const pipelineId = parseInt(pipelineValue, 10);\n      if (isNaN(pipelineId) || pipelineId <= 0) {\n        showStatus(\"Pipeline ID must be a positive integer\", \"error\");\n        return;\n      }\n      await dataService.setValue(SETTINGS_KEY_PIPELINE, pipelineId, {\n        scopeType: \"User\",\n      });\n    } else {\n      await dataService.setValue(SETTINGS_KEY_PIPELINE, null, {\n        scopeType: \"User\",\n      });\n    }\n\n    showStatus(\"Settings saved successfully\", \"success\");\n\n    // Update status display\n    await updateStatus();\n  } catch (error: unknown) {\n    console.error(\"Failed to save settings:\", error);\n    showStatus(\"Failed to save settings: \" + getErrorMessage(error), \"error\");\n  }\n}\n\n/**\n * Clear settings.\n */\nasync function clearSettings(): Promise<void> {\n  if (!dataService) return;\n\n  // Clear form\n  if (projectDropdownAvailable) {\n    const dropdown = document.getElementById(\n      \"project-select\",\n    ) as HTMLSelectElement;\n    if (dropdown) dropdown.value = \"\";\n  } else {\n    const textInput = document.getElementById(\"project-id\") as HTMLInputElement;\n    if (textInput) textInput.value = \"\";\n  }\n  const pipelineInput = document.getElementById(\n    \"pipeline-id\",\n  ) as HTMLInputElement;\n  if (pipelineInput) pipelineInput.value = \"\";\n\n  try {\n    await dataService.setValue(SETTINGS_KEY_PROJECT, null, {\n      scopeType: \"User\",\n    });\n    await dataService.setValue(SETTINGS_KEY_PIPELINE, null, {\n      scopeType: \"User\",\n    });\n    showStatus(\n      \"Settings cleared - using current project with auto-discovery\",\n      \"success\",\n    );\n    await updateStatus();\n  } catch (error: unknown) {\n    console.error(\"Failed to clear settings:\", error);\n    showStatus(\"Failed to clear settings: \" + getErrorMessage(error), \"error\");\n  }\n}\n\n/**\n * Update the status display with current configuration.\n */\nasync function updateStatus(): Promise<void> {\n  if (!dataService) return;\n\n  const statusDisplay = document.getElementById(\"status-display\");\n  if (!statusDisplay) return;\n\n  try {\n    const savedProjectId = await dataService.getValue<string>(\n      SETTINGS_KEY_PROJECT,\n      { scopeType: \"User\" },\n    );\n    const savedPipelineId = await dataService.getValue<number>(\n      SETTINGS_KEY_PIPELINE,\n      { scopeType: \"User\" },\n    );\n    const webContext = VSS.getWebContext();\n    const currentProjectName = webContext?.project?.name || \"Unknown\";\n    const currentProjectId = webContext?.project?.id;\n\n    let html = \"\";\n\n    // Current context\n    html += `<p><strong>Current Project:</strong> ${escapeHtml(currentProjectName)}</p>`;\n\n    // Source project configuration\n    if (savedProjectId) {\n      const projectName = getProjectNameById(savedProjectId);\n      html += `<p><strong>Source Project:</strong> ${escapeHtml(projectName)} <code>${savedProjectId.substring(0, 8)}...</code></p>`;\n    } else {\n      html += `<p><strong>Source Project:</strong> <em>Same as current</em></p>`;\n    }\n\n    // Pipeline configuration with validation\n    if (savedPipelineId) {\n      html += `<p><strong>Pipeline Definition ID:</strong> ${savedPipelineId}`;\n\n      // Validate the saved pipeline\n      const targetProjectId = savedProjectId || currentProjectId;\n      if (targetProjectId) {\n        const validation = await validatePipeline(\n          savedPipelineId,\n          targetProjectId,\n        );\n\n        if (validation.valid) {\n          html += ` <span class=\"status-valid\"> Valid</span>`;\n          html += `</p>`;\n          html += `<p class=\"status-hint\">Pipeline: \"${escapeHtml(validation.name || \"\")}\" (Build #${validation.buildId})</p>`;\n        } else {\n          html += ` <span class=\"status-invalid\"> Invalid</span>`;\n          html += `</p>`;\n          html += `<p class=\"status-warning\"> ${escapeHtml(validation.error || \"\")}</p>`;\n          html += `<p class=\"status-hint\">The dashboard will automatically clear this setting and re-discover pipelines. Consider clearing manually to configure a different pipeline.</p>`;\n        }\n      } else {\n        html += `</p><p class=\"status-warning\"> No project ID available for validation</p>`;\n      }\n    } else {\n      html += `<p><strong>Mode:</strong> Auto-discovery</p>`;\n      html += `<p class=\"status-hint\">The dashboard will automatically find pipelines with an \"aggregates\" artifact.</p>`;\n    }\n\n    // Dropdown availability\n    if (projectDropdownAvailable) {\n      html += `<p class=\"status-hint\"> Project dropdown available (${projectList.length} projects)</p>`;\n    } else {\n      html += `<p class=\"status-hint\">Project dropdown not available - using text input</p>`;\n    }\n\n    statusDisplay.innerHTML = html;\n  } catch (error: unknown) {\n    statusDisplay.innerHTML = `<p class=\"status-error\">Failed to load status: ${escapeHtml(getErrorMessage(error))}</p>`;\n  }\n}\n\n/**\n * Get project name by ID from the cached list.\n */\nfunction getProjectNameById(projectId: string): string {\n  const project = projectList.find((p) => p.id === projectId);\n  return project?.name || projectId;\n}\n\n/**\n * Validate if a pipeline exists and has successful builds with aggregates artifact.\n * Returns validation result with details.\n */\nasync function validatePipeline(\n  pipelineId: number,\n  projectId: string,\n): Promise<{\n  valid: boolean;\n  name?: string;\n  buildId?: number;\n  error?: string;\n}> {\n  return new Promise((resolve) => {\n    VSS.require([\"TFS/Build/RestClient\"], (BuildRestClient: any) => {\n      try {\n        const client = BuildRestClient.getClient();\n\n        // Check if pipeline definition exists\n        client\n          .getDefinitions(\n            projectId,\n            null,\n            null,\n            null,\n            2, // queryOrder: definitionNameAscending\n            null,\n            null,\n            null,\n            [pipelineId],\n          )\n          .then((definitions: any[]) => {\n            if (!definitions || definitions.length === 0) {\n              resolve({\n                valid: false,\n                error: \"Pipeline definition not found (may have been deleted)\",\n              });\n              return;\n            }\n\n            const pipelineName = definitions[0].name;\n\n            // Check for successful/partially-succeeded builds\n            // resultFilter: 6 = Succeeded(2) | PartiallySucceeded(4)\n            client\n              .getBuilds(\n                projectId,\n                [pipelineId],\n                null,\n                null,\n                null,\n                null,\n                null,\n                null,\n                2,\n                6,\n                null,\n                null,\n                1,\n              )\n              .then((builds: any[]) => {\n                if (!builds || builds.length === 0) {\n                  resolve({\n                    valid: false,\n                    name: pipelineName,\n                    error: \"No successful builds found\",\n                  });\n                  return;\n                }\n\n                resolve({\n                  valid: true,\n                  name: pipelineName,\n                  buildId: builds[0].id,\n                });\n              })\n              .catch((e: unknown) => {\n                resolve({\n                  valid: false,\n                  error: `Build check failed: ${getErrorMessage(e)}`,\n                });\n              });\n          })\n          .catch((e: unknown) => {\n            resolve({\n              valid: false,\n              error: `Definition fetch failed: ${getErrorMessage(e)}`,\n            });\n          });\n      } catch (e: unknown) {\n        resolve({ valid: false, error: `Validation error: ${getErrorMessage(e)}` });\n      }\n    });\n  });\n}\n\n/**\n * Discover pipelines with aggregates artifact in the current project.\n */\nasync function discoverPipelines(): Promise<\n  Array<{ id: number; name: string; buildId: number }>\n> {\n  return new Promise((resolve) => {\n    VSS.require([\"TFS/Build/RestClient\"], (BuildRestClient: any) => {\n      try {\n        const client = BuildRestClient.getClient();\n        const webContext = VSS.getWebContext();\n        const projectId = webContext.project?.id;\n        if (!projectId) {\n          resolve([]);\n          return;\n        }\n        const matches: any[] = [];\n\n        // Get pipeline definitions (limit for performance)\n        client\n          .getDefinitions(projectId, null, null, null, 2, 50)\n          .then(async (definitions: any[]) => {\n            for (const def of definitions) {\n              // Get latest successful/partially-succeeded build\n              try {\n                const builds = await client.getBuilds(\n                  projectId,\n                  [def.id],\n                  null,\n                  null,\n                  null,\n                  null,\n                  null,\n                  null,\n                  2,\n                  6,\n                  null,\n                  null,\n                  1,\n                );\n\n                if (!builds || builds.length === 0) continue;\n\n                const latestBuild = builds[0];\n\n                // Check for aggregates artifact\n                const artifacts = await client.getArtifacts(\n                  projectId,\n                  latestBuild.id,\n                );\n                if (!artifacts.some((a: any) => a.name === \"aggregates\"))\n                  continue;\n\n                matches.push({\n                  id: def.id,\n                  name: def.name,\n                  buildId: latestBuild.id,\n                });\n              } catch (e) {\n                // Skip pipelines we can't access\n                console.debug(`Skipping pipeline ${def.name}:`, e);\n              }\n            }\n            resolve(matches);\n          })\n          .catch((e: unknown) => {\n            console.error(\"Discovery: definitions fetch failed:\", e);\n            resolve([]);\n          });\n      } catch (e) {\n        console.error(\"Discovery error:\", e);\n        resolve([]);\n      }\n    });\n  });\n}\n\n/**\n * Run auto-discovery and show results to user.\n */\nasync function runDiscovery(): Promise<void> {\n  const statusDisplay = document.getElementById(\"status-display\");\n  if (!statusDisplay) return;\n\n  const originalContent = statusDisplay.innerHTML;\n  statusDisplay.innerHTML =\n    \"<p> Discovering pipelines with aggregates artifact...</p>\";\n\n  try {\n    const matches = await discoverPipelines();\n\n    if (matches.length === 0) {\n      statusDisplay.innerHTML = `\n                <p class=\"status-warning\"> No PR Insights pipelines found in the current project.</p>\n                <p class=\"status-hint\">Create a pipeline using pr-insights-pipeline.yml and run it at least once.</p>\n            `;\n      showStatus(\"No pipelines found with aggregates artifact\", \"warning\");\n      return;\n    }\n\n    let html = `<p><strong>Found ${matches.length} pipeline(s):</strong></p><ul class=\"discovered-pipelines\">`;\n    for (const match of matches) {\n      html += `<li>\n                <strong>${escapeHtml(match.name)}</strong> (ID: ${match.id})\n                <button class=\"btn btn-small\" id=\"select-pipeline-${match.id}\">Use This</button>\n            </li>`;\n    }\n    html += \"</ul>\";\n    html +=\n      '<p class=\"status-hint\">Click \"Use This\" to configure, or clear settings for auto-discovery.</p>';\n\n    statusDisplay.innerHTML = html;\n\n    // Add event listeners for discovered pipelines\n    for (const match of matches) {\n      document\n        .getElementById(`select-pipeline-${match.id}`)\n        ?.addEventListener(\"click\", () => {\n          const pipelineInput = document.getElementById(\n            \"pipeline-id\",\n          ) as HTMLInputElement;\n          if (pipelineInput) pipelineInput.value = match.id.toString();\n          showStatus(\n            `Pipeline ${match.id} selected - click Save to confirm`,\n            \"info\",\n          );\n        });\n    }\n\n    showStatus(`Found ${matches.length} pipeline(s)`, \"success\");\n  } catch (error: unknown) {\n    statusDisplay.innerHTML = originalContent;\n    showStatus(\"Discovery failed: \" + getErrorMessage(error), \"error\");\n  }\n}\n\n/**\n * Show status message.\n */\nfunction showStatus(message: string, type = \"info\"): void {\n  const statusEl = document.getElementById(\"status-message\");\n  if (!statusEl) return;\n\n  statusEl.textContent = message;\n  statusEl.className = `status-message status-${type}`;\n\n  // Clear after delay\n  setTimeout(() => {\n    statusEl.textContent = \"\";\n    statusEl.className = \"status-message\";\n  }, 5000);\n}\n\n/**\n * Escape HTML to prevent XSS.\n */\nfunction escapeHtml(text: string): string {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\n\n/**\n * Set up event listeners.\n */\nfunction setupEventListeners(): void {\n  document.getElementById(\"save-btn\")?.addEventListener(\"click\", saveSettings);\n  document\n    .getElementById(\"clear-btn\")\n    ?.addEventListener(\"click\", clearSettings);\n  document\n    .getElementById(\"discover-btn\")\n    ?.addEventListener(\"click\", runDiscovery);\n\n  // Enter key saves\n  document\n    .getElementById(\"pipeline-id\")\n    ?.addEventListener(\"keypress\", (e: KeyboardEvent) => {\n      if (e.key === \"Enter\") {\n        saveSettings();\n      }\n    });\n  document\n    .getElementById(\"project-id\")\n    ?.addEventListener(\"keypress\", (e: KeyboardEvent) => {\n      if (e.key === \"Enter\") {\n        saveSettings();\n      }\n    });\n}\n\n// Initialize on load\nif (document.readyState === \"loading\") {\n  document.addEventListener(\"DOMContentLoaded\", init);\n} else {\n  init();\n}\n\n// Global exposure for potential inline handlers (though we use addEventListener now)\nwindow.selectDiscoveredPipeline = (pipelineId: number) => {\n  const pipelineInput = document.getElementById(\n    \"pipeline-id\",\n  ) as HTMLInputElement;\n  if (pipelineInput) pipelineInput.value = pipelineId.toString();\n  showStatus(`Pipeline ${pipelineId} selected - click Save to confirm`, \"info\");\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "E:\\projects\\ado-git-repo-insights\\extension\\ui\\types.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "`import()` type annotations are forbidden.",
        "line": 185,
        "column": 32,
        "nodeType": "TSImportType",
        "messageId": "noImportTypeAnnotations",
        "endLine": 185,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "`import()` type annotations are forbidden.",
        "line": 186,
        "column": 33,
        "nodeType": "TSImportType",
        "messageId": "noImportTypeAnnotations",
        "endLine": 186,
        "endColumn": 74
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "`import()` type annotations are forbidden.",
        "line": 187,
        "column": 36,
        "nodeType": "TSImportType",
        "messageId": "noImportTypeAnnotations",
        "endLine": 187,
        "endColumn": 80
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "`import()` type annotations are forbidden.",
        "line": 188,
        "column": 34,
        "nodeType": "TSImportType",
        "messageId": "noImportTypeAnnotations",
        "endLine": 188,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "`import()` type annotations are forbidden.",
        "line": 189,
        "column": 35,
        "nodeType": "TSImportType",
        "messageId": "noImportTypeAnnotations",
        "endLine": 189,
        "endColumn": 78
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "`import()` type annotations are forbidden.",
        "line": 190,
        "column": 40,
        "nodeType": "TSImportType",
        "messageId": "noImportTypeAnnotations",
        "endLine": 190,
        "endColumn": 88
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "`import()` type annotations are forbidden.",
        "line": 193,
        "column": 33,
        "nodeType": "TSImportType",
        "messageId": "noImportTypeAnnotations",
        "endLine": 193,
        "endColumn": 75
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "`import()` type annotations are forbidden.",
        "line": 194,
        "column": 45,
        "nodeType": "TSImportType",
        "messageId": "noImportTypeAnnotations",
        "endLine": 194,
        "endColumn": 99
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 1,
        "message": "`import()` type annotations are forbidden.",
        "line": 195,
        "column": 37,
        "nodeType": "TSImportType",
        "messageId": "noImportTypeAnnotations",
        "endLine": 195,
        "endColumn": 83
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\r\n * Shared Type Definitions for PR Insights Hub\r\n *\r\n * This module provides TypeScript type definitions for:\r\n * - VSS SDK types (Azure DevOps SDK lacks full TS definitions)\r\n * - Dataset and rollup types\r\n * - Cache system types\r\n * - Error handling utilities\r\n */\r\n\r\n// =============================================================================\r\n// VSS SDK Type Stubs\r\n// Azure DevOps VSS SDK lacks complete TypeScript definitions.\r\n// These provide type safety for known API shapes.\r\n// =============================================================================\r\n\r\nexport interface VSSProject {\r\n    id: string;\r\n    name: string;\r\n    description?: string;\r\n    state?: string;\r\n    visibility?: number;\r\n}\r\n\r\nexport interface VSSBuildDefinition {\r\n    id: number;\r\n    name: string;\r\n    path?: string;\r\n    revision?: number;\r\n    type?: number;\r\n}\r\n\r\nexport interface VSSBuild {\r\n    id: number;\r\n    buildNumber: string;\r\n    result: number;\r\n    status: number;\r\n    startTime?: string;\r\n    finishTime?: string;\r\n    definition?: VSSBuildDefinition;\r\n}\r\n\r\nexport interface VSSBuildArtifact {\r\n    id?: number;\r\n    name: string;\r\n    resource?: {\r\n        downloadUrl?: string;\r\n        type?: string;\r\n        data?: string;\r\n    };\r\n}\r\n\r\n// =============================================================================\r\n// Dataset Types\r\n// =============================================================================\r\n\r\nexport interface RollupRecord {\r\n    week: string;\r\n    org?: string;\r\n    project?: string;\r\n    repo?: string;\r\n    [key: string]: unknown;\r\n}\r\n\r\nexport interface DimensionRecord {\r\n    year: string;\r\n    [key: string]: unknown;\r\n}\r\n\r\nexport interface ManifestSchema {\r\n    version?: string | number;\r\n    generated_at?: string;\r\n    coverage?: {\r\n        first_week?: string;\r\n        last_week?: string;\r\n        total_weeks?: number;\r\n    };\r\n    aggregate_index?: {\r\n        rollups_by_week?: Record<string, { path: string }>;\r\n        dimensions_by_year?: Record<string, { path: string }>;\r\n        predictions?: { path: string };\r\n        ai_insights?: { path: string };\r\n    };\r\n    ui_defaults?: {\r\n        default_range_days?: number;\r\n    };\r\n}\r\n\r\n// =============================================================================\r\n// Cache Types\r\n// =============================================================================\r\n\r\nexport interface CacheEntry<T = unknown> {\r\n    value: T;\r\n    createdAt: number;\r\n    touchedAt: number;\r\n}\r\n\r\nexport interface RollupCache<T = unknown> {\r\n    get(key: string): T | undefined;\r\n    set(key: string, value: T): void;\r\n    has(key: string): boolean;\r\n    clear(): void;\r\n}\r\n\r\n// =============================================================================\r\n// Error Handling Utilities\r\n// =============================================================================\r\n\r\n/**\r\n * Type guard to check if a value is an object with a message property.\r\n */\r\nexport function isErrorWithMessage(\r\n    error: unknown,\r\n): error is { message: string } {\r\n    return (\r\n        typeof error === \"object\" &&\r\n        error !== null &&\r\n        \"message\" in error &&\r\n        typeof (error as { message: unknown }).message === \"string\"\r\n    );\r\n}\r\n\r\n/**\r\n * Type guard to check if a value is an object with a code property.\r\n */\r\nexport function isErrorWithCode(error: unknown): error is { code: string } {\r\n    return (\r\n        typeof error === \"object\" &&\r\n        error !== null &&\r\n        \"code\" in error &&\r\n        typeof (error as { code: unknown }).code === \"string\"\r\n    );\r\n}\r\n\r\n/**\r\n * Safely extract an error message from an unknown caught value.\r\n */\r\nexport function getErrorMessage(error: unknown): string {\r\n    if (isErrorWithMessage(error)) return error.message;\r\n    if (typeof error === \"string\") return error;\r\n    return \"Unknown error\";\r\n}\r\n\r\n/**\r\n * Safely extract an error code from an unknown caught value.\r\n */\r\nexport function getErrorCode(error: unknown): string | undefined {\r\n    if (isErrorWithCode(error)) return error.code;\r\n    return undefined;\r\n}\r\n\r\n// =============================================================================\r\n// Response Status Types\r\n// =============================================================================\r\n\r\nexport type LoadStatus = \"ok\" | \"auth\" | \"missing\" | \"failed\";\r\n\r\nexport interface LoadResult<T> {\r\n    status: LoadStatus;\r\n    data?: T;\r\n    error?: unknown;\r\n}\r\n\r\nexport interface WeekLoadResult<T> {\r\n    week: string;\r\n    status: LoadStatus;\r\n    data?: T;\r\n    error?: unknown;\r\n}\r\n\r\n// =============================================================================\r\n// Window Interface Augmentation\r\n// Typed global exports for browser compatibility\r\n// =============================================================================\r\n\r\n/**\r\n * Extended Window interface for PR Insights globals.\r\n * This allows typed assignments like `window.DatasetLoader = DatasetLoader`\r\n * instead of `(window as any).DatasetLoader = DatasetLoader`.\r\n */\r\ndeclare global {\r\n    interface Window {\r\n        // Dataset Loader exports\r\n        DatasetLoader?: typeof import(\"./dataset-loader\").DatasetLoader;\r\n        fetchSemaphore?: typeof import(\"./dataset-loader\").fetchSemaphore;\r\n        createRollupCache?: typeof import(\"./dataset-loader\").createRollupCache;\r\n        normalizeRollup?: typeof import(\"./dataset-loader\").normalizeRollup;\r\n        normalizeRollups?: typeof import(\"./dataset-loader\").normalizeRollups;\r\n        ROLLUP_FIELD_DEFAULTS?: typeof import(\"./dataset-loader\").ROLLUP_FIELD_DEFAULTS;\r\n\r\n        // Artifact Client exports\r\n        ArtifactClient?: typeof import(\"./artifact-client\").ArtifactClient;\r\n        AuthenticatedDatasetLoader?: typeof import(\"./artifact-client\").AuthenticatedDatasetLoader;\r\n        MockArtifactClient?: typeof import(\"./artifact-client\").MockArtifactClient;\r\n\r\n        // Settings page exports\r\n        selectDiscoveredPipeline?: (pipelineId: number) => void;\r\n\r\n        // Dashboard debug/config (optional runtime values)\r\n        __DASHBOARD_DEBUG__?: boolean;\r\n        __dashboardMetrics?: unknown;\r\n        LOCAL_DASHBOARD_MODE?: boolean;\r\n        DATASET_PATH?: string;\r\n        process?: { env?: { NODE_ENV?: string } };\r\n    }\r\n}\r\n\r\n// Required for module augmentation to work\r\nexport { };\r\n",
    "usedDeprecatedRules": []
  }
]
