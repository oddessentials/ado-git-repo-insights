PASS tests/sdk-bundling.test.ts
  SDK Bundling Integrity
    VSS.SDK.min.js
      ΓêÜ exists in extension/ui folder (13 ms)
      ΓêÜ is non-empty (1 ms)
      ΓêÜ contains VSS namespace definition (1 ms)
    index.html
      ΓêÜ references local SDK file (1 ms)
      ΓêÜ does not reference versioned CDN URL (1 ms)
      ΓêÜ loads SDK before other scripts (2 ms)
    settings.html
      ΓêÜ references local SDK file
      ΓêÜ does not reference versioned CDN URL (1 ms)
      ΓêÜ loads SDK before settings.js
    package.json
      ΓêÜ includes vss-web-extension-sdk dependency

PASS tests/error-codes.test.ts
  Error Codes
    ErrorCodes object
      ΓêÜ defines all required error types (13 ms)
      ΓêÜ each error has required fields (8 ms)
      ΓêÜ defines predictions-specific errors (1 ms)
      ΓêÜ defines AI insights-specific errors
    getErrorByCode
      ΓêÜ finds error by code string (1 ms)
      ΓêÜ returns null for unknown code
      ΓêÜ finds predictions error codes (1 ms)
    createErrorMessage
      ΓêÜ creates message from error key (1 ms)
      ΓêÜ includes optional details in message
      ΓêÜ falls back to UNKNOWN for invalid key

  console.log
    [DatasetLoader] Found manifest at: file://E:\projects\ado-git-repo-insights\tmp\test-fixtures\1000pr-seed42/dataset-manifest.json

      at DatasetLoader.resolveDatasetRoot (ui/dataset-loader.ts:360:19)

  console.log
    [DatasetLoader] Found manifest at: file://E:\projects\ado-git-repo-insights\tmp\test-fixtures\1000pr-seed42/dataset-manifest.json

      at DatasetLoader.resolveDatasetRoot (ui/dataset-loader.ts:360:19)

  console.log
    [DatasetLoader] Found manifest at: file://E:\projects\ado-git-repo-insights\tmp\test-fixtures\1000pr-seed42/dataset-manifest.json

      at DatasetLoader.resolveDatasetRoot (ui/dataset-loader.ts:360:19)

PASS tests/synthetic-fixtures.test.ts
  Synthetic Fixture Consumer Validation
    ΓêÜ 1000 PR fixture passes loadManifest validation (104 ms)
    ΓêÜ generated manifest has correct schema versions (2 ms)
    ΓêÜ generated rollups load successfully (5 ms)
    ΓêÜ generated dimensions load successfully (6 ms)
    ΓêÜ 5k PR fixture generates successfully (2 ms)
    ΓêÜ 10k PR fixture generates successfully (1 ms)
    ΓêÜ deterministic generation: same seed produces identical manifest structure (4 ms)

PASS tests/metrics.test.ts
  Metrics Collector (Phase 4)
    ΓêÜ Production mode ignores __DASHBOARD_DEBUG__ (14 ms)
    ΓêÜ Production mode ignores ?debug param (25 ms)
    ΓêÜ Debug mode enables metrics with __DASHBOARD_DEBUG__ (3 ms)
    ΓêÜ Debug mode enables metrics with ?debug param (4 ms)
    ΓêÜ Metrics collector mark() creates performance mark (2 ms)
    ΓêÜ Metrics collector measure() creates performance measure (3 ms)
    ΓêÜ Metrics collector reset() clears all metrics (1 ms)

PASS tests/pipeline-artifact-url.test.ts
  Artifact File Access
    downloadUrl Construction
      ΓêÜ replaces format=zip with format=file (13 ms)
      ΓêÜ adds format=file if not present (1 ms)
      ΓêÜ adds subPath parameter with URL-encoded path (1 ms)
      ΓêÜ normalizes path to have leading slash (14 ms)
      ΓêÜ handles nested paths correctly (1 ms)
    Artifact File Paths
      ΓêÜ manifest is at artifact ROOT, not in aggregates subfolder (1 ms)
      ΓêÜ dimensions.json is inside aggregates subfolder
      ΓêÜ weekly rollup paths from manifest include aggregates prefix
      ΓêÜ distribution paths from manifest include aggregates prefix
    Regression Prevention
      ΓêÜ Build API does NOT support $format=file
      ΓêÜ downloadUrl is the correct approach for Pipeline Artifacts (1 ms)
      ΓêÜ subPath must have leading slash for root-level files

FAIL tests/cross-project-settings.test.ts
  Cross-Project Settings
    dashboard.ts configuration
      ├ù should have SETTINGS_KEY_PROJECT constant (16 ms)
      ├ù should have SETTINGS_KEY_PIPELINE constant (4 ms)
      ├ù should have getSourceConfig function that returns both projectId and pipelineId (9 ms)
      ├ù should read project setting with SETTINGS_KEY_PROJECT (53 ms)
      ├ù should log source project origin (5 ms)
      ΓêÜ should use targetProjectId for ArtifactClient initialization (2 ms)
      ├ù should pass targetProjectId to resolveFromPipelineId (15 ms)
      ΓêÜ should pass targetProjectId to discoverAndResolve (2 ms)
    settings.ts configuration
      ├ù should have SETTINGS_KEY_PROJECT constant matching dashboard (28 ms)
      ├ù should have SETTINGS_KEY_PIPELINE constant matching dashboard (2 ms)
      ΓêÜ should have tryLoadProjectDropdown for graceful degradation
      ΓêÜ should have getOrganizationProjects for dropdown population
      ΓêÜ should have projectDropdownAvailable flag (1 ms)
      ├ù should save project ID separately from pipeline ID (1 ms)
    settings keys consistency
      ├ù should use the same settings keys in both files (14 ms)
    vss-extension.json manifest
      ΓêÜ should have vso.project scope for listing projects (1 ms)
      ΓêÜ should have vso.build scope for accessing artifacts (29 ms)
      ΓêÜ should have vso.settings scope for extension data

  ΓùÅ Cross-Project Settings ΓÇ║ dashboard.ts configuration ΓÇ║ should have SETTINGS_KEY_PROJECT constant

    expect(received).toContain(expected) // indexOf

    Expected substring: "SETTINGS_KEY_PROJECT = 'pr-insights-source-project'"
    Received string:    "/**
     * PR Insights Dashboard
     *
     * Project-level hub that loads data from pipeline artifacts.
     * Uses Azure DevOps Extension SDK for authentication.
     *
     * Configuration precedence:
     * 1. ?dataset=<url> - Direct URL (DEV ONLY)
     * 2. ?pipelineId=<id> - Query parameter override
     * 3. Extension settings - User-scoped saved preference
     * 4. Auto-discovery - Find pipelines with 'aggregates' artifact
     */┬╖
    import { DatasetLoader, IDatasetLoader, Rollup } from \"./dataset-loader\";
    import { ArtifactClient } from \"./artifact-client\";
    import {
      PrInsightsError,
      ErrorTypes,
      createSetupRequiredError,
      createNoSuccessfulBuildsError,
      createArtifactsMissingError,
      createInvalidConfigError,
      SetupRequiredDetails,
      MultiplePipelinesDetails,
      ArtifactsMissingDetails,
    } from \"./error-types\";┬╖
    // Dashboard state
    let loader: IDatasetLoader | null = null;
    let artifactClient: ArtifactClient | null = null;
    let currentDateRange: { start: Date | null; end: Date | null } = {
      start: null,
      end: null,
    };
    let currentFilters: { repos: string[]; teams: string[] } = {
      repos: [],
      teams: [],
    };
    let comparisonMode = false;
    let cachedRollups: Rollup[] = []; // Cache for export
    let currentBuildId: number | null = null; // Store build ID for raw data download
    let sdkInitialized = false;┬╖
    // Settings keys for extension data storage (must match settings.js)
    const SETTINGS_KEY_PROJECT = \"pr-insights-source-project\";
    const SETTINGS_KEY_PIPELINE = \"pr-insights-pipeline-id\";┬╖
    // Feature flags
    const ENABLE_PHASE5_FEATURES = true;┬╖
    // DOM element cache
    const elements: Record<string, any> = {};┬╖
    /**
     * Phase 4: Production-safe metrics collector
     */
    const IS_PRODUCTION =
      typeof window !== \"undefined\" &&
      (window as any).process?.env?.NODE_ENV === \"production\";
    const DEBUG_ENABLED =
      !IS_PRODUCTION &&
      ((typeof window !== \"undefined\" && (window as any).__DASHBOARD_DEBUG__) ||
        (typeof window !== \"undefined\" &&
          new URLSearchParams(window.location.search).has(\"debug\")));┬╖
    interface PerformanceMetric {
      name: string;
      duration: number;
      timestamp: number;
    }┬╖
    const metricsCollector = DEBUG_ENABLED
      ? {
          marks: new Map<string, number>(),
          measures: [] as PerformanceMetric[],
          mark(name: string) {
            if (!performance || !performance.mark) return;
            try {
              performance.mark(name);
              this.marks.set(name, performance.now());
            } catch (_e) {
              /* ignore */
            }
          },
          measure(name: string, startMark: string, endMark: string) {
            if (!performance || !performance.measure) return;
            try {
              performance.measure(name, startMark, endMark);
              const entries = performance.getEntriesByName(name, \"measure\");
              if (entries.length > 0) {
                const lastEntry = entries[entries.length - 1];
                if (lastEntry) {
                  this.measures.push({
                    name,
                    duration: lastEntry.duration,
                    timestamp: Date.now(),
                  });
                }
              }
            } catch (_e) {
              /* ignore */
            }
          },
          getMetrics() {
            return {
              marks: Array.from(this.marks.entries()).map(([name, time]) => ({
                name,
                time,
              })),
              measures: [...this.measures],
            };
          },
          reset() {
            this.marks.clear();
            this.measures = [];
            if (performance && performance.clearMarks) performance.clearMarks();
            if (performance && performance.clearMeasures)
              performance.clearMeasures();
          },
        }
      : null;┬╖
    if (DEBUG_ENABLED && typeof window !== \"undefined\") {
      (window as any).__dashboardMetrics = metricsCollector;
    }┬╖
    // ============================================================================
    // SDK Initialization
    // ============================================================================┬╖
    /**
     * Initialize Azure DevOps Extension SDK.
     */
    async function initializeAdoSdk(): Promise<void> {
      if (sdkInitialized) return;┬╖
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error(\"Azure DevOps SDK initialization timed out\"));
        }, 10000);┬╖
        VSS.init({
          explicitNotifyLoaded: true,
          usePlatformScripts: true,
          usePlatformStyles: true,
        });┬╖
        VSS.ready(() => {
          clearTimeout(timeout);
          sdkInitialized = true;┬╖
          // Update project name in UI
          const webContext = VSS.getWebContext();
          const projectNameEl = document.getElementById(\"current-project-name\");
          if (projectNameEl && webContext?.project?.name) {
            projectNameEl.textContent = webContext.project.name;
          }┬╖
          VSS.notifyLoadSucceeded();
          resolve();
        });
      });
    }┬╖
    // ============================================================================
    // Configuration Resolution
    // ============================================================================┬╖
    /**
     * Parse and validate query parameters.
     */
    function parseQueryParams():
      | { mode: string; value: any; warning?: string | null }
      | PrInsightsError {
      const params = new URLSearchParams(window.location.search);┬╖
      const datasetUrl = params.get(\"dataset\");
      const pipelineIdStr = params.get(\"pipelineId\");┬╖
      // Check for dataset URL (highest priority)
      if (datasetUrl) {
        // Validate URL
        if (!datasetUrl.startsWith(\"https://\")) {
          return createInvalidConfigError(
            \"dataset\",
            datasetUrl,
            \"Must be a valid HTTPS URL\",
          );
        }┬╖
        // Security warning for non-ADO domains
        const IS_DEV =
          window.location.hostname === \"localhost\" || params.has(\"devMode\");┬╖
        if (!IS_DEV) {
          try {
            const urlHost = new URL(datasetUrl).hostname;
            const isAdoDomain =
              urlHost.endsWith(\"dev.azure.com\") ||
              urlHost.endsWith(\".visualstudio.com\") ||
              urlHost.endsWith(\".azure.com\");
            if (!isAdoDomain) {
              console.warn(
                `SECURITY: ?dataset= URL \"${urlHost}\" is not an Azure DevOps domain. ` +
                  `This parameter is intended for development only.`,
              );
            }
          } catch (_e) {
            return createInvalidConfigError(
              \"dataset\",
              datasetUrl,
              \"Invalid URL format\",
            );
          }
        }┬╖
        let warning: string | null = null;
        if (pipelineIdStr) {
          warning = \"Both dataset and pipelineId specified; using dataset\";
          console.warn(warning);
        }┬╖
        return { mode: \"direct\", value: datasetUrl, warning };
      }┬╖
      // Check for pipelineId
      if (pipelineIdStr) {
        const pipelineId = parseInt(pipelineIdStr, 10);
        if (isNaN(pipelineId) || pipelineId <= 0) {
          return createInvalidConfigError(
            \"pipelineId\",
            pipelineIdStr,
            \"Must be a positive integer\",
          );
        }
        return { mode: \"explicit\", value: pipelineId };
      }┬╖
      return { mode: \"discover\", value: null };
    }┬╖
    /**
     * Get source configuration from extension settings.
     */
    async function getSourceConfig(): Promise<{
      projectId: string | null;
      pipelineId: number | null;
    }> {
      const result: { projectId: string | null; pipelineId: number | null } = {
        projectId: null,
        pipelineId: null,
      };
      try {
        const dataService = await VSS.getService<IExtensionDataService>(
          VSS.ServiceIds.ExtensionData,
        );┬╖
        // Get source project ID
        const savedProjectId = await dataService.getValue<string>(
          SETTINGS_KEY_PROJECT,
          { scopeType: \"User\" },
        );
        if (
          savedProjectId &&
          typeof savedProjectId === \"string\" &&
          savedProjectId.trim()
        ) {
          result.projectId = savedProjectId.trim();
        }┬╖
        // Get pipeline definition ID
        const savedPipelineId = await dataService.getValue<number>(
          SETTINGS_KEY_PIPELINE,
          { scopeType: \"User\" },
        );
        if (
          savedPipelineId &&
          typeof savedPipelineId === \"number\" &&
          savedPipelineId > 0
        ) {
          result.pipelineId = savedPipelineId;
        }
      } catch (e) {
        console.log(\"Could not read extension settings:\", e);
      }
      return result;
    }┬╖
    /**
     * Clear stale pipeline ID setting.
     */
    async function clearStalePipelineSetting(): Promise<void> {
      try {
        const dataService = await VSS.getService<IExtensionDataService>(
          VSS.ServiceIds.ExtensionData,
        );
        await dataService.setValue(SETTINGS_KEY_PIPELINE, null, {
          scopeType: \"User\",
        });
        console.log(\"Cleared stale pipeline setting to re-enable auto-discovery\");
      } catch (e) {
        console.warn(\"Could not clear stale pipeline setting:\", e);
      }
    }┬╖
    /**
     * Resolve configuration using precedence rules.
     */
    async function resolveConfiguration(): Promise<{
      buildId?: number;
      artifactName?: string;
      directUrl?: string;
    }> {
      const queryResult = parseQueryParams();┬╖
      // Check for parsing error
      if (queryResult instanceof PrInsightsError) {
        throw queryResult;
      }┬╖
      // Mode: direct URL
      if (queryResult.mode === \"direct\") {
        return { directUrl: queryResult.value };
      }┬╖
      // Get current project context
      const webContext = VSS.getWebContext();
      const currentProjectId = webContext.project?.id;
      if (!currentProjectId) {
        throw new Error(\"No project context available\");
      }┬╖
      // Get configured source from settings
      const sourceConfig = await getSourceConfig();┬╖
      // Determine which project to use for artifact access
      const targetProjectId = sourceConfig.projectId || currentProjectId;┬╖
      console.log(
        `Source project: ${targetProjectId}${sourceConfig.projectId ? \" (from settings)\" : \" (current context)\"}`,
      );┬╖
      // Initialize artifact client with target project
      artifactClient = new ArtifactClient(targetProjectId);
      await artifactClient.initialize();┬╖
      // Mode: explicit pipelineId from query
      if (queryResult.mode === \"explicit\") {
        return await resolveFromPipelineId(queryResult.value, targetProjectId);
      }┬╖
      // Check settings for pipeline ID
      if (sourceConfig.pipelineId) {
        console.log(
          `Using pipeline definition ID from settings: ${sourceConfig.pipelineId}`,
        );
        try {
          return await resolveFromPipelineId(
            sourceConfig.pipelineId,
            targetProjectId,
          );
        } catch (error: any) {
          console.warn(
            `Saved pipeline ${sourceConfig.pipelineId} is invalid, falling back to auto-discovery:`,
            error.message,
          );
          await clearStalePipelineSetting();
        }
      }┬╖
      // Mode: discovery in target project
      return await discoverAndResolve(targetProjectId);
    }┬╖
    /**
     * Resolve artifact info from a specific pipeline ID.
     */
    async function resolveFromPipelineId(
      pipelineId: number,
      projectId: string,
    ): Promise<{ buildId: number; artifactName: string }> {
      // Get Build REST client
      const buildClient = await getBuildClient();┬╖
      // Get latest successful build
      const builds = await buildClient.getBuilds(
        projectId,
        [pipelineId],
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined, // reasonFilter
        2, // statusFilter: Completed
        6, // resultFilter: Succeeded (2) | PartiallySucceeded (4)
        undefined,
        undefined,
        1, // top
      );┬╖
      if (!builds || builds.length === 0) {
        const definitions = await buildClient.getDefinitions(
          projectId,
          undefined,
          undefined,
          undefined,
          2,
          undefined,
          undefined,
          undefined,
          [pipelineId],
        );
        const name = definitions?.[0]?.name || `ID ${pipelineId}`;
        throw createNoSuccessfulBuildsError(name);
      }┬╖
      const latestBuild = builds[0];
      if (!latestBuild) throw new Error(\"Failed to retrieve latest build\");┬╖
      // Check for aggregates artifact
      if (!artifactClient) throw new Error(\"ArtifactClient not initialized\");
      const artifacts = await artifactClient.getArtifacts(latestBuild.id);
      const hasAggregates = artifacts.some((a) => a.name === \"aggregates\");┬╖
      if (!hasAggregates) {
        const definitions = await buildClient.getDefinitions(
          projectId,
          undefined,
          undefined,
          undefined,
          2,
          undefined,
          undefined,
          undefined,
          [pipelineId],
        );
        const name = definitions?.[0]?.name || `ID ${pipelineId}`;
        throw createArtifactsMissingError(name, latestBuild.id);
      }┬╖
      return { buildId: latestBuild.id, artifactName: \"aggregates\" };
    }┬╖
    /**
     * Discover pipelines with aggregates and resolve.
     */
    async function discoverAndResolve(
      projectId: string,
    ): Promise<{ buildId: number; artifactName: string }> {
      const matches = await discoverInsightsPipelines(projectId);┬╖
      if (matches.length === 0) {
        throw createSetupRequiredError();
      }┬╖
      const firstMatch = matches[0];
      if (!firstMatch) throw createSetupRequiredError();┬╖
      return { buildId: firstMatch.buildId, artifactName: \"aggregates\" };
    }┬╖
    /**
     * Discover pipelines with aggregates artifact.
     */
    async function discoverInsightsPipelines(
      projectId: string,
    ): Promise<Array<{ id: number; name: string; buildId: number }>> {
      const buildClient = await getBuildClient();
      const matches: Array<{ id: number; name: string; buildId: number }> = [];┬╖
      const definitions = await buildClient.getDefinitions(
        projectId,
        undefined,
        undefined,
        undefined,
        2,
        50,
      );┬╖
      for (const def of definitions) {
        const builds = await buildClient.getBuilds(
          projectId,
          [def.id],
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          2,
          6,
          undefined,
          undefined,
          1,
        );┬╖
        if (!builds || builds.length === 0) continue;┬╖
        const latestBuild = builds[0];
        if (!latestBuild) continue;┬╖
        try {
          if (!artifactClient) throw new Error(\"ArtifactClient not initialized\");
          const artifacts = await artifactClient.getArtifacts(latestBuild.id);
          if (!artifacts.some((a) => a.name === \"aggregates\")) continue;┬╖
          matches.push({
            id: def.id,
            name: def.name,
            buildId: latestBuild.id,
          });
        } catch (e) {
          console.debug(`Skipping pipeline ${def.name}:`, e);
        }
      }┬╖
      return matches;
    }┬╖
    /**
     * Get Build REST client from SDK.
     */
    async function getBuildClient(): Promise<IBuildRestClient> {
      return new Promise((resolve) => {
        VSS.require([\"TFS/Build/RestClient\"], (BuildRestClient: any) => {
          resolve(BuildRestClient.getClient());
        });
      });
    }┬╖
    // ============================================================================
    // Main Initialization
    // ============================================================================┬╖
    /**
     * Check if running in local dashboard mode.
     */
    function isLocalMode(): boolean {
      return (
        typeof window !== \"undefined\" &&
        (window as any).LOCAL_DASHBOARD_MODE === true
      );
    }┬╖
    /**
     * Get local dataset path from window config.
     */
    function getLocalDatasetPath(): string {
      return (
        (typeof window !== \"undefined\" && (window as any).DATASET_PATH) ||
        \"./dataset\"
      );
    }┬╖
    /**
     * Initialize the dashboard.
     */
    async function init(): Promise<void> {
      if (metricsCollector) metricsCollector.mark(\"dashboard-init\");┬╖
      cacheElements();
      setupEventListeners();
      initializePhase5Features();┬╖
      try {
        if (isLocalMode()) {
          console.log(\"[Dashboard] Running in local mode\");
          const datasetPath = getLocalDatasetPath();
          loader = new DatasetLoader(datasetPath);
          currentBuildId = null;┬╖
          const projectNameEl = document.getElementById(\"current-project-name\");
          if (projectNameEl) {
            projectNameEl.textContent = \"Local Dashboard\";
          }┬╖
          const exportRawZip = document.getElementById(\"export-raw-zip\");
          if (exportRawZip) {
            exportRawZip.style.display = \"none\";
          }┬╖
          await loadDataset();
          return;
        }┬╖
        await initializeAdoSdk();
        const config = await resolveConfiguration();┬╖
        if (config.directUrl) {
          loader = new DatasetLoader(config.directUrl);
          currentBuildId = null;
        } else if (config.buildId && config.artifactName && artifactClient) {
          loader = artifactClient.createDatasetLoader(
            config.buildId,
            config.artifactName,
          );
          currentBuildId = config.buildId;
        } else {
          throw new Error(\"Failed to resolve configuration\");
        }┬╖
        await loadDataset();
      } catch (error: any) {
        console.error(\"Dashboard initialization failed:\", error);
        handleError(error);
      }
    }┬╖
    /**
     * Handle errors with appropriate UI panels.
     */
    function handleError(error: any): void {
      hideAllPanels();┬╖
      if (error instanceof PrInsightsError) {
        switch (error.type) {
          case ErrorTypes.SETUP_REQUIRED:
            showSetupRequired(error);
            break;
          case ErrorTypes.MULTIPLE_PIPELINES:
            showMultiplePipelines(error);
            break;
          case ErrorTypes.ARTIFACTS_MISSING:
            showArtifactsMissing(error);
            break;
          case ErrorTypes.PERMISSION_DENIED:
            showPermissionDenied(error);
            break;
          default:
            showGenericError(error.title, error.message);
            break;
        }
      } else {
        showGenericError(\"Error\", error.message || \"An unexpected error occurred\");
      }
    }┬╖
    /**
     * Hide all error/setup panels.
     */
    function hideAllPanels(): void {
      [
        \"setup-required\",
        \"multiple-pipelines\",
        \"artifacts-missing\",
        \"permission-denied\",
        \"error-state\",
        \"loading-state\",
        \"main-content\",
      ].forEach((id) => {
        document.getElementById(id)?.classList.add(\"hidden\");
      });
    }┬╖
    /**
     * Show setup required panel.
     */
    function showSetupRequired(error: PrInsightsError): void {
      const panel = document.getElementById(\"setup-required\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"setup-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      const details = error.details as SetupRequiredDetails;
      if (details?.instructions && Array.isArray(details.instructions)) {
        const stepsList = document.getElementById(\"setup-steps\");
        if (stepsList) {
          stepsList.innerHTML = details.instructions
            .map((s: string) => `<li>${s}</li>`)
            .join(\"\");
        }
      }┬╖
      if (details?.docsUrl) {
        const docsLink = document.getElementById(
          \"docs-link\",
        ) as HTMLAnchorElement | null;
        if (docsLink) docsLink.href = String(details.docsUrl);
      }┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show multiple pipelines panel.
     */
    function showMultiplePipelines(error: PrInsightsError): void {
      const panel = document.getElementById(\"multiple-pipelines\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"multiple-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      const listEl = document.getElementById(\"pipeline-list\");
      const details = error.details as MultiplePipelinesDetails;
      if (listEl && details?.matches && Array.isArray(details.matches)) {
        listEl.innerHTML = details.matches
          .map(
            (m: any) => `
                    <a href=\"?pipelineId=${m.id}\" class=\"pipeline-option\">
                        <strong>${m.name}</strong>
                        <span class=\"pipeline-id\">ID: ${m.id}</span>
                    </a>
                `,
          )
          .join(\"\");
      }┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show permission denied panel.
     */
    function showPermissionDenied(error: PrInsightsError): void {
      const panel = document.getElementById(\"permission-denied\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"permission-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show generic error state.
     */
    function showGenericError(title: string, message: string): void {
      const panel = document.getElementById(\"error-state\");
      if (!panel) return;┬╖
      const titleEl = document.getElementById(\"error-title\");
      const messageEl = document.getElementById(\"error-message\");┬╖
      if (titleEl) titleEl.textContent = title;
      if (messageEl) messageEl.textContent = message;┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show artifacts missing panel.
     */
    function showArtifactsMissing(error: PrInsightsError): void {
      const panel = document.getElementById(\"artifacts-missing\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"missing-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      const details = error.details as ArtifactsMissingDetails;
      if (details?.instructions && Array.isArray(details.instructions)) {
        const stepsList = document.getElementById(\"missing-steps\");
        if (stepsList) {
          stepsList.innerHTML = details.instructions
            .map((s: string) => `<li>${s}</li>`)
            .join(\"\");
        }
      }┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    // ============================================================================
    // DOM and Event Handling
    // ============================================================================┬╖
    /**
     * Cache DOM elements for performance.
     */
    function cacheElements(): void {
      const ids = [
        \"app\",
        \"loading-state\",
        \"error-state\",
        \"main-content\",
        \"error-title\",
        \"error-message\",
        \"run-info\",
        \"date-range\",
        \"custom-dates\",
        \"start-date\",
        \"end-date\",
        \"retry-btn\",
        \"total-prs\",
        \"cycle-p50\",
        \"cycle-p90\",
        \"authors-count\",
        \"reviewers-count\",
        \"throughput-chart\",
        \"cycle-distribution\",
        \"total-prs-delta\",
        \"cycle-p50-delta\",
        \"cycle-p90-delta\",
        \"authors-delta\",
        \"reviewers-delta\",
        \"repo-filter\",
        \"team-filter\",
        \"repo-filter-group\",
        \"team-filter-group\",
        \"clear-filters\",
        \"active-filters\",
        \"filter-chips\",
        \"total-prs-sparkline\",
        \"cycle-p50-sparkline\",
        \"cycle-p90-sparkline\",
        \"authors-sparkline\",
        \"reviewers-sparkline\",
        \"cycle-time-trend\",
        \"reviewer-activity\",
        \"compare-toggle\",
        \"comparison-banner\",
        \"current-period-dates\",
        \"previous-period-dates\",
        \"exit-compare\",
        \"export-btn\",
        \"export-menu\",
        \"export-csv\",
        \"export-link\",
        \"export-raw-zip\",
      ];┬╖
      ids.forEach((id) => {
        elements[id] = document.getElementById(id);
      });┬╖
      elements.tabs = document.querySelectorAll(\".tab\");
    }┬╖
    /**
     * Initialize Phase 5 features.
     */
    function initializePhase5Features(): void {
      const phase5Tabs = document.querySelectorAll(\".phase5-tab\");┬╖
      if (ENABLE_PHASE5_FEATURES) {
        phase5Tabs.forEach((tab) => tab.classList.remove(\"hidden\"));
        console.log(\"Phase 5 features enabled\");
      } else {
        console.log(\"Phase 5 features disabled\");
      }
    }┬╖
    /**
     * Set up event listeners.
     */
    function setupEventListeners(): void {
      elements[\"date-range\"]?.addEventListener(\"change\", handleDateRangeChange);
      document
        .getElementById(\"apply-dates\")
        ?.addEventListener(\"click\", applyCustomDates);┬╖
      elements.tabs?.forEach((tab: HTMLElement) => {
        tab.addEventListener(\"click\", () => {
          const tabId = tab.dataset[\"tab\"];
          if (tabId) switchTab(tabId);
        });
      });┬╖
      elements[\"retry-btn\"]?.addEventListener(\"click\", () => init());
      document
        .getElementById(\"setup-retry-btn\")
        ?.addEventListener(\"click\", () => init());
      document
        .getElementById(\"permission-retry-btn\")
        ?.addEventListener(\"click\", () => init());┬╖
      elements[\"repo-filter\"]?.addEventListener(\"change\", handleFilterChange);
      elements[\"team-filter\"]?.addEventListener(\"change\", handleFilterChange);
      elements[\"clear-filters\"]?.addEventListener(\"click\", clearAllFilters);┬╖
      elements[\"compare-toggle\"]?.addEventListener(\"click\", toggleComparisonMode);
      elements[\"exit-compare\"]?.addEventListener(\"click\", exitComparisonMode);┬╖
      elements[\"export-btn\"]?.addEventListener(\"click\", toggleExportMenu);
      elements[\"export-csv\"]?.addEventListener(\"click\", exportToCsv);
      elements[\"export-link\"]?.addEventListener(\"click\", copyShareableLink);
      elements[\"export-raw-zip\"]?.addEventListener(\"click\", downloadRawDataZip);┬╖
      document.addEventListener(\"click\", (e: MouseEvent) => {
        const target = e.target as HTMLElement;
        if (!target.closest(\".export-dropdown\")) {
          elements[\"export-menu\"]?.classList.add(\"hidden\");
        }
      });
    }┬╖
    // ============================================================================
    // Data Loading and Rendering
    // ============================================================================┬╖
    /**
     * Load the dataset.
     */
    async function loadDataset(): Promise<void> {
      showLoading();┬╖
      try {
        if (!loader) throw new Error(\"Loader not initialized\");┬╖
        // Load manifest first
        const manifest = await loader.loadManifest();┬╖
        // Load dimensions
        const dimensions = await loader.loadDimensions();┬╖
        // Populate filter dropdowns from dimensions
        populateFilterDropdowns(dimensions);┬╖
        // Show dataset info
        updateDatasetInfo(manifest);┬╖
        // Restore state from URL if present
        restoreStateFromUrl();┬╖
        // Set initial date range from manifest defaults
        setInitialDateRange();┬╖
        // Load and render metrics
        await refreshMetrics();┬╖
        // Update feature tabs based on manifest
        await updateFeatureTabs();┬╖
        showContent();
      } catch (error) {
        console.error(\"Failed to load dataset:\", error);
        handleError(error);
      }
    }┬╖
    /**
     * Set initial date range from manifest defaults.
     */
    function setInitialDateRange(): void {
      // Skip if already restored from URL
      if (currentDateRange.start && currentDateRange.end) return;
      if (!loader) return;┬╖
      const coverage = loader.getCoverage() || null;
      const defaultDays = loader.getDefaultRangeDays() || 90;┬╖
      if (coverage?.date_range?.max) {
        const endDate = new Date(coverage.date_range.max);
        const startDate = new Date(endDate);
        startDate.setDate(startDate.getDate() - defaultDays);┬╖
        currentDateRange = { start: startDate, end: endDate };┬╖
        if (elements[\"start-date\"]) {
          elements[\"start-date\"].value = startDate.toISOString().split(\"T\")[0];
        }
        if (elements[\"end-date\"]) {
          elements[\"end-date\"].value = endDate.toISOString().split(\"T\")[0];
        }
      }
    }┬╖
    /**
     * Calculate the previous period date range for comparison.
     */
    function getPreviousPeriod(start: Date, end: Date): { start: Date; end: Date } {
      const durationMs = end.getTime() - start.getTime();
      const prevEnd = new Date(start.getTime() - 1); // Day before current start
      const prevStart = new Date(prevEnd.getTime() - durationMs);
      return { start: prevStart, end: prevEnd };
    }┬╖
    /**
     * Apply dimension filters to rollups data.
     * Uses by_repository slices when available for accurate filtering.
     */
    function applyFiltersToRollups(
      rollups: Rollup[],
      filters: { repos: string[]; teams: string[] },
    ): Rollup[] {
      // No filters active - return original data
      if (!filters.repos.length && !filters.teams.length) {
        return rollups;
      }┬╖
      return rollups.map((rollup) => {
        // If we have by_repository slices and repo filter is active, use them
        if (filters.repos.length && rollup.by_repository) {
          const selectedRepos = filters.repos
            .map((repoId) => {
              const repoData = rollup.by_repository![repoId];
              if (repoData) return repoData;┬╖
              return Object.entries(rollup.by_repository!).find(
                ([name]) => name === repoId,
              )?.[1];
            })
            .filter(Boolean) as any[];┬╖
          if (selectedRepos.length === 0) {
            return {
              ...rollup,
              pr_count: 0,
              cycle_time_p50: null,
              cycle_time_p90: null,
              authors_count: 0,
              reviewers_count: 0,
            };
          }┬╖
          // Aggregate metrics
          const totalPrCount = selectedRepos.reduce(
            (sum, r) => sum + (r.pr_count || 0),
            0,
          );
          const p50Values = selectedRepos
            .map((r) => r.cycle_time_p50)
            .filter((v) => v != null);
          const p90Values = selectedRepos
            .map((r) => r.cycle_time_p90)
            .filter((v) => v != null);┬╖
          const avgP50 =
            p50Values.length > 0
              ? p50Values.reduce((a, b) => a + b, 0) / p50Values.length
              : null;
          const avgP90 =
            p90Values.length > 0
              ? p90Values.reduce((a, b) => a + b, 0) / p90Values.length
              : null;┬╖
          const totalAuthors = selectedRepos.reduce(
            (sum, r) => sum + (r.authors_count || 0),
            0,
          );
          const totalReviewers = selectedRepos.reduce(
            (sum, r) => sum + (r.reviewers_count || 0),
            0,
          );┬╖
          return {
            ...rollup,
            pr_count: totalPrCount,
            cycle_time_p50: avgP50,
            cycle_time_p90: avgP90,
            authors_count: totalAuthors,
            reviewers_count: totalReviewers,
          } as Rollup;
        }┬╖
        // If we have by_team slices and team filter is active, use them
        if (filters.teams.length && rollup.by_team) {
          const selectedTeams = filters.teams
            .map((teamId) => rollup.by_team![teamId])
            .filter(Boolean) as any[];┬╖
          if (selectedTeams.length === 0) {
            return {
              ...rollup,
              pr_count: 0,
              cycle_time_p50: null,
              cycle_time_p90: null,
              authors_count: 0,
              reviewers_count: 0,
            };
          }┬╖
          const totalPrCount = selectedTeams.reduce(
            (sum, t) => sum + (t.pr_count || 0),
            0,
          );
          const p50Values = selectedTeams
            .map((t) => t.cycle_time_p50)
            .filter((v) => v != null);
          const avgP50 =
            p50Values.length > 0
              ? p50Values.reduce((a, b) => a + b, 0) / p50Values.length
              : null;┬╖
          return {
            ...rollup,
            pr_count: totalPrCount,
            cycle_time_p50: avgP50,
          } as Rollup;
        }┬╖
        return rollup;
      });
    }┬╖
    /**
     * Refresh metrics for current date range.
     */
    async function refreshMetrics(): Promise<void> {
      if (!currentDateRange.start || !currentDateRange.end || !loader) return;┬╖
      // Load current period data
      const rawRollups = await loader.getWeeklyRollups(
        currentDateRange.start,
        currentDateRange.end,
      );┬╖
      const distributions = await loader.getDistributions(
        currentDateRange.start,
        currentDateRange.end,
      );┬╖
      // Apply dimension filters to rollups
      const rollups = applyFiltersToRollups(rawRollups, currentFilters);┬╖
      // Load previous period data for comparison
      const prevPeriod = getPreviousPeriod(
        currentDateRange.start,
        currentDateRange.end,
      );
      let prevRollups: Rollup[] = [];
      try {
        const rawPrevRollups = await loader.getWeeklyRollups(
          prevPeriod.start,
          prevPeriod.end,
        );
        prevRollups = applyFiltersToRollups(rawPrevRollups, currentFilters);
      } catch (e) {
        console.debug(\"Previous period data not available:\", e);
      }┬╖
      // Cache filtered rollups for export
      cachedRollups = rollups;┬╖
      renderSummaryCards(rollups, prevRollups);
      renderThroughputChart(rollups);
      renderCycleTimeTrend(rollups);
      renderReviewerActivity(rollups);
      renderCycleDistribution(distributions);┬╖
      // Update comparison banner if in comparison mode
      if (comparisonMode) {
        updateComparisonBanner();
      }
    }┬╖
    interface CalculatedMetrics {
      totalPrs: number;
      cycleP50: number | null;
      cycleP90: number | null;
      avgAuthors: number;
      avgReviewers: number;
    }┬╖
    /**
     * Calculate metrics from rollups data.
     */
    function calculateMetrics(rollups: Rollup[]): CalculatedMetrics {
      if (!rollups || !rollups.length) {
        return {
          totalPrs: 0,
          cycleP50: null,
          cycleP90: null,
          avgAuthors: 0,
          avgReviewers: 0,
        };
      }┬╖
      const totalPrs = rollups.reduce((sum, r) => sum + (r.pr_count || 0), 0);┬╖
      const p50Values = rollups
        .map((r) => r.cycle_time_p50)
        .filter((v): v is number => v !== null && v !== undefined);
      const p90Values = rollups
        .map((r) => r.cycle_time_p90)
        .filter((v): v is number => v !== null && v !== undefined);┬╖
      const authorsSum = rollups.reduce(
        (sum, r) => sum + (r.authors_count || 0),
        0,
      );
      const reviewersSum = rollups.reduce(
        (sum, r) => sum + (r.reviewers_count || 0),
        0,
      );┬╖
      return {
        totalPrs,
        cycleP50: p50Values.length ? median(p50Values) : null,
        cycleP90: p90Values.length ? median(p90Values) : null,
        avgAuthors:
          rollups.length > 0 ? Math.round(authorsSum / rollups.length) : 0,
        avgReviewers:
          rollups.length > 0 ? Math.round(reviewersSum / rollups.length) : 0,
      };
    }┬╖
    /**
     * Calculate percentage change between two values.
     */
    function calculatePercentChange(
      current: number | null | undefined,
      previous: number | null | undefined,
    ): number | null {
      if (previous === null || previous === undefined || previous === 0) {
        return null;
      }
      if (current === null || current === undefined) {
        return null;
      }
      return ((current - previous) / previous) * 100;
    }┬╖
    /**
     * Render a delta indicator element.
     */
    function renderDelta(
      element: HTMLElement | null,
      percentChange: number | null,
      inverse = false,
    ): void {
      if (!element) return;┬╖
      if (percentChange === null) {
        element.innerHTML = \"\";
        element.className = \"metric-delta\";
        return;
      }┬╖
      const isNeutral = Math.abs(percentChange) < 2; // Within 2% is neutral
      const isPositive = percentChange > 0;
      const absChange = Math.abs(percentChange);┬╖
      let cssClass = \"metric-delta \";
      let arrow = \"\";┬╖
      if (isNeutral) {
        cssClass += \"delta-neutral\";
        arrow = \"~\";
      } else if (isPositive) {
        cssClass += inverse ? \"delta-negative-inverse\" : \"delta-positive\";
        arrow = \"&#9650;\"; // Up arrow
      } else {
        cssClass += inverse ? \"delta-positive-inverse\" : \"delta-negative\";
        arrow = \"&#9660;\"; // Down arrow
      }┬╖
      const sign = isPositive ? \"+\" : \"\";
      element.className = cssClass;
      element.innerHTML = `<span class=\"delta-arrow\">${arrow}</span> ${sign}${absChange.toFixed(0)}% <span class=\"delta-label\">vs prev</span>`;
    }┬╖
    /**
     * Render a sparkline SVG from data points.
     */
    function renderSparkline(element: HTMLElement | null, values: number[]): void {
      if (!element || !values || values.length < 2) {
        if (element) element.innerHTML = \"\";
        return;
      }┬╖
      // Take last 8 values for sparkline
      const data = values.slice(-8);
      const width = 60;
      const height = 24;
      const padding = 2;┬╖
      const minVal = Math.min(...data);
      const maxVal = Math.max(...data);
      const range = maxVal - minVal || 1;┬╖
      // Calculate points
      const points = data.map((val, i) => {
        const x = padding + (i / (data.length - 1)) * (width - padding * 2);
        const y =
          height - padding - ((val - minVal) / range) * (height - padding * 2);
        return { x, y };
      });┬╖
      // Create path
      const pathD = points
        .map((p, i) => `${i === 0 ? \"M\" : \"L\"} ${p.x.toFixed(1)} ${p.y.toFixed(1)}`)
        .join(\" \");┬╖
      // Create area path (closed)
      const areaD =
        pathD +
        ` L ${points[points.length - 1]!.x.toFixed(1)} ${height - padding} L ${points[0]!.x.toFixed(1)} ${height - padding} Z`;┬╖
      // Last point for dot
      const lastPoint = points[points.length - 1]!;┬╖
      element.innerHTML = `
            <svg viewBox=\"0 0 ${width} ${height}\" preserveAspectRatio=\"none\">
                <path class=\"sparkline-area\" d=\"${areaD}\"/>
                <path class=\"sparkline-line\" d=\"${pathD}\"/>
                <circle class=\"sparkline-dot\" cx=\"${lastPoint.x.toFixed(1)}\" cy=\"${lastPoint.y.toFixed(1)}\" r=\"2\"/>
            </svg>
        `;
    }┬╖
    /**
     * Extract sparkline data from rollups.
     */
    function extractSparklineData(rollups: Rollup[]): {
      prCounts: number[];
      p50s: number[];
      p90s: number[];
      authors: number[];
      reviewers: number[];
    } {
      if (!rollups || !rollups.length) {
        return { prCounts: [], p50s: [], p90s: [], authors: [], reviewers: [] };
      }┬╖
      return {
        prCounts: rollups.map((r) => r.pr_count || 0),
        p50s: rollups
          .map((r) => r.cycle_time_p50)
          .filter((v): v is number => v !== null && v !== undefined),
        p90s: rollups
          .map((r) => r.cycle_time_p90)
          .filter((v): v is number => v !== null && v !== undefined),
        authors: rollups.map((r) => r.authors_count || 0),
        reviewers: rollups.map((r) => r.reviewers_count || 0),
      };
    }┬╖
    /**
     * Render summary metric cards.
     */
    function renderSummaryCards(
      rollups: Rollup[],
      prevRollups: Rollup[] = [],
    ): void {
      if (metricsCollector) metricsCollector.mark(\"render-summary-cards-start\");┬╖
      const current = calculateMetrics(rollups);
      const previous = calculateMetrics(prevRollups);┬╖
      // Render metric values
      if (elements[\"total-prs\"])
        elements[\"total-prs\"].textContent = current.totalPrs.toLocaleString();
      if (elements[\"cycle-p50\"])
        elements[\"cycle-p50\"].textContent =
          current.cycleP50 !== null ? formatDuration(current.cycleP50) : \"-\";
      if (elements[\"cycle-p90\"])
        elements[\"cycle-p90\"].textContent =
          current.cycleP90 !== null ? formatDuration(current.cycleP90) : \"-\";
      if (elements[\"authors-count\"])
        elements[\"authors-count\"].textContent = current.avgAuthors.toLocaleString();
      if (elements[\"reviewers-count\"]) {
        elements[\"reviewers-count\"].textContent =
          current.avgReviewers.toLocaleString();
      }┬╖
      // Render sparklines
      const sparklineData = extractSparklineData(rollups);
      renderSparkline(elements[\"total-prs-sparkline\"], sparklineData.prCounts);
      renderSparkline(elements[\"cycle-p50-sparkline\"], sparklineData.p50s);
      renderSparkline(elements[\"cycle-p90-sparkline\"], sparklineData.p90s);
      renderSparkline(elements[\"authors-sparkline\"], sparklineData.authors);
      renderSparkline(elements[\"reviewers-sparkline\"], sparklineData.reviewers);┬╖
      // Render deltas (only if we have previous period data)
      if (prevRollups && prevRollups.length > 0) {
        renderDelta(
          elements[\"total-prs-delta\"],
          calculatePercentChange(current.totalPrs, previous.totalPrs),
          false,
        );
        renderDelta(
          elements[\"cycle-p50-delta\"],
          calculatePercentChange(current.cycleP50, previous.cycleP50),
          true,
        ); // Inverse: lower is better
        renderDelta(
          elements[\"cycle-p90-delta\"],
          calculatePercentChange(current.cycleP90, previous.cycleP90),
          true,
        ); // Inverse: lower is better
        renderDelta(
          elements[\"authors-delta\"],
          calculatePercentChange(current.avgAuthors, previous.avgAuthors),
          false,
        );
        renderDelta(
          elements[\"reviewers-delta\"],
          calculatePercentChange(current.avgReviewers, previous.avgReviewers),
          false,
        );
      } else {
        // Clear deltas if no previous data
        [
          \"total-prs-delta\",
          \"cycle-p50-delta\",
          \"cycle-p90-delta\",
          \"authors-delta\",
          \"reviewers-delta\",
        ].forEach((id) => {
          const el = elements[id];
          if (el) {
            el.innerHTML = \"\";
            el.className = \"metric-delta\";
          }
        });
      }┬╖
      if (metricsCollector) {
        metricsCollector.mark(\"render-summary-cards-end\");
        metricsCollector.mark(\"first-meaningful-paint\");
        metricsCollector.measure(
          \"init-to-fmp\",
          \"dashboard-init\",
          \"first-meaningful-paint\",
        );
      }
    }┬╖
    /**
     * Calculate moving average for trend line.
     */
    function calculateMovingAverage(
      values: number[],
      window = 4,
    ): (number | null)[] {
      const result: (number | null)[] = [];
      for (let i = 0; i < values.length; i++) {
        if (i < window - 1) {
          result.push(null);
        } else {
          const sum = values
            .slice(i - window + 1, i + 1)
            .reduce((a, b) => a + b, 0);
          result.push(sum / window);
        }
      }
      return result;
    }┬╖
    /**
     * Render throughput chart with trend line overlay.
     */
    function renderThroughputChart(rollups: Rollup[]): void {
      const chartEl = elements[\"throughput-chart\"];
      if (!chartEl) return;┬╖
      if (!rollups || !rollups.length) {
        chartEl.innerHTML = '<p class=\"no-data\">No data for selected range</p>';
        return;
      }┬╖
      const prCounts = rollups.map((r) => r.pr_count || 0);
      const maxCount = Math.max(...prCounts);
      const movingAvg = calculateMovingAverage(prCounts, 4);┬╖
      // Render bar chart
      const barsHtml = rollups
        .map((r) => {
          const height = maxCount > 0 ? ((r.pr_count || 0) / maxCount) * 100 : 0;
          return `
                <div class=\"bar-container\" title=\"${r.week}: ${r.pr_count || 0} PRs\">
                    <div class=\"bar\" style=\"height: ${height}%\"></div>
                    <div class=\"bar-label\">${r.week.split(\"-W\")[1]}</div>
                </div>
            `;
        })
        .join(\"\");┬╖
      // Render trend line SVG overlay
      let trendLineHtml = \"\";
      if (rollups.length >= 4) {
        const validPoints = movingAvg
          .map((val, i) => ({ val, i }))
          .filter((p): p is { val: number; i: number } => p.val !== null);┬╖
        if (validPoints.length >= 2) {
          const chartHeight = 200;
          const chartPadding = 8;┬╖
          // Calculate SVG path points
          const points = validPoints.map((p) => {
            const x = (p.i / (rollups.length - 1)) * 100;
            const y =
              maxCount > 0
                ? chartHeight -
                  chartPadding -
                  (p.val / maxCount) * (chartHeight - chartPadding * 2)
                : chartHeight / 2;
            return { x, y };
          });┬╖
          const pathD = points
            .map(
              (pt, i) =>
                `${i === 0 ? \"M\" : \"L\"} ${pt.x.toFixed(1)}% ${pt.y.toFixed(1)}`,
            )
            .join(\" \");┬╖
          trendLineHtml = `
                    <div class=\"trend-line-overlay\">
                        <svg viewBox=\"0 0 100 ${chartHeight}\" preserveAspectRatio=\"none\">
                            <path class=\"trend-line\" d=\"${pathD}\" vector-effect=\"non-scaling-stroke\"/>
                        </svg>
                    </div>
                `;
        }
      }┬╖
      // Legend
      const legendHtml = `
            <div class=\"chart-legend\">
                <div class=\"legend-item\">
                    <span class=\"legend-bar\"></span>
                    <span>Weekly PRs</span>
                </div>
                <div class=\"legend-item\">
                    <span class=\"legend-line\"></span>
                    <span>4-week avg</span>
                </div>
            </div>
        `;┬╖
      chartEl.innerHTML = `
            <div class=\"chart-with-trend\">
                <div class=\"bar-chart\">${barsHtml}</div>
                ${trendLineHtml}
            </div>
            ${legendHtml}
        `;
    }┬╖
    /**
     * Render cycle time distribution.
     */
    function renderCycleDistribution(distributions: any[]): void {
      const distEl = elements[\"cycle-distribution\"];
      if (!distEl) return;┬╖
      if (!distributions || !distributions.length) {
        distEl.innerHTML = '<p class=\"no-data\">No data for selected range</p>';
        return;
      }┬╖
      const buckets: Record<string, number> = {
        \"0-1h\": 0,
        \"1-4h\": 0,
        \"4-24h\": 0,
        \"1-3d\": 0,
        \"3-7d\": 0,
        \"7d+\": 0,
      };
      distributions.forEach((d) => {
        Object.entries(d.cycle_time_buckets || {}).forEach(([key, val]) => {
          buckets[key] = (buckets[key] || 0) + (val as number);
        });
      });┬╖
      const total = Object.values(buckets).reduce((a, b) => a + b, 0);
      if (total === 0) {
        distEl.innerHTML = '<p class=\"no-data\">No cycle time data</p>';
        return;
      }┬╖
      const html = Object.entries(buckets)
        .map(([label, count]) => {
          const pct = ((count / total) * 100).toFixed(1);
          return `
                <div class=\"dist-row\">
                    <span class=\"dist-label\">${label}</span>
                    <div class=\"dist-bar-bg\">
                        <div class=\"dist-bar\" style=\"width: ${pct}%\"></div>
                    </div>
                    <span class=\"dist-value\">${count} (${pct}%)</span>
                </div>
            `;
        })
        .join(\"\");┬╖
      distEl.innerHTML = html;
    }┬╖
    /**
     * Render cycle time trend chart (line chart with P50 and P90).
     */
    function renderCycleTimeTrend(rollups: Rollup[]): void {
      const trendEl = elements[\"cycle-time-trend\"];
      if (!trendEl) return;┬╖
      if (!rollups || rollups.length < 2) {
        trendEl.innerHTML = '<p class=\"no-data\">Not enough data for trend</p>';
        return;
      }┬╖
      const p50Data = rollups
        .map((r) => ({ week: r.week, value: r.cycle_time_p50 }))
        .filter((d): d is { week: string; value: number } => d.value !== null);
      const p90Data = rollups
        .map((r) => ({ week: r.week, value: r.cycle_time_p90 }))
        .filter((d): d is { week: string; value: number } => d.value !== null);┬╖
      if (p50Data.length < 2 && p90Data.length < 2) {
        trendEl.innerHTML = '<p class=\"no-data\">No cycle time data available</p>';
        return;
      }┬╖
      const allValues = [
        ...p50Data.map((d) => d.value),
        ...p90Data.map((d) => d.value),
      ];
      const maxVal = Math.max(...allValues);
      const minVal = Math.min(...allValues);
      const range = maxVal - minVal || 1;┬╖
      const width = 100;
      const height = 180;
      const padding = { top: 10, right: 10, bottom: 25, left: 40 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;┬╖
      // Generate paths
      const generatePath = (data: { week: string; value: number }[]) => {
        const points = data.map((d) => {
          const dataIndex = rollups.findIndex((r) => r.week === d.week);
          const x = padding.left + (dataIndex / (rollups.length - 1)) * chartWidth;
          const y =
            padding.top + chartHeight - ((d.value - minVal) / range) * chartHeight;
          return { x, y, week: d.week, value: d.value };
        });
        const pathD = points
          .map(
            (p, i) => `${i === 0 ? \"M\" : \"L\"} ${p.x.toFixed(1)} ${p.y.toFixed(1)}`,
          )
          .join(\" \");
        return { pathD, points };
      };┬╖
      const p50Path = p50Data.length >= 2 ? generatePath(p50Data) : null;
      const p90Path = p90Data.length >= 2 ? generatePath(p90Data) : null;┬╖
      // Y-axis labels
      const yLabels = [minVal, (minVal + maxVal) / 2, maxVal];┬╖
      const svgContent = `
            <svg viewBox=\"0 0 ${width} ${height}\" preserveAspectRatio=\"xMidYMid meet\">
                <!-- Grid lines -->
                ${yLabels
                  .map((val, i) => {
                    const y =
                      padding.top +
                      chartHeight -
                      (i / (yLabels.length - 1)) * chartHeight;
                    return `<line class=\"line-chart-grid\" x1=\"${padding.left}\" y1=\"${y}\" x2=\"${width - padding.right}\" y2=\"${y}\"/>`;
                  })
                  .join(\"\")}┬╖
                <!-- Y-axis labels -->
                ${yLabels
                  .map((val, i) => {
                    const y =
                      padding.top +
                      chartHeight -
                      (i / (yLabels.length - 1)) * chartHeight;
                    return `<text class=\"line-chart-axis\" x=\"${padding.left - 4}\" y=\"${y + 3}\" text-anchor=\"end\">${formatDuration(val)}</text>`;
                  })
                  .join(\"\")}┬╖
                <!-- Lines -->
                ${p90Path ? `<path class=\"line-chart-p90\" d=\"${p90Path.pathD}\" vector-effect=\"non-scaling-stroke\"/>` : \"\"}
                ${p50Path ? `<path class=\"line-chart-p50\" d=\"${p50Path.pathD}\" vector-effect=\"non-scaling-stroke\"/>` : \"\"}┬╖
                <!-- Dots -->
                ${p90Path ? p90Path.points.map((p) => `<circle class=\"line-chart-dot\" cx=\"${p.x}\" cy=\"${p.y}\" r=\"3\" fill=\"var(--warning)\" data-week=\"${p.week}\" data-value=\"${p.value}\" data-metric=\"P90\"/>`).join(\"\") : \"\"}
                ${p50Path ? p50Path.points.map((p) => `<circle class=\"line-chart-dot\" cx=\"${p.x}\" cy=\"${p.y}\" r=\"3\" fill=\"var(--primary)\" data-week=\"${p.week}\" data-value=\"${p.value}\" data-metric=\"P50\"/>`).join(\"\") : \"\"}
            </svg>
        `;┬╖
      const legendHtml = `
            <div class=\"chart-legend\">
                <div class=\"legend-item\">
                    <span class=\"chart-tooltip-dot legend-p50\"></span>
                    <span>P50 (Median)</span>
                </div>
                <div class=\"legend-item\">
                    <span class=\"chart-tooltip-dot legend-p90\"></span>
                    <span>P90</span>
                </div>
            </div>
        `;┬╖
      trendEl.innerHTML = `<div class=\"line-chart\">${svgContent}</div>${legendHtml}`;┬╖
      // Add tooltip interactions
      addChartTooltips(trendEl, (dot: HTMLElement) => {
        const week = dot.dataset[\"week\"];
        const value = parseFloat(dot.dataset[\"value\"] || \"0\");
        const metric = dot.dataset[\"metric\"];
        return `
                <div class=\"chart-tooltip-title\">${week}</div>
                <div class=\"chart-tooltip-row\">
                    <span class=\"chart-tooltip-label\">
                        <span class=\"chart-tooltip-dot ${metric === \"P50\" ? \"legend-p50\" : \"legend-p90\"}\"></span>
                        ${metric}
                    </span>
                    <span>${formatDuration(value)}</span>
                </div>
            `;
      });
    }┬╖
    /**
     * Render reviewer activity chart (horizontal bar chart).
     */
    function renderReviewerActivity(rollups: Rollup[]): void {
      const revEl = elements[\"reviewer-activity\"];
      if (!revEl) return;┬╖
      if (!rollups || !rollups.length) {
        revEl.innerHTML = '<p class=\"no-data\">No reviewer data available</p>';
        return;
      }┬╖
      // Take last 8 weeks for display
      const recentRollups = rollups.slice(-8);
      const maxReviewers = Math.max(
        ...recentRollups.map((r) => r.reviewers_count || 0),
      );┬╖
      if (maxReviewers === 0) {
        revEl.innerHTML = '<p class=\"no-data\">No reviewer data available</p>';
        return;
      }┬╖
      const barsHtml = recentRollups
        .map((r) => {
          const count = r.reviewers_count || 0;
          const pct = (count / maxReviewers) * 100;
          const weekLabel = r.week.split(\"-W\")[1];
          return `
                <div class=\"h-bar-row\" title=\"${r.week}: ${count} reviewers\">
                    <span class=\"h-bar-label\">W${weekLabel}</span>
                    <div class=\"h-bar-container\">
                        <div class=\"h-bar\" style=\"width: ${pct}%\"></div>
                    </div>
                    <span class=\"h-bar-value\">${count}</span>
                </div>
            `;
        })
        .join(\"\");┬╖
      revEl.innerHTML = `<div class=\"horizontal-bar-chart\">${barsHtml}</div>`;
    }┬╖
    /**
     * Add tooltip interactions to a chart.
     */
    function addChartTooltips(
      container: HTMLElement,
      contentFn: (dot: HTMLElement) => string,
    ): void {
      const dots = container.querySelectorAll(\".line-chart-dot\");
      let tooltip: HTMLElement | null = null;┬╖
      dots.forEach((dotNode) => {
        const dot = dotNode as HTMLElement;
        dot.addEventListener(\"mouseenter\", () => {
          if (!tooltip) {
            tooltip = document.createElement(\"div\");
            tooltip.className = \"chart-tooltip\";
            container.appendChild(tooltip);
          }
          tooltip.innerHTML = contentFn(dot);
          tooltip.style.display = \"block\";┬╖
          // Position tooltip
          const rect = container.getBoundingClientRect();
          const dotRect = dot.getBoundingClientRect();
          tooltip.style.left = `${dotRect.left - rect.left + 10}px`;
          tooltip.style.top = `${dotRect.top - rect.top - 40}px`;
        });┬╖
        dot.addEventListener(\"mouseleave\", () => {
          if (tooltip) {
            tooltip.style.display = \"none\";
          }
        });
      });
    }┬╖
    /**
     * Update feature tabs based on manifest.
     */
    async function updateFeatureTabs(): Promise<void> {
      if (!loader) return;┬╖
      // Check if loader supports loadPredictions/loadInsights
      if (typeof (loader as any).loadPredictions !== \"function\") return;┬╖
      const predictionsContent = document.getElementById(\"tab-predictions\");
      const predictionsUnavailable = document.getElementById(
        \"predictions-unavailable\",
      );
      if (predictionsContent) {
        const predictionsResult = await (loader as any).loadPredictions();┬╖
        if (
          predictionsResult?.state === \"ok\" &&
          predictionsResult.data?.forecasts?.length > 0
        ) {
          renderPredictions(predictionsContent, predictionsResult.data);
        } else if (predictionsUnavailable) {
          predictionsUnavailable.classList.remove(\"hidden\");
        }
      }┬╖
      const aiContent = document.getElementById(\"tab-ai-insights\");
      const aiUnavailable = document.getElementById(\"ai-unavailable\");
      if (aiContent) {
        const insightsResult = await (loader as any).loadInsights();┬╖
        if (
          insightsResult?.state === \"ok\" &&
          insightsResult.data?.insights?.length > 0
        ) {
          renderAIInsights(aiContent, insightsResult.data);
        } else if (aiUnavailable) {
          aiUnavailable.classList.remove(\"hidden\");
        }
      }
    }┬╖
    /**
     * Render predictions.
     */
    function renderPredictions(container: HTMLElement, predictions: any): void {
      const content = document.createElement(\"div\");
      content.className = \"predictions-content\";┬╖
      if (predictions.is_stub) {
        content.innerHTML += `<div class=\"stub-warning\">ΓÜá∩╕Å Demo data</div>`;
      }┬╖
      predictions.forecasts.forEach((forecast: any) => {
        const label = forecast.metric
          .replace(/_/g, \" \")
          .replace(/\\b\\w/g, (c: string) => c.toUpperCase());
        content.innerHTML += `
                <div class=\"forecast-section\">
                    <h4>${label} (${forecast.unit})</h4>
                    <table class=\"forecast-table\">
                        <thead><tr><th>Week</th><th>Predicted</th><th>Range</th></tr></thead>
                        <tbody>
                            ${forecast.values
                              .map(
                                (v: any) => `
                                <tr>
                                    <td>${v.period_start}</td>
                                    <td>${v.predicted}</td>
                                    <td>${v.lower_bound} - ${v.upper_bound}</td>
                                </tr>
                            `,
                              )
                              .join(\"\")}
                        </tbody>
                    </table>
                </div>
            `;
      });┬╖
      const unavailable = container.querySelector(\".feature-unavailable\");
      if (unavailable) unavailable.classList.add(\"hidden\");
      container.appendChild(content);
    }┬╖
    /**
     * Render AI insights.
     */
    function renderAIInsights(container: HTMLElement, insights: any): void {
      const content = document.createElement(\"div\");
      content.className = \"insights-content\";┬╖
      if (insights.is_stub) {
        content.innerHTML += `<div class=\"stub-warning\">ΓÜá∩╕Å Demo data</div>`;
      }┬╖
      const icons: Record<string, string> = {
        critical: \"≡ƒö┤\",
        warning: \"≡ƒƒí\",
        info: \"≡ƒö╡\",
      };
      [\"critical\", \"warning\", \"info\"].forEach((severity) => {
        const items = insights.insights.filter((i: any) => i.severity === severity);
        if (!items.length) return;┬╖
        content.innerHTML += `
                <div class=\"severity-section\">
                    <h4>${icons[severity]} ${severity.charAt(0).toUpperCase() + severity.slice(1)}</h4>
                    <div class=\"insight-cards\">
                        ${items
                          .map(
                            (i: any) => `
                            <div class=\"insight-card ${i.severity}\">
                                <div class=\"insight-category\">${i.category}</div>
                                <h5>${i.title}</h5>
                                <p>${i.description}</p>
                            </div>
                        `,
                          )
                          .join(\"\")}
                    </div>
                </div>
            `;
      });┬╖
      const unavailable = container.querySelector(\".feature-unavailable\");
      if (unavailable) unavailable.classList.add(\"hidden\");
      container.appendChild(content);
    }┬╖
    // ============================================================================
    // Event Handlers
    // ============================================================================┬╖
    function handleDateRangeChange(e: Event): void {
      const target = e.target as HTMLSelectElement;
      const value = target.value;┬╖
      if (value === \"custom\") {
        elements[\"custom-dates\"]?.classList.remove(\"hidden\");
        return;
      }┬╖
      elements[\"custom-dates\"]?.classList.add(\"hidden\");┬╖
      const days = parseInt(value, 10);
      const coverage = loader?.getCoverage() || null;
      const endDate = coverage?.date_range?.max
        ? new Date(coverage.date_range.max)
        : new Date();
      const startDate = new Date(endDate);
      startDate.setDate(startDate.getDate() - days);┬╖
      currentDateRange = { start: startDate, end: endDate };
      updateUrlState();
      refreshMetrics();
    }┬╖
    function applyCustomDates(): void {
      const start = (elements[\"start-date\"] as HTMLInputElement)?.value;
      const end = (elements[\"end-date\"] as HTMLInputElement)?.value;┬╖
      if (!start || !end) return;┬╖
      currentDateRange = { start: new Date(start), end: new Date(end) };
      updateUrlState();
      refreshMetrics();
    }┬╖
    function switchTab(tabId: string): void {
      elements.tabs?.forEach((tab: HTMLElement) => {
        tab.classList.toggle(\"active\", tab.dataset[\"tab\"] === tabId);
      });┬╖
      document.querySelectorAll(\".tab-content\").forEach((content) => {
        content.classList.toggle(\"active\", content.id === `tab-${tabId}`);
        content.classList.toggle(\"hidden\", content.id !== `tab-${tabId}`);
      });┬╖
      updateUrlState();
    }┬╖
    // ============================================================================
    // Filter Management
    // ============================================================================┬╖
    /**
     * Populate filter dropdowns from loaded dimensions.
     */
    function populateFilterDropdowns(dimensions: any): void {
      if (!dimensions) return;┬╖
      // Populate repository filter
      const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
      if (repoFilter && dimensions.repositories?.length > 0) {
        repoFilter.innerHTML = '<option value=\"\">All</option>';
        dimensions.repositories.forEach((repo: any) => {
          const option = document.createElement(\"option\");
          option.value = repo.id || repo.name;
          option.textContent = repo.name;
          repoFilter.appendChild(option);
        });
        elements[\"repo-filter-group\"]?.classList.remove(\"hidden\");
      } else {
        elements[\"repo-filter-group\"]?.classList.add(\"hidden\");
      }┬╖
      // Populate team filter
      const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
      if (teamFilter && dimensions.teams?.length > 0) {
        teamFilter.innerHTML = '<option value=\"\">All</option>';
        dimensions.teams.forEach((team: any) => {
          const option = document.createElement(\"option\");
          option.value = team.id || team.name;
          option.textContent = team.name;
          teamFilter.appendChild(option);
        });
        elements[\"team-filter-group\"]?.classList.remove(\"hidden\");
      } else {
        elements[\"team-filter-group\"]?.classList.add(\"hidden\");
      }┬╖
      // Restore filter state from URL
      restoreFiltersFromUrl();
    }┬╖
    /**
     * Handle filter dropdown change.
     */
    function handleFilterChange(): void {
      const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
      const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;┬╖
      const repoValues = repoFilter
        ? Array.from(repoFilter.selectedOptions)
            .map((o) => o.value)
            .filter((v) => v)
        : [];
      const teamValues = teamFilter
        ? Array.from(teamFilter.selectedOptions)
            .map((o) => o.value)
            .filter((v) => v)
        : [];┬╖
      currentFilters = { repos: repoValues, teams: teamValues };┬╖
      updateFilterUI();
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Clear all filters.
     */
    function clearAllFilters(): void {
      currentFilters = { repos: [], teams: [] };┬╖
      const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
      const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;┬╖
      if (repoFilter) {
        Array.from(repoFilter.options).forEach(
          (o) => (o.selected = o.value === \"\"),
        );
      }
      if (teamFilter) {
        Array.from(teamFilter.options).forEach(
          (o) => (o.selected = o.value === \"\"),
        );
      }┬╖
      updateFilterUI();
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Remove a specific filter.
     */
    function removeFilter(type: string, value: string): void {
      if (type === \"repo\") {
        currentFilters.repos = currentFilters.repos.filter((v) => v !== value);
        const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
        if (repoFilter) {
          const option = repoFilter.querySelector(
            `option[value=\"${value}\"]`,
          ) as HTMLOptionElement | null;
          if (option) option.selected = false;
        }
      } else if (type === \"team\") {
        currentFilters.teams = currentFilters.teams.filter((v) => v !== value);
        const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
        if (teamFilter) {
          const option = teamFilter.querySelector(
            `option[value=\"${value}\"]`,
          ) as HTMLOptionElement | null;
          if (option) option.selected = false;
        }
      }┬╖
      updateFilterUI();
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Update filter UI.
     */
    function updateFilterUI(): void {
      const hasFilters =
        currentFilters.repos.length > 0 || currentFilters.teams.length > 0;┬╖
      if (elements[\"clear-filters\"]) {
        elements[\"clear-filters\"].classList.toggle(\"hidden\", !hasFilters);
      }┬╖
      if (elements[\"active-filters\"] && elements[\"filter-chips\"]) {
        elements[\"active-filters\"].classList.toggle(\"hidden\", !hasFilters);┬╖
        if (hasFilters) {
          renderFilterChips();
        } else {
          elements[\"filter-chips\"].innerHTML = \"\";
        }
      }
    }┬╖
    /**
     * Render filter chips for active filters.
     */
    function renderFilterChips(): void {
      const chipsEl = elements[\"filter-chips\"] as HTMLElement | null;
      if (!chipsEl) return;┬╖
      const chips: string[] = [];┬╖
      currentFilters.repos.forEach((value) => {
        const label = getFilterLabel(\"repo\", value);
        chips.push(createFilterChip(\"repo\", value, label));
      });┬╖
      currentFilters.teams.forEach((value) => {
        const label = getFilterLabel(\"team\", value);
        chips.push(createFilterChip(\"team\", value, label));
      });┬╖
      chipsEl.innerHTML = chips.join(\"\");┬╖
      chipsEl.querySelectorAll(\".filter-chip-remove\").forEach((btnNode) => {
        const btn = btnNode as HTMLElement;
        btn.addEventListener(\"click\", () => {
          const type = btn.dataset[\"type\"];
          const val = btn.dataset[\"value\"];
          if (type && val) removeFilter(type, val);
        });
      });
    }┬╖
    /**
     * Get display label for a filter value.
     */
    function getFilterLabel(type: string, value: string): string {
      if (type === \"repo\") {
        const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
        const option = repoFilter?.querySelector(`option[value=\"${value}\"]`);
        return option?.textContent || value;
      }
      if (type === \"team\") {
        const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
        const option = teamFilter?.querySelector(`option[value=\"${value}\"]`);
        return option?.textContent || value;
      }
      return value;
    }┬╖
    /**
     * Create HTML for a filter chip.
     */
    function createFilterChip(type: string, value: string, label: string): string {
      const prefix = type === \"repo\" ? \"repo\" : \"team\";
      return `
            <span class=\"filter-chip\">
                <span class=\"filter-chip-label\">${prefix}: ${label}</span>
                <span class=\"filter-chip-remove\" data-type=\"${type}\" data-value=\"${value}\">&times;</span>
            </span>
        `;
    }┬╖
    /**
     * Restore filters from URL parameters.
     */
    function restoreFiltersFromUrl(): void {
      const params = new URLSearchParams(window.location.search);┬╖
      const reposParam = params.get(\"repos\");
      const teamsParam = params.get(\"teams\");┬╖
      if (reposParam) {
        currentFilters.repos = reposParam.split(\",\").filter((v) => v);
        const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
        if (repoFilter) {
          currentFilters.repos.forEach((value) => {
            const option = repoFilter.querySelector(
              `option[value=\"${value}\"]`,
            ) as HTMLOptionElement | null;
            if (option) option.selected = true;
          });
        }
      }┬╖
      if (teamsParam) {
        currentFilters.teams = teamsParam.split(\",\").filter((v) => v);
        const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
        if (teamFilter) {
          currentFilters.teams.forEach((value) => {
            const option = teamFilter.querySelector(
              `option[value=\"${value}\"]`,
            ) as HTMLOptionElement | null;
            if (option) option.selected = true;
          });
        }
      }┬╖
      updateFilterUI();
    }┬╖
    // ============================================================================
    // Comparison Mode
    // ============================================================================┬╖
    /**
     * Toggle comparison mode on/off.
     */
    function toggleComparisonMode(): void {
      comparisonMode = !comparisonMode;┬╖
      elements[\"compare-toggle\"]?.classList.toggle(\"active\", comparisonMode);
      elements[\"comparison-banner\"]?.classList.toggle(\"hidden\", !comparisonMode);┬╖
      if (comparisonMode) {
        updateComparisonBanner();
      }┬╖
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Exit comparison mode.
     */
    function exitComparisonMode(): void {
      comparisonMode = false;
      elements[\"compare-toggle\"]?.classList.remove(\"active\");
      elements[\"comparison-banner\"]?.classList.add(\"hidden\");
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Update the comparison banner with date ranges.
     */
    function updateComparisonBanner(): void {
      if (!currentDateRange.start || !currentDateRange.end) return;┬╖
      const formatDate = (date: Date) =>
        date.toLocaleDateString(\"en-US\", {
          month: \"short\",
          day: \"numeric\",
          year: \"numeric\",
        });┬╖
      // Current period
      const currentStart = formatDate(currentDateRange.start);
      const currentEnd = formatDate(currentDateRange.end);
      if (elements[\"current-period-dates\"]) {
        elements[\"current-period-dates\"].textContent =
          `${currentStart} - ${currentEnd}`;
      }┬╖
      // Previous period
      const prevPeriod = getPreviousPeriod(
        currentDateRange.start,
        currentDateRange.end,
      );
      const prevStart = formatDate(prevPeriod.start);
      const prevEnd = formatDate(prevPeriod.end);
      if (elements[\"previous-period-dates\"]) {
        elements[\"previous-period-dates\"].textContent = `${prevStart} - ${prevEnd}`;
      }
    }┬╖
    // ============================================================================
    // Export Functions
    // ============================================================================┬╖
    /**
     * Toggle export menu visibility.
     */
    function toggleExportMenu(e: Event): void {
      e.stopPropagation();
      elements[\"export-menu\"]?.classList.toggle(\"hidden\");
    }┬╖
    /**
     * Export current data to CSV.
     */
    function exportToCsv(): void {
      elements[\"export-menu\"]?.classList.add(\"hidden\");┬╖
      if (!cachedRollups || cachedRollups.length === 0) {
        showToast(\"No data to export\", \"error\");
        return;
      }┬╖
      // Build CSV content
      const headers = [
        \"Week\",
        \"Start Date\",
        \"End Date\",
        \"PR Count\",
        \"Cycle Time P50 (min)\",
        \"Cycle Time P90 (min)\",
        \"Authors\",
        \"Reviewers\",
      ];
      const rows = cachedRollups.map((r) => [
        r.week,
        r.start_date || \"\",
        r.end_date || \"\",
        r.pr_count || 0,
        r.cycle_time_p50 != null ? r.cycle_time_p50.toFixed(1) : \"\",
        r.cycle_time_p90 != null ? r.cycle_time_p90.toFixed(1) : \"\",
        r.authors_count || 0,
        r.reviewers_count || 0,
      ]);┬╖
      const csvContent = [headers, ...rows]
        .map((row) => row.map((cell) => `\"${cell}\"`).join(\",\"))
        .join(\"\\n\");┬╖
      // Download file
      const blob = new Blob([csvContent], { type: \"text/csv;charset=utf-8;\" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement(\"a\");
      link.href = url;┬╖
      const dateStr = new Date().toISOString().split(\"T\")[0];
      link.download = `pr-insights-${dateStr}.csv`;┬╖
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);┬╖
      showToast(\"CSV exported successfully\", \"success\");
    }┬╖
    /**
     * Copy shareable link to clipboard.
     */
    async function copyShareableLink(): Promise<void> {
      elements[\"export-menu\"]?.classList.add(\"hidden\");┬╖
      try {
        await navigator.clipboard.writeText(window.location.href);
        showToast(\"Link copied to clipboard\", \"success\");
      } catch (_err) {
        // Fallback
        const textArea = document.createElement(\"textarea\");
        textArea.value = window.location.href;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand(\"copy\");
        document.body.removeChild(textArea);
        showToast(\"Link copied to clipboard\", \"success\");
      }
    }┬╖
    /**
     * Download raw CSV data as a ZIP file.
     */
    async function downloadRawDataZip(): Promise<void> {
      elements[\"export-menu\"]?.classList.add(\"hidden\");┬╖
      if (!currentBuildId || !artifactClient) {
        showToast(\"Raw data not available in direct URL mode\", \"error\");
        return;
      }┬╖
      try {
        showToast(\"Preparing download...\", \"success\");┬╖
        const artifact = await artifactClient.getArtifactMetadata(
          currentBuildId,
          \"csv-output\",
        );┬╖
        if (!artifact) {
          showToast(\"Raw CSV artifact not found in this pipeline run\", \"error\");
          return;
        }┬╖
        const downloadUrl = artifact.resource?.downloadUrl;
        if (!downloadUrl) {
          showToast(\"Download URL not available\", \"error\");
          return;
        }┬╖
        let zipUrl = downloadUrl;
        if (!zipUrl.includes(\"format=zip\")) {
          const separator = zipUrl.includes(\"?\") ? \"&\" : \"?\";
          zipUrl = `${zipUrl}${separator}format=zip`;
        }┬╖
        // Use the protected method from ArtifactClient
        const response = await (artifactClient as any)._authenticatedFetch(zipUrl);┬╖
        if (!response.ok) {
          if (response.status === 403 || response.status === 401) {
            showToast(\"Permission denied to download artifacts\", \"error\");
          } else {
            showToast(`Download failed: ${response.statusText}`, \"error\");
          }
          return;
        }┬╖
        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        const link = document.createElement(\"a\");
        link.href = url;┬╖
        const dateStr = new Date().toISOString().split(\"T\")[0];
        link.download = `pr-insights-raw-data-${dateStr}.zip`;┬╖
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);┬╖
        showToast(\"Download started\", \"success\");
      } catch (err) {
        console.error(\"Failed to download raw data:\", err);
        showToast(\"Failed to download raw data\", \"error\");
      }
    }┬╖
    /**
     * Show a toast notification.
     */
    function showToast(
      message: string,
      type: \"success\" | \"error\" = \"success\",
    ): void {
      const toast = document.createElement(\"div\");
      toast.className = `toast ${type}`;
      toast.textContent = message;
      document.body.appendChild(toast);┬╖
      setTimeout(() => {
        toast.remove();
      }, 3000);
    }┬╖
    // ============================================================================
    // Utility Functions
    // ============================================================================┬╖
    function showLoading(): void {
      hideAllPanels();
      elements[\"loading-state\"]?.classList.remove(\"hidden\");
    }┬╖
    function showContent(): void {
      hideAllPanels();
      elements[\"main-content\"]?.classList.remove(\"hidden\");
    }┬╖
    function updateDatasetInfo(manifest: any): void {
      const generatedAt = manifest?.generated_at
        ? new Date(manifest.generated_at).toLocaleString()
        : \"Unknown\";
      const runId = manifest?.run_id || \"\";┬╖
      const runInfo = elements[\"run-info\"];
      if (runInfo) {
        runInfo.textContent = `Generated: ${generatedAt}`;
        if (runId) runInfo.textContent += ` | Run: ${runId.slice(0, 8)}`;
      }
    }┬╖
    function formatDuration(minutes: number): string {
      if (minutes < 60) return `${Math.round(minutes)}m`;
      if (minutes < 1440) return `${(minutes / 60).toFixed(1)}h`;
      return `${(minutes / 1440).toFixed(1)}d`;
    }┬╖
    function median(arr: number[]): number {
      const sorted = [...arr].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      return sorted.length % 2
        ? sorted[mid]!
        : (sorted[mid - 1]! + sorted[mid]!) / 2;
    }┬╖
    function updateUrlState(): void {
      const params = new URLSearchParams(window.location.search);
      const newParams = new URLSearchParams();┬╖
      // Preserve config params
      if (params.get(\"dataset\")) newParams.set(\"dataset\", params.get(\"dataset\")!);
      if (params.get(\"pipelineId\"))
        newParams.set(\"pipelineId\", params.get(\"pipelineId\")!);┬╖
      // Add date range
      if (currentDateRange.start) {
        newParams.set(\"start\", currentDateRange.start.toISOString().split(\"T\")[0]!);
      }
      if (currentDateRange.end) {
        newParams.set(\"end\", currentDateRange.end.toISOString().split(\"T\")[0]!);
      }┬╖
      // Add active tab
      const activeTab = document.querySelector(\".tab.active\") as HTMLElement | null;
      if (activeTab && activeTab.dataset[\"tab\"] !== \"metrics\") {
        newParams.set(\"tab\", activeTab.dataset[\"tab\"]!);
      }┬╖
      // Add filters
      if (currentFilters.repos.length > 0) {
        newParams.set(\"repos\", currentFilters.repos.join(\",\"));
      }
      if (currentFilters.teams.length > 0) {
        newParams.set(\"teams\", currentFilters.teams.join(\",\"));
      }┬╖
      // Add comparison mode
      if (comparisonMode) {
        newParams.set(\"compare\", \"1\");
      }┬╖
      window.history.replaceState(
        {},
        \"\",
        `${window.location.pathname}?${newParams.toString()}`,
      );
    }┬╖
    function restoreStateFromUrl(): void {
      const params = new URLSearchParams(window.location.search);┬╖
      const startParam = params.get(\"start\");
      const endParam = params.get(\"end\");
      if (startParam && endParam) {
        currentDateRange = { start: new Date(startParam), end: new Date(endParam) };
        const dateRangeEl = elements[\"date-range\"] as HTMLSelectElement | null;
        if (dateRangeEl) {
          dateRangeEl.value = \"custom\";
          elements[\"custom-dates\"]?.classList.remove(\"hidden\");
        }
        if (elements[\"start-date\"]) elements[\"start-date\"].value = startParam;
        if (elements[\"end-date\"]) elements[\"end-date\"].value = endParam;
      }┬╖
      const tabParam = params.get(\"tab\");
      if (tabParam) {
        setTimeout(() => switchTab(tabParam), 0);
      }┬╖
      // Restore comparison mode
      const compareParam = params.get(\"compare\");
      if (compareParam === \"1\") {
        comparisonMode = true;
        elements[\"compare-toggle\"]?.classList.add(\"active\");
        elements[\"comparison-banner\"]?.classList.remove(\"hidden\");
      }
    }┬╖
    // ============================================================================
    // Initialize
    // ============================================================================┬╖
    if (document.readyState === \"loading\") {
      document.addEventListener(\"DOMContentLoaded\", init);
    } else {
      init();
    }
    "

      19 |
      20 |     it("should have SETTINGS_KEY_PROJECT constant", () => {
    > 21 |       expect(dashboardCode).toContain(
         |                             ^
      22 |         "SETTINGS_KEY_PROJECT = 'pr-insights-source-project'",
      23 |       );
      24 |     });

      at Object.<anonymous> (tests/cross-project-settings.test.ts:21:29)

  ΓùÅ Cross-Project Settings ΓÇ║ dashboard.ts configuration ΓÇ║ should have SETTINGS_KEY_PIPELINE constant

    expect(received).toContain(expected) // indexOf

    Expected substring: "SETTINGS_KEY_PIPELINE = 'pr-insights-pipeline-id'"
    Received string:    "/**
     * PR Insights Dashboard
     *
     * Project-level hub that loads data from pipeline artifacts.
     * Uses Azure DevOps Extension SDK for authentication.
     *
     * Configuration precedence:
     * 1. ?dataset=<url> - Direct URL (DEV ONLY)
     * 2. ?pipelineId=<id> - Query parameter override
     * 3. Extension settings - User-scoped saved preference
     * 4. Auto-discovery - Find pipelines with 'aggregates' artifact
     */┬╖
    import { DatasetLoader, IDatasetLoader, Rollup } from \"./dataset-loader\";
    import { ArtifactClient } from \"./artifact-client\";
    import {
      PrInsightsError,
      ErrorTypes,
      createSetupRequiredError,
      createNoSuccessfulBuildsError,
      createArtifactsMissingError,
      createInvalidConfigError,
      SetupRequiredDetails,
      MultiplePipelinesDetails,
      ArtifactsMissingDetails,
    } from \"./error-types\";┬╖
    // Dashboard state
    let loader: IDatasetLoader | null = null;
    let artifactClient: ArtifactClient | null = null;
    let currentDateRange: { start: Date | null; end: Date | null } = {
      start: null,
      end: null,
    };
    let currentFilters: { repos: string[]; teams: string[] } = {
      repos: [],
      teams: [],
    };
    let comparisonMode = false;
    let cachedRollups: Rollup[] = []; // Cache for export
    let currentBuildId: number | null = null; // Store build ID for raw data download
    let sdkInitialized = false;┬╖
    // Settings keys for extension data storage (must match settings.js)
    const SETTINGS_KEY_PROJECT = \"pr-insights-source-project\";
    const SETTINGS_KEY_PIPELINE = \"pr-insights-pipeline-id\";┬╖
    // Feature flags
    const ENABLE_PHASE5_FEATURES = true;┬╖
    // DOM element cache
    const elements: Record<string, any> = {};┬╖
    /**
     * Phase 4: Production-safe metrics collector
     */
    const IS_PRODUCTION =
      typeof window !== \"undefined\" &&
      (window as any).process?.env?.NODE_ENV === \"production\";
    const DEBUG_ENABLED =
      !IS_PRODUCTION &&
      ((typeof window !== \"undefined\" && (window as any).__DASHBOARD_DEBUG__) ||
        (typeof window !== \"undefined\" &&
          new URLSearchParams(window.location.search).has(\"debug\")));┬╖
    interface PerformanceMetric {
      name: string;
      duration: number;
      timestamp: number;
    }┬╖
    const metricsCollector = DEBUG_ENABLED
      ? {
          marks: new Map<string, number>(),
          measures: [] as PerformanceMetric[],
          mark(name: string) {
            if (!performance || !performance.mark) return;
            try {
              performance.mark(name);
              this.marks.set(name, performance.now());
            } catch (_e) {
              /* ignore */
            }
          },
          measure(name: string, startMark: string, endMark: string) {
            if (!performance || !performance.measure) return;
            try {
              performance.measure(name, startMark, endMark);
              const entries = performance.getEntriesByName(name, \"measure\");
              if (entries.length > 0) {
                const lastEntry = entries[entries.length - 1];
                if (lastEntry) {
                  this.measures.push({
                    name,
                    duration: lastEntry.duration,
                    timestamp: Date.now(),
                  });
                }
              }
            } catch (_e) {
              /* ignore */
            }
          },
          getMetrics() {
            return {
              marks: Array.from(this.marks.entries()).map(([name, time]) => ({
                name,
                time,
              })),
              measures: [...this.measures],
            };
          },
          reset() {
            this.marks.clear();
            this.measures = [];
            if (performance && performance.clearMarks) performance.clearMarks();
            if (performance && performance.clearMeasures)
              performance.clearMeasures();
          },
        }
      : null;┬╖
    if (DEBUG_ENABLED && typeof window !== \"undefined\") {
      (window as any).__dashboardMetrics = metricsCollector;
    }┬╖
    // ============================================================================
    // SDK Initialization
    // ============================================================================┬╖
    /**
     * Initialize Azure DevOps Extension SDK.
     */
    async function initializeAdoSdk(): Promise<void> {
      if (sdkInitialized) return;┬╖
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error(\"Azure DevOps SDK initialization timed out\"));
        }, 10000);┬╖
        VSS.init({
          explicitNotifyLoaded: true,
          usePlatformScripts: true,
          usePlatformStyles: true,
        });┬╖
        VSS.ready(() => {
          clearTimeout(timeout);
          sdkInitialized = true;┬╖
          // Update project name in UI
          const webContext = VSS.getWebContext();
          const projectNameEl = document.getElementById(\"current-project-name\");
          if (projectNameEl && webContext?.project?.name) {
            projectNameEl.textContent = webContext.project.name;
          }┬╖
          VSS.notifyLoadSucceeded();
          resolve();
        });
      });
    }┬╖
    // ============================================================================
    // Configuration Resolution
    // ============================================================================┬╖
    /**
     * Parse and validate query parameters.
     */
    function parseQueryParams():
      | { mode: string; value: any; warning?: string | null }
      | PrInsightsError {
      const params = new URLSearchParams(window.location.search);┬╖
      const datasetUrl = params.get(\"dataset\");
      const pipelineIdStr = params.get(\"pipelineId\");┬╖
      // Check for dataset URL (highest priority)
      if (datasetUrl) {
        // Validate URL
        if (!datasetUrl.startsWith(\"https://\")) {
          return createInvalidConfigError(
            \"dataset\",
            datasetUrl,
            \"Must be a valid HTTPS URL\",
          );
        }┬╖
        // Security warning for non-ADO domains
        const IS_DEV =
          window.location.hostname === \"localhost\" || params.has(\"devMode\");┬╖
        if (!IS_DEV) {
          try {
            const urlHost = new URL(datasetUrl).hostname;
            const isAdoDomain =
              urlHost.endsWith(\"dev.azure.com\") ||
              urlHost.endsWith(\".visualstudio.com\") ||
              urlHost.endsWith(\".azure.com\");
            if (!isAdoDomain) {
              console.warn(
                `SECURITY: ?dataset= URL \"${urlHost}\" is not an Azure DevOps domain. ` +
                  `This parameter is intended for development only.`,
              );
            }
          } catch (_e) {
            return createInvalidConfigError(
              \"dataset\",
              datasetUrl,
              \"Invalid URL format\",
            );
          }
        }┬╖
        let warning: string | null = null;
        if (pipelineIdStr) {
          warning = \"Both dataset and pipelineId specified; using dataset\";
          console.warn(warning);
        }┬╖
        return { mode: \"direct\", value: datasetUrl, warning };
      }┬╖
      // Check for pipelineId
      if (pipelineIdStr) {
        const pipelineId = parseInt(pipelineIdStr, 10);
        if (isNaN(pipelineId) || pipelineId <= 0) {
          return createInvalidConfigError(
            \"pipelineId\",
            pipelineIdStr,
            \"Must be a positive integer\",
          );
        }
        return { mode: \"explicit\", value: pipelineId };
      }┬╖
      return { mode: \"discover\", value: null };
    }┬╖
    /**
     * Get source configuration from extension settings.
     */
    async function getSourceConfig(): Promise<{
      projectId: string | null;
      pipelineId: number | null;
    }> {
      const result: { projectId: string | null; pipelineId: number | null } = {
        projectId: null,
        pipelineId: null,
      };
      try {
        const dataService = await VSS.getService<IExtensionDataService>(
          VSS.ServiceIds.ExtensionData,
        );┬╖
        // Get source project ID
        const savedProjectId = await dataService.getValue<string>(
          SETTINGS_KEY_PROJECT,
          { scopeType: \"User\" },
        );
        if (
          savedProjectId &&
          typeof savedProjectId === \"string\" &&
          savedProjectId.trim()
        ) {
          result.projectId = savedProjectId.trim();
        }┬╖
        // Get pipeline definition ID
        const savedPipelineId = await dataService.getValue<number>(
          SETTINGS_KEY_PIPELINE,
          { scopeType: \"User\" },
        );
        if (
          savedPipelineId &&
          typeof savedPipelineId === \"number\" &&
          savedPipelineId > 0
        ) {
          result.pipelineId = savedPipelineId;
        }
      } catch (e) {
        console.log(\"Could not read extension settings:\", e);
      }
      return result;
    }┬╖
    /**
     * Clear stale pipeline ID setting.
     */
    async function clearStalePipelineSetting(): Promise<void> {
      try {
        const dataService = await VSS.getService<IExtensionDataService>(
          VSS.ServiceIds.ExtensionData,
        );
        await dataService.setValue(SETTINGS_KEY_PIPELINE, null, {
          scopeType: \"User\",
        });
        console.log(\"Cleared stale pipeline setting to re-enable auto-discovery\");
      } catch (e) {
        console.warn(\"Could not clear stale pipeline setting:\", e);
      }
    }┬╖
    /**
     * Resolve configuration using precedence rules.
     */
    async function resolveConfiguration(): Promise<{
      buildId?: number;
      artifactName?: string;
      directUrl?: string;
    }> {
      const queryResult = parseQueryParams();┬╖
      // Check for parsing error
      if (queryResult instanceof PrInsightsError) {
        throw queryResult;
      }┬╖
      // Mode: direct URL
      if (queryResult.mode === \"direct\") {
        return { directUrl: queryResult.value };
      }┬╖
      // Get current project context
      const webContext = VSS.getWebContext();
      const currentProjectId = webContext.project?.id;
      if (!currentProjectId) {
        throw new Error(\"No project context available\");
      }┬╖
      // Get configured source from settings
      const sourceConfig = await getSourceConfig();┬╖
      // Determine which project to use for artifact access
      const targetProjectId = sourceConfig.projectId || currentProjectId;┬╖
      console.log(
        `Source project: ${targetProjectId}${sourceConfig.projectId ? \" (from settings)\" : \" (current context)\"}`,
      );┬╖
      // Initialize artifact client with target project
      artifactClient = new ArtifactClient(targetProjectId);
      await artifactClient.initialize();┬╖
      // Mode: explicit pipelineId from query
      if (queryResult.mode === \"explicit\") {
        return await resolveFromPipelineId(queryResult.value, targetProjectId);
      }┬╖
      // Check settings for pipeline ID
      if (sourceConfig.pipelineId) {
        console.log(
          `Using pipeline definition ID from settings: ${sourceConfig.pipelineId}`,
        );
        try {
          return await resolveFromPipelineId(
            sourceConfig.pipelineId,
            targetProjectId,
          );
        } catch (error: any) {
          console.warn(
            `Saved pipeline ${sourceConfig.pipelineId} is invalid, falling back to auto-discovery:`,
            error.message,
          );
          await clearStalePipelineSetting();
        }
      }┬╖
      // Mode: discovery in target project
      return await discoverAndResolve(targetProjectId);
    }┬╖
    /**
     * Resolve artifact info from a specific pipeline ID.
     */
    async function resolveFromPipelineId(
      pipelineId: number,
      projectId: string,
    ): Promise<{ buildId: number; artifactName: string }> {
      // Get Build REST client
      const buildClient = await getBuildClient();┬╖
      // Get latest successful build
      const builds = await buildClient.getBuilds(
        projectId,
        [pipelineId],
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined, // reasonFilter
        2, // statusFilter: Completed
        6, // resultFilter: Succeeded (2) | PartiallySucceeded (4)
        undefined,
        undefined,
        1, // top
      );┬╖
      if (!builds || builds.length === 0) {
        const definitions = await buildClient.getDefinitions(
          projectId,
          undefined,
          undefined,
          undefined,
          2,
          undefined,
          undefined,
          undefined,
          [pipelineId],
        );
        const name = definitions?.[0]?.name || `ID ${pipelineId}`;
        throw createNoSuccessfulBuildsError(name);
      }┬╖
      const latestBuild = builds[0];
      if (!latestBuild) throw new Error(\"Failed to retrieve latest build\");┬╖
      // Check for aggregates artifact
      if (!artifactClient) throw new Error(\"ArtifactClient not initialized\");
      const artifacts = await artifactClient.getArtifacts(latestBuild.id);
      const hasAggregates = artifacts.some((a) => a.name === \"aggregates\");┬╖
      if (!hasAggregates) {
        const definitions = await buildClient.getDefinitions(
          projectId,
          undefined,
          undefined,
          undefined,
          2,
          undefined,
          undefined,
          undefined,
          [pipelineId],
        );
        const name = definitions?.[0]?.name || `ID ${pipelineId}`;
        throw createArtifactsMissingError(name, latestBuild.id);
      }┬╖
      return { buildId: latestBuild.id, artifactName: \"aggregates\" };
    }┬╖
    /**
     * Discover pipelines with aggregates and resolve.
     */
    async function discoverAndResolve(
      projectId: string,
    ): Promise<{ buildId: number; artifactName: string }> {
      const matches = await discoverInsightsPipelines(projectId);┬╖
      if (matches.length === 0) {
        throw createSetupRequiredError();
      }┬╖
      const firstMatch = matches[0];
      if (!firstMatch) throw createSetupRequiredError();┬╖
      return { buildId: firstMatch.buildId, artifactName: \"aggregates\" };
    }┬╖
    /**
     * Discover pipelines with aggregates artifact.
     */
    async function discoverInsightsPipelines(
      projectId: string,
    ): Promise<Array<{ id: number; name: string; buildId: number }>> {
      const buildClient = await getBuildClient();
      const matches: Array<{ id: number; name: string; buildId: number }> = [];┬╖
      const definitions = await buildClient.getDefinitions(
        projectId,
        undefined,
        undefined,
        undefined,
        2,
        50,
      );┬╖
      for (const def of definitions) {
        const builds = await buildClient.getBuilds(
          projectId,
          [def.id],
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          2,
          6,
          undefined,
          undefined,
          1,
        );┬╖
        if (!builds || builds.length === 0) continue;┬╖
        const latestBuild = builds[0];
        if (!latestBuild) continue;┬╖
        try {
          if (!artifactClient) throw new Error(\"ArtifactClient not initialized\");
          const artifacts = await artifactClient.getArtifacts(latestBuild.id);
          if (!artifacts.some((a) => a.name === \"aggregates\")) continue;┬╖
          matches.push({
            id: def.id,
            name: def.name,
            buildId: latestBuild.id,
          });
        } catch (e) {
          console.debug(`Skipping pipeline ${def.name}:`, e);
        }
      }┬╖
      return matches;
    }┬╖
    /**
     * Get Build REST client from SDK.
     */
    async function getBuildClient(): Promise<IBuildRestClient> {
      return new Promise((resolve) => {
        VSS.require([\"TFS/Build/RestClient\"], (BuildRestClient: any) => {
          resolve(BuildRestClient.getClient());
        });
      });
    }┬╖
    // ============================================================================
    // Main Initialization
    // ============================================================================┬╖
    /**
     * Check if running in local dashboard mode.
     */
    function isLocalMode(): boolean {
      return (
        typeof window !== \"undefined\" &&
        (window as any).LOCAL_DASHBOARD_MODE === true
      );
    }┬╖
    /**
     * Get local dataset path from window config.
     */
    function getLocalDatasetPath(): string {
      return (
        (typeof window !== \"undefined\" && (window as any).DATASET_PATH) ||
        \"./dataset\"
      );
    }┬╖
    /**
     * Initialize the dashboard.
     */
    async function init(): Promise<void> {
      if (metricsCollector) metricsCollector.mark(\"dashboard-init\");┬╖
      cacheElements();
      setupEventListeners();
      initializePhase5Features();┬╖
      try {
        if (isLocalMode()) {
          console.log(\"[Dashboard] Running in local mode\");
          const datasetPath = getLocalDatasetPath();
          loader = new DatasetLoader(datasetPath);
          currentBuildId = null;┬╖
          const projectNameEl = document.getElementById(\"current-project-name\");
          if (projectNameEl) {
            projectNameEl.textContent = \"Local Dashboard\";
          }┬╖
          const exportRawZip = document.getElementById(\"export-raw-zip\");
          if (exportRawZip) {
            exportRawZip.style.display = \"none\";
          }┬╖
          await loadDataset();
          return;
        }┬╖
        await initializeAdoSdk();
        const config = await resolveConfiguration();┬╖
        if (config.directUrl) {
          loader = new DatasetLoader(config.directUrl);
          currentBuildId = null;
        } else if (config.buildId && config.artifactName && artifactClient) {
          loader = artifactClient.createDatasetLoader(
            config.buildId,
            config.artifactName,
          );
          currentBuildId = config.buildId;
        } else {
          throw new Error(\"Failed to resolve configuration\");
        }┬╖
        await loadDataset();
      } catch (error: any) {
        console.error(\"Dashboard initialization failed:\", error);
        handleError(error);
      }
    }┬╖
    /**
     * Handle errors with appropriate UI panels.
     */
    function handleError(error: any): void {
      hideAllPanels();┬╖
      if (error instanceof PrInsightsError) {
        switch (error.type) {
          case ErrorTypes.SETUP_REQUIRED:
            showSetupRequired(error);
            break;
          case ErrorTypes.MULTIPLE_PIPELINES:
            showMultiplePipelines(error);
            break;
          case ErrorTypes.ARTIFACTS_MISSING:
            showArtifactsMissing(error);
            break;
          case ErrorTypes.PERMISSION_DENIED:
            showPermissionDenied(error);
            break;
          default:
            showGenericError(error.title, error.message);
            break;
        }
      } else {
        showGenericError(\"Error\", error.message || \"An unexpected error occurred\");
      }
    }┬╖
    /**
     * Hide all error/setup panels.
     */
    function hideAllPanels(): void {
      [
        \"setup-required\",
        \"multiple-pipelines\",
        \"artifacts-missing\",
        \"permission-denied\",
        \"error-state\",
        \"loading-state\",
        \"main-content\",
      ].forEach((id) => {
        document.getElementById(id)?.classList.add(\"hidden\");
      });
    }┬╖
    /**
     * Show setup required panel.
     */
    function showSetupRequired(error: PrInsightsError): void {
      const panel = document.getElementById(\"setup-required\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"setup-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      const details = error.details as SetupRequiredDetails;
      if (details?.instructions && Array.isArray(details.instructions)) {
        const stepsList = document.getElementById(\"setup-steps\");
        if (stepsList) {
          stepsList.innerHTML = details.instructions
            .map((s: string) => `<li>${s}</li>`)
            .join(\"\");
        }
      }┬╖
      if (details?.docsUrl) {
        const docsLink = document.getElementById(
          \"docs-link\",
        ) as HTMLAnchorElement | null;
        if (docsLink) docsLink.href = String(details.docsUrl);
      }┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show multiple pipelines panel.
     */
    function showMultiplePipelines(error: PrInsightsError): void {
      const panel = document.getElementById(\"multiple-pipelines\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"multiple-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      const listEl = document.getElementById(\"pipeline-list\");
      const details = error.details as MultiplePipelinesDetails;
      if (listEl && details?.matches && Array.isArray(details.matches)) {
        listEl.innerHTML = details.matches
          .map(
            (m: any) => `
                    <a href=\"?pipelineId=${m.id}\" class=\"pipeline-option\">
                        <strong>${m.name}</strong>
                        <span class=\"pipeline-id\">ID: ${m.id}</span>
                    </a>
                `,
          )
          .join(\"\");
      }┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show permission denied panel.
     */
    function showPermissionDenied(error: PrInsightsError): void {
      const panel = document.getElementById(\"permission-denied\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"permission-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show generic error state.
     */
    function showGenericError(title: string, message: string): void {
      const panel = document.getElementById(\"error-state\");
      if (!panel) return;┬╖
      const titleEl = document.getElementById(\"error-title\");
      const messageEl = document.getElementById(\"error-message\");┬╖
      if (titleEl) titleEl.textContent = title;
      if (messageEl) messageEl.textContent = message;┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show artifacts missing panel.
     */
    function showArtifactsMissing(error: PrInsightsError): void {
      const panel = document.getElementById(\"artifacts-missing\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"missing-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      const details = error.details as ArtifactsMissingDetails;
      if (details?.instructions && Array.isArray(details.instructions)) {
        const stepsList = document.getElementById(\"missing-steps\");
        if (stepsList) {
          stepsList.innerHTML = details.instructions
            .map((s: string) => `<li>${s}</li>`)
            .join(\"\");
        }
      }┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    // ============================================================================
    // DOM and Event Handling
    // ============================================================================┬╖
    /**
     * Cache DOM elements for performance.
     */
    function cacheElements(): void {
      const ids = [
        \"app\",
        \"loading-state\",
        \"error-state\",
        \"main-content\",
        \"error-title\",
        \"error-message\",
        \"run-info\",
        \"date-range\",
        \"custom-dates\",
        \"start-date\",
        \"end-date\",
        \"retry-btn\",
        \"total-prs\",
        \"cycle-p50\",
        \"cycle-p90\",
        \"authors-count\",
        \"reviewers-count\",
        \"throughput-chart\",
        \"cycle-distribution\",
        \"total-prs-delta\",
        \"cycle-p50-delta\",
        \"cycle-p90-delta\",
        \"authors-delta\",
        \"reviewers-delta\",
        \"repo-filter\",
        \"team-filter\",
        \"repo-filter-group\",
        \"team-filter-group\",
        \"clear-filters\",
        \"active-filters\",
        \"filter-chips\",
        \"total-prs-sparkline\",
        \"cycle-p50-sparkline\",
        \"cycle-p90-sparkline\",
        \"authors-sparkline\",
        \"reviewers-sparkline\",
        \"cycle-time-trend\",
        \"reviewer-activity\",
        \"compare-toggle\",
        \"comparison-banner\",
        \"current-period-dates\",
        \"previous-period-dates\",
        \"exit-compare\",
        \"export-btn\",
        \"export-menu\",
        \"export-csv\",
        \"export-link\",
        \"export-raw-zip\",
      ];┬╖
      ids.forEach((id) => {
        elements[id] = document.getElementById(id);
      });┬╖
      elements.tabs = document.querySelectorAll(\".tab\");
    }┬╖
    /**
     * Initialize Phase 5 features.
     */
    function initializePhase5Features(): void {
      const phase5Tabs = document.querySelectorAll(\".phase5-tab\");┬╖
      if (ENABLE_PHASE5_FEATURES) {
        phase5Tabs.forEach((tab) => tab.classList.remove(\"hidden\"));
        console.log(\"Phase 5 features enabled\");
      } else {
        console.log(\"Phase 5 features disabled\");
      }
    }┬╖
    /**
     * Set up event listeners.
     */
    function setupEventListeners(): void {
      elements[\"date-range\"]?.addEventListener(\"change\", handleDateRangeChange);
      document
        .getElementById(\"apply-dates\")
        ?.addEventListener(\"click\", applyCustomDates);┬╖
      elements.tabs?.forEach((tab: HTMLElement) => {
        tab.addEventListener(\"click\", () => {
          const tabId = tab.dataset[\"tab\"];
          if (tabId) switchTab(tabId);
        });
      });┬╖
      elements[\"retry-btn\"]?.addEventListener(\"click\", () => init());
      document
        .getElementById(\"setup-retry-btn\")
        ?.addEventListener(\"click\", () => init());
      document
        .getElementById(\"permission-retry-btn\")
        ?.addEventListener(\"click\", () => init());┬╖
      elements[\"repo-filter\"]?.addEventListener(\"change\", handleFilterChange);
      elements[\"team-filter\"]?.addEventListener(\"change\", handleFilterChange);
      elements[\"clear-filters\"]?.addEventListener(\"click\", clearAllFilters);┬╖
      elements[\"compare-toggle\"]?.addEventListener(\"click\", toggleComparisonMode);
      elements[\"exit-compare\"]?.addEventListener(\"click\", exitComparisonMode);┬╖
      elements[\"export-btn\"]?.addEventListener(\"click\", toggleExportMenu);
      elements[\"export-csv\"]?.addEventListener(\"click\", exportToCsv);
      elements[\"export-link\"]?.addEventListener(\"click\", copyShareableLink);
      elements[\"export-raw-zip\"]?.addEventListener(\"click\", downloadRawDataZip);┬╖
      document.addEventListener(\"click\", (e: MouseEvent) => {
        const target = e.target as HTMLElement;
        if (!target.closest(\".export-dropdown\")) {
          elements[\"export-menu\"]?.classList.add(\"hidden\");
        }
      });
    }┬╖
    // ============================================================================
    // Data Loading and Rendering
    // ============================================================================┬╖
    /**
     * Load the dataset.
     */
    async function loadDataset(): Promise<void> {
      showLoading();┬╖
      try {
        if (!loader) throw new Error(\"Loader not initialized\");┬╖
        // Load manifest first
        const manifest = await loader.loadManifest();┬╖
        // Load dimensions
        const dimensions = await loader.loadDimensions();┬╖
        // Populate filter dropdowns from dimensions
        populateFilterDropdowns(dimensions);┬╖
        // Show dataset info
        updateDatasetInfo(manifest);┬╖
        // Restore state from URL if present
        restoreStateFromUrl();┬╖
        // Set initial date range from manifest defaults
        setInitialDateRange();┬╖
        // Load and render metrics
        await refreshMetrics();┬╖
        // Update feature tabs based on manifest
        await updateFeatureTabs();┬╖
        showContent();
      } catch (error) {
        console.error(\"Failed to load dataset:\", error);
        handleError(error);
      }
    }┬╖
    /**
     * Set initial date range from manifest defaults.
     */
    function setInitialDateRange(): void {
      // Skip if already restored from URL
      if (currentDateRange.start && currentDateRange.end) return;
      if (!loader) return;┬╖
      const coverage = loader.getCoverage() || null;
      const defaultDays = loader.getDefaultRangeDays() || 90;┬╖
      if (coverage?.date_range?.max) {
        const endDate = new Date(coverage.date_range.max);
        const startDate = new Date(endDate);
        startDate.setDate(startDate.getDate() - defaultDays);┬╖
        currentDateRange = { start: startDate, end: endDate };┬╖
        if (elements[\"start-date\"]) {
          elements[\"start-date\"].value = startDate.toISOString().split(\"T\")[0];
        }
        if (elements[\"end-date\"]) {
          elements[\"end-date\"].value = endDate.toISOString().split(\"T\")[0];
        }
      }
    }┬╖
    /**
     * Calculate the previous period date range for comparison.
     */
    function getPreviousPeriod(start: Date, end: Date): { start: Date; end: Date } {
      const durationMs = end.getTime() - start.getTime();
      const prevEnd = new Date(start.getTime() - 1); // Day before current start
      const prevStart = new Date(prevEnd.getTime() - durationMs);
      return { start: prevStart, end: prevEnd };
    }┬╖
    /**
     * Apply dimension filters to rollups data.
     * Uses by_repository slices when available for accurate filtering.
     */
    function applyFiltersToRollups(
      rollups: Rollup[],
      filters: { repos: string[]; teams: string[] },
    ): Rollup[] {
      // No filters active - return original data
      if (!filters.repos.length && !filters.teams.length) {
        return rollups;
      }┬╖
      return rollups.map((rollup) => {
        // If we have by_repository slices and repo filter is active, use them
        if (filters.repos.length && rollup.by_repository) {
          const selectedRepos = filters.repos
            .map((repoId) => {
              const repoData = rollup.by_repository![repoId];
              if (repoData) return repoData;┬╖
              return Object.entries(rollup.by_repository!).find(
                ([name]) => name === repoId,
              )?.[1];
            })
            .filter(Boolean) as any[];┬╖
          if (selectedRepos.length === 0) {
            return {
              ...rollup,
              pr_count: 0,
              cycle_time_p50: null,
              cycle_time_p90: null,
              authors_count: 0,
              reviewers_count: 0,
            };
          }┬╖
          // Aggregate metrics
          const totalPrCount = selectedRepos.reduce(
            (sum, r) => sum + (r.pr_count || 0),
            0,
          );
          const p50Values = selectedRepos
            .map((r) => r.cycle_time_p50)
            .filter((v) => v != null);
          const p90Values = selectedRepos
            .map((r) => r.cycle_time_p90)
            .filter((v) => v != null);┬╖
          const avgP50 =
            p50Values.length > 0
              ? p50Values.reduce((a, b) => a + b, 0) / p50Values.length
              : null;
          const avgP90 =
            p90Values.length > 0
              ? p90Values.reduce((a, b) => a + b, 0) / p90Values.length
              : null;┬╖
          const totalAuthors = selectedRepos.reduce(
            (sum, r) => sum + (r.authors_count || 0),
            0,
          );
          const totalReviewers = selectedRepos.reduce(
            (sum, r) => sum + (r.reviewers_count || 0),
            0,
          );┬╖
          return {
            ...rollup,
            pr_count: totalPrCount,
            cycle_time_p50: avgP50,
            cycle_time_p90: avgP90,
            authors_count: totalAuthors,
            reviewers_count: totalReviewers,
          } as Rollup;
        }┬╖
        // If we have by_team slices and team filter is active, use them
        if (filters.teams.length && rollup.by_team) {
          const selectedTeams = filters.teams
            .map((teamId) => rollup.by_team![teamId])
            .filter(Boolean) as any[];┬╖
          if (selectedTeams.length === 0) {
            return {
              ...rollup,
              pr_count: 0,
              cycle_time_p50: null,
              cycle_time_p90: null,
              authors_count: 0,
              reviewers_count: 0,
            };
          }┬╖
          const totalPrCount = selectedTeams.reduce(
            (sum, t) => sum + (t.pr_count || 0),
            0,
          );
          const p50Values = selectedTeams
            .map((t) => t.cycle_time_p50)
            .filter((v) => v != null);
          const avgP50 =
            p50Values.length > 0
              ? p50Values.reduce((a, b) => a + b, 0) / p50Values.length
              : null;┬╖
          return {
            ...rollup,
            pr_count: totalPrCount,
            cycle_time_p50: avgP50,
          } as Rollup;
        }┬╖
        return rollup;
      });
    }┬╖
    /**
     * Refresh metrics for current date range.
     */
    async function refreshMetrics(): Promise<void> {
      if (!currentDateRange.start || !currentDateRange.end || !loader) return;┬╖
      // Load current period data
      const rawRollups = await loader.getWeeklyRollups(
        currentDateRange.start,
        currentDateRange.end,
      );┬╖
      const distributions = await loader.getDistributions(
        currentDateRange.start,
        currentDateRange.end,
      );┬╖
      // Apply dimension filters to rollups
      const rollups = applyFiltersToRollups(rawRollups, currentFilters);┬╖
      // Load previous period data for comparison
      const prevPeriod = getPreviousPeriod(
        currentDateRange.start,
        currentDateRange.end,
      );
      let prevRollups: Rollup[] = [];
      try {
        const rawPrevRollups = await loader.getWeeklyRollups(
          prevPeriod.start,
          prevPeriod.end,
        );
        prevRollups = applyFiltersToRollups(rawPrevRollups, currentFilters);
      } catch (e) {
        console.debug(\"Previous period data not available:\", e);
      }┬╖
      // Cache filtered rollups for export
      cachedRollups = rollups;┬╖
      renderSummaryCards(rollups, prevRollups);
      renderThroughputChart(rollups);
      renderCycleTimeTrend(rollups);
      renderReviewerActivity(rollups);
      renderCycleDistribution(distributions);┬╖
      // Update comparison banner if in comparison mode
      if (comparisonMode) {
        updateComparisonBanner();
      }
    }┬╖
    interface CalculatedMetrics {
      totalPrs: number;
      cycleP50: number | null;
      cycleP90: number | null;
      avgAuthors: number;
      avgReviewers: number;
    }┬╖
    /**
     * Calculate metrics from rollups data.
     */
    function calculateMetrics(rollups: Rollup[]): CalculatedMetrics {
      if (!rollups || !rollups.length) {
        return {
          totalPrs: 0,
          cycleP50: null,
          cycleP90: null,
          avgAuthors: 0,
          avgReviewers: 0,
        };
      }┬╖
      const totalPrs = rollups.reduce((sum, r) => sum + (r.pr_count || 0), 0);┬╖
      const p50Values = rollups
        .map((r) => r.cycle_time_p50)
        .filter((v): v is number => v !== null && v !== undefined);
      const p90Values = rollups
        .map((r) => r.cycle_time_p90)
        .filter((v): v is number => v !== null && v !== undefined);┬╖
      const authorsSum = rollups.reduce(
        (sum, r) => sum + (r.authors_count || 0),
        0,
      );
      const reviewersSum = rollups.reduce(
        (sum, r) => sum + (r.reviewers_count || 0),
        0,
      );┬╖
      return {
        totalPrs,
        cycleP50: p50Values.length ? median(p50Values) : null,
        cycleP90: p90Values.length ? median(p90Values) : null,
        avgAuthors:
          rollups.length > 0 ? Math.round(authorsSum / rollups.length) : 0,
        avgReviewers:
          rollups.length > 0 ? Math.round(reviewersSum / rollups.length) : 0,
      };
    }┬╖
    /**
     * Calculate percentage change between two values.
     */
    function calculatePercentChange(
      current: number | null | undefined,
      previous: number | null | undefined,
    ): number | null {
      if (previous === null || previous === undefined || previous === 0) {
        return null;
      }
      if (current === null || current === undefined) {
        return null;
      }
      return ((current - previous) / previous) * 100;
    }┬╖
    /**
     * Render a delta indicator element.
     */
    function renderDelta(
      element: HTMLElement | null,
      percentChange: number | null,
      inverse = false,
    ): void {
      if (!element) return;┬╖
      if (percentChange === null) {
        element.innerHTML = \"\";
        element.className = \"metric-delta\";
        return;
      }┬╖
      const isNeutral = Math.abs(percentChange) < 2; // Within 2% is neutral
      const isPositive = percentChange > 0;
      const absChange = Math.abs(percentChange);┬╖
      let cssClass = \"metric-delta \";
      let arrow = \"\";┬╖
      if (isNeutral) {
        cssClass += \"delta-neutral\";
        arrow = \"~\";
      } else if (isPositive) {
        cssClass += inverse ? \"delta-negative-inverse\" : \"delta-positive\";
        arrow = \"&#9650;\"; // Up arrow
      } else {
        cssClass += inverse ? \"delta-positive-inverse\" : \"delta-negative\";
        arrow = \"&#9660;\"; // Down arrow
      }┬╖
      const sign = isPositive ? \"+\" : \"\";
      element.className = cssClass;
      element.innerHTML = `<span class=\"delta-arrow\">${arrow}</span> ${sign}${absChange.toFixed(0)}% <span class=\"delta-label\">vs prev</span>`;
    }┬╖
    /**
     * Render a sparkline SVG from data points.
     */
    function renderSparkline(element: HTMLElement | null, values: number[]): void {
      if (!element || !values || values.length < 2) {
        if (element) element.innerHTML = \"\";
        return;
      }┬╖
      // Take last 8 values for sparkline
      const data = values.slice(-8);
      const width = 60;
      const height = 24;
      const padding = 2;┬╖
      const minVal = Math.min(...data);
      const maxVal = Math.max(...data);
      const range = maxVal - minVal || 1;┬╖
      // Calculate points
      const points = data.map((val, i) => {
        const x = padding + (i / (data.length - 1)) * (width - padding * 2);
        const y =
          height - padding - ((val - minVal) / range) * (height - padding * 2);
        return { x, y };
      });┬╖
      // Create path
      const pathD = points
        .map((p, i) => `${i === 0 ? \"M\" : \"L\"} ${p.x.toFixed(1)} ${p.y.toFixed(1)}`)
        .join(\" \");┬╖
      // Create area path (closed)
      const areaD =
        pathD +
        ` L ${points[points.length - 1]!.x.toFixed(1)} ${height - padding} L ${points[0]!.x.toFixed(1)} ${height - padding} Z`;┬╖
      // Last point for dot
      const lastPoint = points[points.length - 1]!;┬╖
      element.innerHTML = `
            <svg viewBox=\"0 0 ${width} ${height}\" preserveAspectRatio=\"none\">
                <path class=\"sparkline-area\" d=\"${areaD}\"/>
                <path class=\"sparkline-line\" d=\"${pathD}\"/>
                <circle class=\"sparkline-dot\" cx=\"${lastPoint.x.toFixed(1)}\" cy=\"${lastPoint.y.toFixed(1)}\" r=\"2\"/>
            </svg>
        `;
    }┬╖
    /**
     * Extract sparkline data from rollups.
     */
    function extractSparklineData(rollups: Rollup[]): {
      prCounts: number[];
      p50s: number[];
      p90s: number[];
      authors: number[];
      reviewers: number[];
    } {
      if (!rollups || !rollups.length) {
        return { prCounts: [], p50s: [], p90s: [], authors: [], reviewers: [] };
      }┬╖
      return {
        prCounts: rollups.map((r) => r.pr_count || 0),
        p50s: rollups
          .map((r) => r.cycle_time_p50)
          .filter((v): v is number => v !== null && v !== undefined),
        p90s: rollups
          .map((r) => r.cycle_time_p90)
          .filter((v): v is number => v !== null && v !== undefined),
        authors: rollups.map((r) => r.authors_count || 0),
        reviewers: rollups.map((r) => r.reviewers_count || 0),
      };
    }┬╖
    /**
     * Render summary metric cards.
     */
    function renderSummaryCards(
      rollups: Rollup[],
      prevRollups: Rollup[] = [],
    ): void {
      if (metricsCollector) metricsCollector.mark(\"render-summary-cards-start\");┬╖
      const current = calculateMetrics(rollups);
      const previous = calculateMetrics(prevRollups);┬╖
      // Render metric values
      if (elements[\"total-prs\"])
        elements[\"total-prs\"].textContent = current.totalPrs.toLocaleString();
      if (elements[\"cycle-p50\"])
        elements[\"cycle-p50\"].textContent =
          current.cycleP50 !== null ? formatDuration(current.cycleP50) : \"-\";
      if (elements[\"cycle-p90\"])
        elements[\"cycle-p90\"].textContent =
          current.cycleP90 !== null ? formatDuration(current.cycleP90) : \"-\";
      if (elements[\"authors-count\"])
        elements[\"authors-count\"].textContent = current.avgAuthors.toLocaleString();
      if (elements[\"reviewers-count\"]) {
        elements[\"reviewers-count\"].textContent =
          current.avgReviewers.toLocaleString();
      }┬╖
      // Render sparklines
      const sparklineData = extractSparklineData(rollups);
      renderSparkline(elements[\"total-prs-sparkline\"], sparklineData.prCounts);
      renderSparkline(elements[\"cycle-p50-sparkline\"], sparklineData.p50s);
      renderSparkline(elements[\"cycle-p90-sparkline\"], sparklineData.p90s);
      renderSparkline(elements[\"authors-sparkline\"], sparklineData.authors);
      renderSparkline(elements[\"reviewers-sparkline\"], sparklineData.reviewers);┬╖
      // Render deltas (only if we have previous period data)
      if (prevRollups && prevRollups.length > 0) {
        renderDelta(
          elements[\"total-prs-delta\"],
          calculatePercentChange(current.totalPrs, previous.totalPrs),
          false,
        );
        renderDelta(
          elements[\"cycle-p50-delta\"],
          calculatePercentChange(current.cycleP50, previous.cycleP50),
          true,
        ); // Inverse: lower is better
        renderDelta(
          elements[\"cycle-p90-delta\"],
          calculatePercentChange(current.cycleP90, previous.cycleP90),
          true,
        ); // Inverse: lower is better
        renderDelta(
          elements[\"authors-delta\"],
          calculatePercentChange(current.avgAuthors, previous.avgAuthors),
          false,
        );
        renderDelta(
          elements[\"reviewers-delta\"],
          calculatePercentChange(current.avgReviewers, previous.avgReviewers),
          false,
        );
      } else {
        // Clear deltas if no previous data
        [
          \"total-prs-delta\",
          \"cycle-p50-delta\",
          \"cycle-p90-delta\",
          \"authors-delta\",
          \"reviewers-delta\",
        ].forEach((id) => {
          const el = elements[id];
          if (el) {
            el.innerHTML = \"\";
            el.className = \"metric-delta\";
          }
        });
      }┬╖
      if (metricsCollector) {
        metricsCollector.mark(\"render-summary-cards-end\");
        metricsCollector.mark(\"first-meaningful-paint\");
        metricsCollector.measure(
          \"init-to-fmp\",
          \"dashboard-init\",
          \"first-meaningful-paint\",
        );
      }
    }┬╖
    /**
     * Calculate moving average for trend line.
     */
    function calculateMovingAverage(
      values: number[],
      window = 4,
    ): (number | null)[] {
      const result: (number | null)[] = [];
      for (let i = 0; i < values.length; i++) {
        if (i < window - 1) {
          result.push(null);
        } else {
          const sum = values
            .slice(i - window + 1, i + 1)
            .reduce((a, b) => a + b, 0);
          result.push(sum / window);
        }
      }
      return result;
    }┬╖
    /**
     * Render throughput chart with trend line overlay.
     */
    function renderThroughputChart(rollups: Rollup[]): void {
      const chartEl = elements[\"throughput-chart\"];
      if (!chartEl) return;┬╖
      if (!rollups || !rollups.length) {
        chartEl.innerHTML = '<p class=\"no-data\">No data for selected range</p>';
        return;
      }┬╖
      const prCounts = rollups.map((r) => r.pr_count || 0);
      const maxCount = Math.max(...prCounts);
      const movingAvg = calculateMovingAverage(prCounts, 4);┬╖
      // Render bar chart
      const barsHtml = rollups
        .map((r) => {
          const height = maxCount > 0 ? ((r.pr_count || 0) / maxCount) * 100 : 0;
          return `
                <div class=\"bar-container\" title=\"${r.week}: ${r.pr_count || 0} PRs\">
                    <div class=\"bar\" style=\"height: ${height}%\"></div>
                    <div class=\"bar-label\">${r.week.split(\"-W\")[1]}</div>
                </div>
            `;
        })
        .join(\"\");┬╖
      // Render trend line SVG overlay
      let trendLineHtml = \"\";
      if (rollups.length >= 4) {
        const validPoints = movingAvg
          .map((val, i) => ({ val, i }))
          .filter((p): p is { val: number; i: number } => p.val !== null);┬╖
        if (validPoints.length >= 2) {
          const chartHeight = 200;
          const chartPadding = 8;┬╖
          // Calculate SVG path points
          const points = validPoints.map((p) => {
            const x = (p.i / (rollups.length - 1)) * 100;
            const y =
              maxCount > 0
                ? chartHeight -
                  chartPadding -
                  (p.val / maxCount) * (chartHeight - chartPadding * 2)
                : chartHeight / 2;
            return { x, y };
          });┬╖
          const pathD = points
            .map(
              (pt, i) =>
                `${i === 0 ? \"M\" : \"L\"} ${pt.x.toFixed(1)}% ${pt.y.toFixed(1)}`,
            )
            .join(\" \");┬╖
          trendLineHtml = `
                    <div class=\"trend-line-overlay\">
                        <svg viewBox=\"0 0 100 ${chartHeight}\" preserveAspectRatio=\"none\">
                            <path class=\"trend-line\" d=\"${pathD}\" vector-effect=\"non-scaling-stroke\"/>
                        </svg>
                    </div>
                `;
        }
      }┬╖
      // Legend
      const legendHtml = `
            <div class=\"chart-legend\">
                <div class=\"legend-item\">
                    <span class=\"legend-bar\"></span>
                    <span>Weekly PRs</span>
                </div>
                <div class=\"legend-item\">
                    <span class=\"legend-line\"></span>
                    <span>4-week avg</span>
                </div>
            </div>
        `;┬╖
      chartEl.innerHTML = `
            <div class=\"chart-with-trend\">
                <div class=\"bar-chart\">${barsHtml}</div>
                ${trendLineHtml}
            </div>
            ${legendHtml}
        `;
    }┬╖
    /**
     * Render cycle time distribution.
     */
    function renderCycleDistribution(distributions: any[]): void {
      const distEl = elements[\"cycle-distribution\"];
      if (!distEl) return;┬╖
      if (!distributions || !distributions.length) {
        distEl.innerHTML = '<p class=\"no-data\">No data for selected range</p>';
        return;
      }┬╖
      const buckets: Record<string, number> = {
        \"0-1h\": 0,
        \"1-4h\": 0,
        \"4-24h\": 0,
        \"1-3d\": 0,
        \"3-7d\": 0,
        \"7d+\": 0,
      };
      distributions.forEach((d) => {
        Object.entries(d.cycle_time_buckets || {}).forEach(([key, val]) => {
          buckets[key] = (buckets[key] || 0) + (val as number);
        });
      });┬╖
      const total = Object.values(buckets).reduce((a, b) => a + b, 0);
      if (total === 0) {
        distEl.innerHTML = '<p class=\"no-data\">No cycle time data</p>';
        return;
      }┬╖
      const html = Object.entries(buckets)
        .map(([label, count]) => {
          const pct = ((count / total) * 100).toFixed(1);
          return `
                <div class=\"dist-row\">
                    <span class=\"dist-label\">${label}</span>
                    <div class=\"dist-bar-bg\">
                        <div class=\"dist-bar\" style=\"width: ${pct}%\"></div>
                    </div>
                    <span class=\"dist-value\">${count} (${pct}%)</span>
                </div>
            `;
        })
        .join(\"\");┬╖
      distEl.innerHTML = html;
    }┬╖
    /**
     * Render cycle time trend chart (line chart with P50 and P90).
     */
    function renderCycleTimeTrend(rollups: Rollup[]): void {
      const trendEl = elements[\"cycle-time-trend\"];
      if (!trendEl) return;┬╖
      if (!rollups || rollups.length < 2) {
        trendEl.innerHTML = '<p class=\"no-data\">Not enough data for trend</p>';
        return;
      }┬╖
      const p50Data = rollups
        .map((r) => ({ week: r.week, value: r.cycle_time_p50 }))
        .filter((d): d is { week: string; value: number } => d.value !== null);
      const p90Data = rollups
        .map((r) => ({ week: r.week, value: r.cycle_time_p90 }))
        .filter((d): d is { week: string; value: number } => d.value !== null);┬╖
      if (p50Data.length < 2 && p90Data.length < 2) {
        trendEl.innerHTML = '<p class=\"no-data\">No cycle time data available</p>';
        return;
      }┬╖
      const allValues = [
        ...p50Data.map((d) => d.value),
        ...p90Data.map((d) => d.value),
      ];
      const maxVal = Math.max(...allValues);
      const minVal = Math.min(...allValues);
      const range = maxVal - minVal || 1;┬╖
      const width = 100;
      const height = 180;
      const padding = { top: 10, right: 10, bottom: 25, left: 40 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;┬╖
      // Generate paths
      const generatePath = (data: { week: string; value: number }[]) => {
        const points = data.map((d) => {
          const dataIndex = rollups.findIndex((r) => r.week === d.week);
          const x = padding.left + (dataIndex / (rollups.length - 1)) * chartWidth;
          const y =
            padding.top + chartHeight - ((d.value - minVal) / range) * chartHeight;
          return { x, y, week: d.week, value: d.value };
        });
        const pathD = points
          .map(
            (p, i) => `${i === 0 ? \"M\" : \"L\"} ${p.x.toFixed(1)} ${p.y.toFixed(1)}`,
          )
          .join(\" \");
        return { pathD, points };
      };┬╖
      const p50Path = p50Data.length >= 2 ? generatePath(p50Data) : null;
      const p90Path = p90Data.length >= 2 ? generatePath(p90Data) : null;┬╖
      // Y-axis labels
      const yLabels = [minVal, (minVal + maxVal) / 2, maxVal];┬╖
      const svgContent = `
            <svg viewBox=\"0 0 ${width} ${height}\" preserveAspectRatio=\"xMidYMid meet\">
                <!-- Grid lines -->
                ${yLabels
                  .map((val, i) => {
                    const y =
                      padding.top +
                      chartHeight -
                      (i / (yLabels.length - 1)) * chartHeight;
                    return `<line class=\"line-chart-grid\" x1=\"${padding.left}\" y1=\"${y}\" x2=\"${width - padding.right}\" y2=\"${y}\"/>`;
                  })
                  .join(\"\")}┬╖
                <!-- Y-axis labels -->
                ${yLabels
                  .map((val, i) => {
                    const y =
                      padding.top +
                      chartHeight -
                      (i / (yLabels.length - 1)) * chartHeight;
                    return `<text class=\"line-chart-axis\" x=\"${padding.left - 4}\" y=\"${y + 3}\" text-anchor=\"end\">${formatDuration(val)}</text>`;
                  })
                  .join(\"\")}┬╖
                <!-- Lines -->
                ${p90Path ? `<path class=\"line-chart-p90\" d=\"${p90Path.pathD}\" vector-effect=\"non-scaling-stroke\"/>` : \"\"}
                ${p50Path ? `<path class=\"line-chart-p50\" d=\"${p50Path.pathD}\" vector-effect=\"non-scaling-stroke\"/>` : \"\"}┬╖
                <!-- Dots -->
                ${p90Path ? p90Path.points.map((p) => `<circle class=\"line-chart-dot\" cx=\"${p.x}\" cy=\"${p.y}\" r=\"3\" fill=\"var(--warning)\" data-week=\"${p.week}\" data-value=\"${p.value}\" data-metric=\"P90\"/>`).join(\"\") : \"\"}
                ${p50Path ? p50Path.points.map((p) => `<circle class=\"line-chart-dot\" cx=\"${p.x}\" cy=\"${p.y}\" r=\"3\" fill=\"var(--primary)\" data-week=\"${p.week}\" data-value=\"${p.value}\" data-metric=\"P50\"/>`).join(\"\") : \"\"}
            </svg>
        `;┬╖
      const legendHtml = `
            <div class=\"chart-legend\">
                <div class=\"legend-item\">
                    <span class=\"chart-tooltip-dot legend-p50\"></span>
                    <span>P50 (Median)</span>
                </div>
                <div class=\"legend-item\">
                    <span class=\"chart-tooltip-dot legend-p90\"></span>
                    <span>P90</span>
                </div>
            </div>
        `;┬╖
      trendEl.innerHTML = `<div class=\"line-chart\">${svgContent}</div>${legendHtml}`;┬╖
      // Add tooltip interactions
      addChartTooltips(trendEl, (dot: HTMLElement) => {
        const week = dot.dataset[\"week\"];
        const value = parseFloat(dot.dataset[\"value\"] || \"0\");
        const metric = dot.dataset[\"metric\"];
        return `
                <div class=\"chart-tooltip-title\">${week}</div>
                <div class=\"chart-tooltip-row\">
                    <span class=\"chart-tooltip-label\">
                        <span class=\"chart-tooltip-dot ${metric === \"P50\" ? \"legend-p50\" : \"legend-p90\"}\"></span>
                        ${metric}
                    </span>
                    <span>${formatDuration(value)}</span>
                </div>
            `;
      });
    }┬╖
    /**
     * Render reviewer activity chart (horizontal bar chart).
     */
    function renderReviewerActivity(rollups: Rollup[]): void {
      const revEl = elements[\"reviewer-activity\"];
      if (!revEl) return;┬╖
      if (!rollups || !rollups.length) {
        revEl.innerHTML = '<p class=\"no-data\">No reviewer data available</p>';
        return;
      }┬╖
      // Take last 8 weeks for display
      const recentRollups = rollups.slice(-8);
      const maxReviewers = Math.max(
        ...recentRollups.map((r) => r.reviewers_count || 0),
      );┬╖
      if (maxReviewers === 0) {
        revEl.innerHTML = '<p class=\"no-data\">No reviewer data available</p>';
        return;
      }┬╖
      const barsHtml = recentRollups
        .map((r) => {
          const count = r.reviewers_count || 0;
          const pct = (count / maxReviewers) * 100;
          const weekLabel = r.week.split(\"-W\")[1];
          return `
                <div class=\"h-bar-row\" title=\"${r.week}: ${count} reviewers\">
                    <span class=\"h-bar-label\">W${weekLabel}</span>
                    <div class=\"h-bar-container\">
                        <div class=\"h-bar\" style=\"width: ${pct}%\"></div>
                    </div>
                    <span class=\"h-bar-value\">${count}</span>
                </div>
            `;
        })
        .join(\"\");┬╖
      revEl.innerHTML = `<div class=\"horizontal-bar-chart\">${barsHtml}</div>`;
    }┬╖
    /**
     * Add tooltip interactions to a chart.
     */
    function addChartTooltips(
      container: HTMLElement,
      contentFn: (dot: HTMLElement) => string,
    ): void {
      const dots = container.querySelectorAll(\".line-chart-dot\");
      let tooltip: HTMLElement | null = null;┬╖
      dots.forEach((dotNode) => {
        const dot = dotNode as HTMLElement;
        dot.addEventListener(\"mouseenter\", () => {
          if (!tooltip) {
            tooltip = document.createElement(\"div\");
            tooltip.className = \"chart-tooltip\";
            container.appendChild(tooltip);
          }
          tooltip.innerHTML = contentFn(dot);
          tooltip.style.display = \"block\";┬╖
          // Position tooltip
          const rect = container.getBoundingClientRect();
          const dotRect = dot.getBoundingClientRect();
          tooltip.style.left = `${dotRect.left - rect.left + 10}px`;
          tooltip.style.top = `${dotRect.top - rect.top - 40}px`;
        });┬╖
        dot.addEventListener(\"mouseleave\", () => {
          if (tooltip) {
            tooltip.style.display = \"none\";
          }
        });
      });
    }┬╖
    /**
     * Update feature tabs based on manifest.
     */
    async function updateFeatureTabs(): Promise<void> {
      if (!loader) return;┬╖
      // Check if loader supports loadPredictions/loadInsights
      if (typeof (loader as any).loadPredictions !== \"function\") return;┬╖
      const predictionsContent = document.getElementById(\"tab-predictions\");
      const predictionsUnavailable = document.getElementById(
        \"predictions-unavailable\",
      );
      if (predictionsContent) {
        const predictionsResult = await (loader as any).loadPredictions();┬╖
        if (
          predictionsResult?.state === \"ok\" &&
          predictionsResult.data?.forecasts?.length > 0
        ) {
          renderPredictions(predictionsContent, predictionsResult.data);
        } else if (predictionsUnavailable) {
          predictionsUnavailable.classList.remove(\"hidden\");
        }
      }┬╖
      const aiContent = document.getElementById(\"tab-ai-insights\");
      const aiUnavailable = document.getElementById(\"ai-unavailable\");
      if (aiContent) {
        const insightsResult = await (loader as any).loadInsights();┬╖
        if (
          insightsResult?.state === \"ok\" &&
          insightsResult.data?.insights?.length > 0
        ) {
          renderAIInsights(aiContent, insightsResult.data);
        } else if (aiUnavailable) {
          aiUnavailable.classList.remove(\"hidden\");
        }
      }
    }┬╖
    /**
     * Render predictions.
     */
    function renderPredictions(container: HTMLElement, predictions: any): void {
      const content = document.createElement(\"div\");
      content.className = \"predictions-content\";┬╖
      if (predictions.is_stub) {
        content.innerHTML += `<div class=\"stub-warning\">ΓÜá∩╕Å Demo data</div>`;
      }┬╖
      predictions.forecasts.forEach((forecast: any) => {
        const label = forecast.metric
          .replace(/_/g, \" \")
          .replace(/\\b\\w/g, (c: string) => c.toUpperCase());
        content.innerHTML += `
                <div class=\"forecast-section\">
                    <h4>${label} (${forecast.unit})</h4>
                    <table class=\"forecast-table\">
                        <thead><tr><th>Week</th><th>Predicted</th><th>Range</th></tr></thead>
                        <tbody>
                            ${forecast.values
                              .map(
                                (v: any) => `
                                <tr>
                                    <td>${v.period_start}</td>
                                    <td>${v.predicted}</td>
                                    <td>${v.lower_bound} - ${v.upper_bound}</td>
                                </tr>
                            `,
                              )
                              .join(\"\")}
                        </tbody>
                    </table>
                </div>
            `;
      });┬╖
      const unavailable = container.querySelector(\".feature-unavailable\");
      if (unavailable) unavailable.classList.add(\"hidden\");
      container.appendChild(content);
    }┬╖
    /**
     * Render AI insights.
     */
    function renderAIInsights(container: HTMLElement, insights: any): void {
      const content = document.createElement(\"div\");
      content.className = \"insights-content\";┬╖
      if (insights.is_stub) {
        content.innerHTML += `<div class=\"stub-warning\">ΓÜá∩╕Å Demo data</div>`;
      }┬╖
      const icons: Record<string, string> = {
        critical: \"≡ƒö┤\",
        warning: \"≡ƒƒí\",
        info: \"≡ƒö╡\",
      };
      [\"critical\", \"warning\", \"info\"].forEach((severity) => {
        const items = insights.insights.filter((i: any) => i.severity === severity);
        if (!items.length) return;┬╖
        content.innerHTML += `
                <div class=\"severity-section\">
                    <h4>${icons[severity]} ${severity.charAt(0).toUpperCase() + severity.slice(1)}</h4>
                    <div class=\"insight-cards\">
                        ${items
                          .map(
                            (i: any) => `
                            <div class=\"insight-card ${i.severity}\">
                                <div class=\"insight-category\">${i.category}</div>
                                <h5>${i.title}</h5>
                                <p>${i.description}</p>
                            </div>
                        `,
                          )
                          .join(\"\")}
                    </div>
                </div>
            `;
      });┬╖
      const unavailable = container.querySelector(\".feature-unavailable\");
      if (unavailable) unavailable.classList.add(\"hidden\");
      container.appendChild(content);
    }┬╖
    // ============================================================================
    // Event Handlers
    // ============================================================================┬╖
    function handleDateRangeChange(e: Event): void {
      const target = e.target as HTMLSelectElement;
      const value = target.value;┬╖
      if (value === \"custom\") {
        elements[\"custom-dates\"]?.classList.remove(\"hidden\");
        return;
      }┬╖
      elements[\"custom-dates\"]?.classList.add(\"hidden\");┬╖
      const days = parseInt(value, 10);
      const coverage = loader?.getCoverage() || null;
      const endDate = coverage?.date_range?.max
        ? new Date(coverage.date_range.max)
        : new Date();
      const startDate = new Date(endDate);
      startDate.setDate(startDate.getDate() - days);┬╖
      currentDateRange = { start: startDate, end: endDate };
      updateUrlState();
      refreshMetrics();
    }┬╖
    function applyCustomDates(): void {
      const start = (elements[\"start-date\"] as HTMLInputElement)?.value;
      const end = (elements[\"end-date\"] as HTMLInputElement)?.value;┬╖
      if (!start || !end) return;┬╖
      currentDateRange = { start: new Date(start), end: new Date(end) };
      updateUrlState();
      refreshMetrics();
    }┬╖
    function switchTab(tabId: string): void {
      elements.tabs?.forEach((tab: HTMLElement) => {
        tab.classList.toggle(\"active\", tab.dataset[\"tab\"] === tabId);
      });┬╖
      document.querySelectorAll(\".tab-content\").forEach((content) => {
        content.classList.toggle(\"active\", content.id === `tab-${tabId}`);
        content.classList.toggle(\"hidden\", content.id !== `tab-${tabId}`);
      });┬╖
      updateUrlState();
    }┬╖
    // ============================================================================
    // Filter Management
    // ============================================================================┬╖
    /**
     * Populate filter dropdowns from loaded dimensions.
     */
    function populateFilterDropdowns(dimensions: any): void {
      if (!dimensions) return;┬╖
      // Populate repository filter
      const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
      if (repoFilter && dimensions.repositories?.length > 0) {
        repoFilter.innerHTML = '<option value=\"\">All</option>';
        dimensions.repositories.forEach((repo: any) => {
          const option = document.createElement(\"option\");
          option.value = repo.id || repo.name;
          option.textContent = repo.name;
          repoFilter.appendChild(option);
        });
        elements[\"repo-filter-group\"]?.classList.remove(\"hidden\");
      } else {
        elements[\"repo-filter-group\"]?.classList.add(\"hidden\");
      }┬╖
      // Populate team filter
      const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
      if (teamFilter && dimensions.teams?.length > 0) {
        teamFilter.innerHTML = '<option value=\"\">All</option>';
        dimensions.teams.forEach((team: any) => {
          const option = document.createElement(\"option\");
          option.value = team.id || team.name;
          option.textContent = team.name;
          teamFilter.appendChild(option);
        });
        elements[\"team-filter-group\"]?.classList.remove(\"hidden\");
      } else {
        elements[\"team-filter-group\"]?.classList.add(\"hidden\");
      }┬╖
      // Restore filter state from URL
      restoreFiltersFromUrl();
    }┬╖
    /**
     * Handle filter dropdown change.
     */
    function handleFilterChange(): void {
      const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
      const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;┬╖
      const repoValues = repoFilter
        ? Array.from(repoFilter.selectedOptions)
            .map((o) => o.value)
            .filter((v) => v)
        : [];
      const teamValues = teamFilter
        ? Array.from(teamFilter.selectedOptions)
            .map((o) => o.value)
            .filter((v) => v)
        : [];┬╖
      currentFilters = { repos: repoValues, teams: teamValues };┬╖
      updateFilterUI();
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Clear all filters.
     */
    function clearAllFilters(): void {
      currentFilters = { repos: [], teams: [] };┬╖
      const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
      const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;┬╖
      if (repoFilter) {
        Array.from(repoFilter.options).forEach(
          (o) => (o.selected = o.value === \"\"),
        );
      }
      if (teamFilter) {
        Array.from(teamFilter.options).forEach(
          (o) => (o.selected = o.value === \"\"),
        );
      }┬╖
      updateFilterUI();
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Remove a specific filter.
     */
    function removeFilter(type: string, value: string): void {
      if (type === \"repo\") {
        currentFilters.repos = currentFilters.repos.filter((v) => v !== value);
        const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
        if (repoFilter) {
          const option = repoFilter.querySelector(
            `option[value=\"${value}\"]`,
          ) as HTMLOptionElement | null;
          if (option) option.selected = false;
        }
      } else if (type === \"team\") {
        currentFilters.teams = currentFilters.teams.filter((v) => v !== value);
        const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
        if (teamFilter) {
          const option = teamFilter.querySelector(
            `option[value=\"${value}\"]`,
          ) as HTMLOptionElement | null;
          if (option) option.selected = false;
        }
      }┬╖
      updateFilterUI();
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Update filter UI.
     */
    function updateFilterUI(): void {
      const hasFilters =
        currentFilters.repos.length > 0 || currentFilters.teams.length > 0;┬╖
      if (elements[\"clear-filters\"]) {
        elements[\"clear-filters\"].classList.toggle(\"hidden\", !hasFilters);
      }┬╖
      if (elements[\"active-filters\"] && elements[\"filter-chips\"]) {
        elements[\"active-filters\"].classList.toggle(\"hidden\", !hasFilters);┬╖
        if (hasFilters) {
          renderFilterChips();
        } else {
          elements[\"filter-chips\"].innerHTML = \"\";
        }
      }
    }┬╖
    /**
     * Render filter chips for active filters.
     */
    function renderFilterChips(): void {
      const chipsEl = elements[\"filter-chips\"] as HTMLElement | null;
      if (!chipsEl) return;┬╖
      const chips: string[] = [];┬╖
      currentFilters.repos.forEach((value) => {
        const label = getFilterLabel(\"repo\", value);
        chips.push(createFilterChip(\"repo\", value, label));
      });┬╖
      currentFilters.teams.forEach((value) => {
        const label = getFilterLabel(\"team\", value);
        chips.push(createFilterChip(\"team\", value, label));
      });┬╖
      chipsEl.innerHTML = chips.join(\"\");┬╖
      chipsEl.querySelectorAll(\".filter-chip-remove\").forEach((btnNode) => {
        const btn = btnNode as HTMLElement;
        btn.addEventListener(\"click\", () => {
          const type = btn.dataset[\"type\"];
          const val = btn.dataset[\"value\"];
          if (type && val) removeFilter(type, val);
        });
      });
    }┬╖
    /**
     * Get display label for a filter value.
     */
    function getFilterLabel(type: string, value: string): string {
      if (type === \"repo\") {
        const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
        const option = repoFilter?.querySelector(`option[value=\"${value}\"]`);
        return option?.textContent || value;
      }
      if (type === \"team\") {
        const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
        const option = teamFilter?.querySelector(`option[value=\"${value}\"]`);
        return option?.textContent || value;
      }
      return value;
    }┬╖
    /**
     * Create HTML for a filter chip.
     */
    function createFilterChip(type: string, value: string, label: string): string {
      const prefix = type === \"repo\" ? \"repo\" : \"team\";
      return `
            <span class=\"filter-chip\">
                <span class=\"filter-chip-label\">${prefix}: ${label}</span>
                <span class=\"filter-chip-remove\" data-type=\"${type}\" data-value=\"${value}\">&times;</span>
            </span>
        `;
    }┬╖
    /**
     * Restore filters from URL parameters.
     */
    function restoreFiltersFromUrl(): void {
      const params = new URLSearchParams(window.location.search);┬╖
      const reposParam = params.get(\"repos\");
      const teamsParam = params.get(\"teams\");┬╖
      if (reposParam) {
        currentFilters.repos = reposParam.split(\",\").filter((v) => v);
        const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
        if (repoFilter) {
          currentFilters.repos.forEach((value) => {
            const option = repoFilter.querySelector(
              `option[value=\"${value}\"]`,
            ) as HTMLOptionElement | null;
            if (option) option.selected = true;
          });
        }
      }┬╖
      if (teamsParam) {
        currentFilters.teams = teamsParam.split(\",\").filter((v) => v);
        const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
        if (teamFilter) {
          currentFilters.teams.forEach((value) => {
            const option = teamFilter.querySelector(
              `option[value=\"${value}\"]`,
            ) as HTMLOptionElement | null;
            if (option) option.selected = true;
          });
        }
      }┬╖
      updateFilterUI();
    }┬╖
    // ============================================================================
    // Comparison Mode
    // ============================================================================┬╖
    /**
     * Toggle comparison mode on/off.
     */
    function toggleComparisonMode(): void {
      comparisonMode = !comparisonMode;┬╖
      elements[\"compare-toggle\"]?.classList.toggle(\"active\", comparisonMode);
      elements[\"comparison-banner\"]?.classList.toggle(\"hidden\", !comparisonMode);┬╖
      if (comparisonMode) {
        updateComparisonBanner();
      }┬╖
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Exit comparison mode.
     */
    function exitComparisonMode(): void {
      comparisonMode = false;
      elements[\"compare-toggle\"]?.classList.remove(\"active\");
      elements[\"comparison-banner\"]?.classList.add(\"hidden\");
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Update the comparison banner with date ranges.
     */
    function updateComparisonBanner(): void {
      if (!currentDateRange.start || !currentDateRange.end) return;┬╖
      const formatDate = (date: Date) =>
        date.toLocaleDateString(\"en-US\", {
          month: \"short\",
          day: \"numeric\",
          year: \"numeric\",
        });┬╖
      // Current period
      const currentStart = formatDate(currentDateRange.start);
      const currentEnd = formatDate(currentDateRange.end);
      if (elements[\"current-period-dates\"]) {
        elements[\"current-period-dates\"].textContent =
          `${currentStart} - ${currentEnd}`;
      }┬╖
      // Previous period
      const prevPeriod = getPreviousPeriod(
        currentDateRange.start,
        currentDateRange.end,
      );
      const prevStart = formatDate(prevPeriod.start);
      const prevEnd = formatDate(prevPeriod.end);
      if (elements[\"previous-period-dates\"]) {
        elements[\"previous-period-dates\"].textContent = `${prevStart} - ${prevEnd}`;
      }
    }┬╖
    // ============================================================================
    // Export Functions
    // ============================================================================┬╖
    /**
     * Toggle export menu visibility.
     */
    function toggleExportMenu(e: Event): void {
      e.stopPropagation();
      elements[\"export-menu\"]?.classList.toggle(\"hidden\");
    }┬╖
    /**
     * Export current data to CSV.
     */
    function exportToCsv(): void {
      elements[\"export-menu\"]?.classList.add(\"hidden\");┬╖
      if (!cachedRollups || cachedRollups.length === 0) {
        showToast(\"No data to export\", \"error\");
        return;
      }┬╖
      // Build CSV content
      const headers = [
        \"Week\",
        \"Start Date\",
        \"End Date\",
        \"PR Count\",
        \"Cycle Time P50 (min)\",
        \"Cycle Time P90 (min)\",
        \"Authors\",
        \"Reviewers\",
      ];
      const rows = cachedRollups.map((r) => [
        r.week,
        r.start_date || \"\",
        r.end_date || \"\",
        r.pr_count || 0,
        r.cycle_time_p50 != null ? r.cycle_time_p50.toFixed(1) : \"\",
        r.cycle_time_p90 != null ? r.cycle_time_p90.toFixed(1) : \"\",
        r.authors_count || 0,
        r.reviewers_count || 0,
      ]);┬╖
      const csvContent = [headers, ...rows]
        .map((row) => row.map((cell) => `\"${cell}\"`).join(\",\"))
        .join(\"\\n\");┬╖
      // Download file
      const blob = new Blob([csvContent], { type: \"text/csv;charset=utf-8;\" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement(\"a\");
      link.href = url;┬╖
      const dateStr = new Date().toISOString().split(\"T\")[0];
      link.download = `pr-insights-${dateStr}.csv`;┬╖
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);┬╖
      showToast(\"CSV exported successfully\", \"success\");
    }┬╖
    /**
     * Copy shareable link to clipboard.
     */
    async function copyShareableLink(): Promise<void> {
      elements[\"export-menu\"]?.classList.add(\"hidden\");┬╖
      try {
        await navigator.clipboard.writeText(window.location.href);
        showToast(\"Link copied to clipboard\", \"success\");
      } catch (_err) {
        // Fallback
        const textArea = document.createElement(\"textarea\");
        textArea.value = window.location.href;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand(\"copy\");
        document.body.removeChild(textArea);
        showToast(\"Link copied to clipboard\", \"success\");
      }
    }┬╖
    /**
     * Download raw CSV data as a ZIP file.
     */
    async function downloadRawDataZip(): Promise<void> {
      elements[\"export-menu\"]?.classList.add(\"hidden\");┬╖
      if (!currentBuildId || !artifactClient) {
        showToast(\"Raw data not available in direct URL mode\", \"error\");
        return;
      }┬╖
      try {
        showToast(\"Preparing download...\", \"success\");┬╖
        const artifact = await artifactClient.getArtifactMetadata(
          currentBuildId,
          \"csv-output\",
        );┬╖
        if (!artifact) {
          showToast(\"Raw CSV artifact not found in this pipeline run\", \"error\");
          return;
        }┬╖
        const downloadUrl = artifact.resource?.downloadUrl;
        if (!downloadUrl) {
          showToast(\"Download URL not available\", \"error\");
          return;
        }┬╖
        let zipUrl = downloadUrl;
        if (!zipUrl.includes(\"format=zip\")) {
          const separator = zipUrl.includes(\"?\") ? \"&\" : \"?\";
          zipUrl = `${zipUrl}${separator}format=zip`;
        }┬╖
        // Use the protected method from ArtifactClient
        const response = await (artifactClient as any)._authenticatedFetch(zipUrl);┬╖
        if (!response.ok) {
          if (response.status === 403 || response.status === 401) {
            showToast(\"Permission denied to download artifacts\", \"error\");
          } else {
            showToast(`Download failed: ${response.statusText}`, \"error\");
          }
          return;
        }┬╖
        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        const link = document.createElement(\"a\");
        link.href = url;┬╖
        const dateStr = new Date().toISOString().split(\"T\")[0];
        link.download = `pr-insights-raw-data-${dateStr}.zip`;┬╖
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);┬╖
        showToast(\"Download started\", \"success\");
      } catch (err) {
        console.error(\"Failed to download raw data:\", err);
        showToast(\"Failed to download raw data\", \"error\");
      }
    }┬╖
    /**
     * Show a toast notification.
     */
    function showToast(
      message: string,
      type: \"success\" | \"error\" = \"success\",
    ): void {
      const toast = document.createElement(\"div\");
      toast.className = `toast ${type}`;
      toast.textContent = message;
      document.body.appendChild(toast);┬╖
      setTimeout(() => {
        toast.remove();
      }, 3000);
    }┬╖
    // ============================================================================
    // Utility Functions
    // ============================================================================┬╖
    function showLoading(): void {
      hideAllPanels();
      elements[\"loading-state\"]?.classList.remove(\"hidden\");
    }┬╖
    function showContent(): void {
      hideAllPanels();
      elements[\"main-content\"]?.classList.remove(\"hidden\");
    }┬╖
    function updateDatasetInfo(manifest: any): void {
      const generatedAt = manifest?.generated_at
        ? new Date(manifest.generated_at).toLocaleString()
        : \"Unknown\";
      const runId = manifest?.run_id || \"\";┬╖
      const runInfo = elements[\"run-info\"];
      if (runInfo) {
        runInfo.textContent = `Generated: ${generatedAt}`;
        if (runId) runInfo.textContent += ` | Run: ${runId.slice(0, 8)}`;
      }
    }┬╖
    function formatDuration(minutes: number): string {
      if (minutes < 60) return `${Math.round(minutes)}m`;
      if (minutes < 1440) return `${(minutes / 60).toFixed(1)}h`;
      return `${(minutes / 1440).toFixed(1)}d`;
    }┬╖
    function median(arr: number[]): number {
      const sorted = [...arr].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      return sorted.length % 2
        ? sorted[mid]!
        : (sorted[mid - 1]! + sorted[mid]!) / 2;
    }┬╖
    function updateUrlState(): void {
      const params = new URLSearchParams(window.location.search);
      const newParams = new URLSearchParams();┬╖
      // Preserve config params
      if (params.get(\"dataset\")) newParams.set(\"dataset\", params.get(\"dataset\")!);
      if (params.get(\"pipelineId\"))
        newParams.set(\"pipelineId\", params.get(\"pipelineId\")!);┬╖
      // Add date range
      if (currentDateRange.start) {
        newParams.set(\"start\", currentDateRange.start.toISOString().split(\"T\")[0]!);
      }
      if (currentDateRange.end) {
        newParams.set(\"end\", currentDateRange.end.toISOString().split(\"T\")[0]!);
      }┬╖
      // Add active tab
      const activeTab = document.querySelector(\".tab.active\") as HTMLElement | null;
      if (activeTab && activeTab.dataset[\"tab\"] !== \"metrics\") {
        newParams.set(\"tab\", activeTab.dataset[\"tab\"]!);
      }┬╖
      // Add filters
      if (currentFilters.repos.length > 0) {
        newParams.set(\"repos\", currentFilters.repos.join(\",\"));
      }
      if (currentFilters.teams.length > 0) {
        newParams.set(\"teams\", currentFilters.teams.join(\",\"));
      }┬╖
      // Add comparison mode
      if (comparisonMode) {
        newParams.set(\"compare\", \"1\");
      }┬╖
      window.history.replaceState(
        {},
        \"\",
        `${window.location.pathname}?${newParams.toString()}`,
      );
    }┬╖
    function restoreStateFromUrl(): void {
      const params = new URLSearchParams(window.location.search);┬╖
      const startParam = params.get(\"start\");
      const endParam = params.get(\"end\");
      if (startParam && endParam) {
        currentDateRange = { start: new Date(startParam), end: new Date(endParam) };
        const dateRangeEl = elements[\"date-range\"] as HTMLSelectElement | null;
        if (dateRangeEl) {
          dateRangeEl.value = \"custom\";
          elements[\"custom-dates\"]?.classList.remove(\"hidden\");
        }
        if (elements[\"start-date\"]) elements[\"start-date\"].value = startParam;
        if (elements[\"end-date\"]) elements[\"end-date\"].value = endParam;
      }┬╖
      const tabParam = params.get(\"tab\");
      if (tabParam) {
        setTimeout(() => switchTab(tabParam), 0);
      }┬╖
      // Restore comparison mode
      const compareParam = params.get(\"compare\");
      if (compareParam === \"1\") {
        comparisonMode = true;
        elements[\"compare-toggle\"]?.classList.add(\"active\");
        elements[\"comparison-banner\"]?.classList.remove(\"hidden\");
      }
    }┬╖
    // ============================================================================
    // Initialize
    // ============================================================================┬╖
    if (document.readyState === \"loading\") {
      document.addEventListener(\"DOMContentLoaded\", init);
    } else {
      init();
    }
    "

      25 |
      26 |     it("should have SETTINGS_KEY_PIPELINE constant", () => {
    > 27 |       expect(dashboardCode).toContain(
         |                             ^
      28 |         "SETTINGS_KEY_PIPELINE = 'pr-insights-pipeline-id'",
      29 |       );
      30 |     });

      at Object.<anonymous> (tests/cross-project-settings.test.ts:27:29)

  ΓùÅ Cross-Project Settings ΓÇ║ dashboard.ts configuration ΓÇ║ should have getSourceConfig function that returns both projectId and pipelineId

    expect(received).toContain(expected) // indexOf

    Expected substring: "const result: { projectId: string | null; pipelineId: number | null } = { projectId: null, pipelineId: null }"
    Received string:    "/**
     * PR Insights Dashboard
     *
     * Project-level hub that loads data from pipeline artifacts.
     * Uses Azure DevOps Extension SDK for authentication.
     *
     * Configuration precedence:
     * 1. ?dataset=<url> - Direct URL (DEV ONLY)
     * 2. ?pipelineId=<id> - Query parameter override
     * 3. Extension settings - User-scoped saved preference
     * 4. Auto-discovery - Find pipelines with 'aggregates' artifact
     */┬╖
    import { DatasetLoader, IDatasetLoader, Rollup } from \"./dataset-loader\";
    import { ArtifactClient } from \"./artifact-client\";
    import {
      PrInsightsError,
      ErrorTypes,
      createSetupRequiredError,
      createNoSuccessfulBuildsError,
      createArtifactsMissingError,
      createInvalidConfigError,
      SetupRequiredDetails,
      MultiplePipelinesDetails,
      ArtifactsMissingDetails,
    } from \"./error-types\";┬╖
    // Dashboard state
    let loader: IDatasetLoader | null = null;
    let artifactClient: ArtifactClient | null = null;
    let currentDateRange: { start: Date | null; end: Date | null } = {
      start: null,
      end: null,
    };
    let currentFilters: { repos: string[]; teams: string[] } = {
      repos: [],
      teams: [],
    };
    let comparisonMode = false;
    let cachedRollups: Rollup[] = []; // Cache for export
    let currentBuildId: number | null = null; // Store build ID for raw data download
    let sdkInitialized = false;┬╖
    // Settings keys for extension data storage (must match settings.js)
    const SETTINGS_KEY_PROJECT = \"pr-insights-source-project\";
    const SETTINGS_KEY_PIPELINE = \"pr-insights-pipeline-id\";┬╖
    // Feature flags
    const ENABLE_PHASE5_FEATURES = true;┬╖
    // DOM element cache
    const elements: Record<string, any> = {};┬╖
    /**
     * Phase 4: Production-safe metrics collector
     */
    const IS_PRODUCTION =
      typeof window !== \"undefined\" &&
      (window as any).process?.env?.NODE_ENV === \"production\";
    const DEBUG_ENABLED =
      !IS_PRODUCTION &&
      ((typeof window !== \"undefined\" && (window as any).__DASHBOARD_DEBUG__) ||
        (typeof window !== \"undefined\" &&
          new URLSearchParams(window.location.search).has(\"debug\")));┬╖
    interface PerformanceMetric {
      name: string;
      duration: number;
      timestamp: number;
    }┬╖
    const metricsCollector = DEBUG_ENABLED
      ? {
          marks: new Map<string, number>(),
          measures: [] as PerformanceMetric[],
          mark(name: string) {
            if (!performance || !performance.mark) return;
            try {
              performance.mark(name);
              this.marks.set(name, performance.now());
            } catch (_e) {
              /* ignore */
            }
          },
          measure(name: string, startMark: string, endMark: string) {
            if (!performance || !performance.measure) return;
            try {
              performance.measure(name, startMark, endMark);
              const entries = performance.getEntriesByName(name, \"measure\");
              if (entries.length > 0) {
                const lastEntry = entries[entries.length - 1];
                if (lastEntry) {
                  this.measures.push({
                    name,
                    duration: lastEntry.duration,
                    timestamp: Date.now(),
                  });
                }
              }
            } catch (_e) {
              /* ignore */
            }
          },
          getMetrics() {
            return {
              marks: Array.from(this.marks.entries()).map(([name, time]) => ({
                name,
                time,
              })),
              measures: [...this.measures],
            };
          },
          reset() {
            this.marks.clear();
            this.measures = [];
            if (performance && performance.clearMarks) performance.clearMarks();
            if (performance && performance.clearMeasures)
              performance.clearMeasures();
          },
        }
      : null;┬╖
    if (DEBUG_ENABLED && typeof window !== \"undefined\") {
      (window as any).__dashboardMetrics = metricsCollector;
    }┬╖
    // ============================================================================
    // SDK Initialization
    // ============================================================================┬╖
    /**
     * Initialize Azure DevOps Extension SDK.
     */
    async function initializeAdoSdk(): Promise<void> {
      if (sdkInitialized) return;┬╖
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error(\"Azure DevOps SDK initialization timed out\"));
        }, 10000);┬╖
        VSS.init({
          explicitNotifyLoaded: true,
          usePlatformScripts: true,
          usePlatformStyles: true,
        });┬╖
        VSS.ready(() => {
          clearTimeout(timeout);
          sdkInitialized = true;┬╖
          // Update project name in UI
          const webContext = VSS.getWebContext();
          const projectNameEl = document.getElementById(\"current-project-name\");
          if (projectNameEl && webContext?.project?.name) {
            projectNameEl.textContent = webContext.project.name;
          }┬╖
          VSS.notifyLoadSucceeded();
          resolve();
        });
      });
    }┬╖
    // ============================================================================
    // Configuration Resolution
    // ============================================================================┬╖
    /**
     * Parse and validate query parameters.
     */
    function parseQueryParams():
      | { mode: string; value: any; warning?: string | null }
      | PrInsightsError {
      const params = new URLSearchParams(window.location.search);┬╖
      const datasetUrl = params.get(\"dataset\");
      const pipelineIdStr = params.get(\"pipelineId\");┬╖
      // Check for dataset URL (highest priority)
      if (datasetUrl) {
        // Validate URL
        if (!datasetUrl.startsWith(\"https://\")) {
          return createInvalidConfigError(
            \"dataset\",
            datasetUrl,
            \"Must be a valid HTTPS URL\",
          );
        }┬╖
        // Security warning for non-ADO domains
        const IS_DEV =
          window.location.hostname === \"localhost\" || params.has(\"devMode\");┬╖
        if (!IS_DEV) {
          try {
            const urlHost = new URL(datasetUrl).hostname;
            const isAdoDomain =
              urlHost.endsWith(\"dev.azure.com\") ||
              urlHost.endsWith(\".visualstudio.com\") ||
              urlHost.endsWith(\".azure.com\");
            if (!isAdoDomain) {
              console.warn(
                `SECURITY: ?dataset= URL \"${urlHost}\" is not an Azure DevOps domain. ` +
                  `This parameter is intended for development only.`,
              );
            }
          } catch (_e) {
            return createInvalidConfigError(
              \"dataset\",
              datasetUrl,
              \"Invalid URL format\",
            );
          }
        }┬╖
        let warning: string | null = null;
        if (pipelineIdStr) {
          warning = \"Both dataset and pipelineId specified; using dataset\";
          console.warn(warning);
        }┬╖
        return { mode: \"direct\", value: datasetUrl, warning };
      }┬╖
      // Check for pipelineId
      if (pipelineIdStr) {
        const pipelineId = parseInt(pipelineIdStr, 10);
        if (isNaN(pipelineId) || pipelineId <= 0) {
          return createInvalidConfigError(
            \"pipelineId\",
            pipelineIdStr,
            \"Must be a positive integer\",
          );
        }
        return { mode: \"explicit\", value: pipelineId };
      }┬╖
      return { mode: \"discover\", value: null };
    }┬╖
    /**
     * Get source configuration from extension settings.
     */
    async function getSourceConfig(): Promise<{
      projectId: string | null;
      pipelineId: number | null;
    }> {
      const result: { projectId: string | null; pipelineId: number | null } = {
        projectId: null,
        pipelineId: null,
      };
      try {
        const dataService = await VSS.getService<IExtensionDataService>(
          VSS.ServiceIds.ExtensionData,
        );┬╖
        // Get source project ID
        const savedProjectId = await dataService.getValue<string>(
          SETTINGS_KEY_PROJECT,
          { scopeType: \"User\" },
        );
        if (
          savedProjectId &&
          typeof savedProjectId === \"string\" &&
          savedProjectId.trim()
        ) {
          result.projectId = savedProjectId.trim();
        }┬╖
        // Get pipeline definition ID
        const savedPipelineId = await dataService.getValue<number>(
          SETTINGS_KEY_PIPELINE,
          { scopeType: \"User\" },
        );
        if (
          savedPipelineId &&
          typeof savedPipelineId === \"number\" &&
          savedPipelineId > 0
        ) {
          result.pipelineId = savedPipelineId;
        }
      } catch (e) {
        console.log(\"Could not read extension settings:\", e);
      }
      return result;
    }┬╖
    /**
     * Clear stale pipeline ID setting.
     */
    async function clearStalePipelineSetting(): Promise<void> {
      try {
        const dataService = await VSS.getService<IExtensionDataService>(
          VSS.ServiceIds.ExtensionData,
        );
        await dataService.setValue(SETTINGS_KEY_PIPELINE, null, {
          scopeType: \"User\",
        });
        console.log(\"Cleared stale pipeline setting to re-enable auto-discovery\");
      } catch (e) {
        console.warn(\"Could not clear stale pipeline setting:\", e);
      }
    }┬╖
    /**
     * Resolve configuration using precedence rules.
     */
    async function resolveConfiguration(): Promise<{
      buildId?: number;
      artifactName?: string;
      directUrl?: string;
    }> {
      const queryResult = parseQueryParams();┬╖
      // Check for parsing error
      if (queryResult instanceof PrInsightsError) {
        throw queryResult;
      }┬╖
      // Mode: direct URL
      if (queryResult.mode === \"direct\") {
        return { directUrl: queryResult.value };
      }┬╖
      // Get current project context
      const webContext = VSS.getWebContext();
      const currentProjectId = webContext.project?.id;
      if (!currentProjectId) {
        throw new Error(\"No project context available\");
      }┬╖
      // Get configured source from settings
      const sourceConfig = await getSourceConfig();┬╖
      // Determine which project to use for artifact access
      const targetProjectId = sourceConfig.projectId || currentProjectId;┬╖
      console.log(
        `Source project: ${targetProjectId}${sourceConfig.projectId ? \" (from settings)\" : \" (current context)\"}`,
      );┬╖
      // Initialize artifact client with target project
      artifactClient = new ArtifactClient(targetProjectId);
      await artifactClient.initialize();┬╖
      // Mode: explicit pipelineId from query
      if (queryResult.mode === \"explicit\") {
        return await resolveFromPipelineId(queryResult.value, targetProjectId);
      }┬╖
      // Check settings for pipeline ID
      if (sourceConfig.pipelineId) {
        console.log(
          `Using pipeline definition ID from settings: ${sourceConfig.pipelineId}`,
        );
        try {
          return await resolveFromPipelineId(
            sourceConfig.pipelineId,
            targetProjectId,
          );
        } catch (error: any) {
          console.warn(
            `Saved pipeline ${sourceConfig.pipelineId} is invalid, falling back to auto-discovery:`,
            error.message,
          );
          await clearStalePipelineSetting();
        }
      }┬╖
      // Mode: discovery in target project
      return await discoverAndResolve(targetProjectId);
    }┬╖
    /**
     * Resolve artifact info from a specific pipeline ID.
     */
    async function resolveFromPipelineId(
      pipelineId: number,
      projectId: string,
    ): Promise<{ buildId: number; artifactName: string }> {
      // Get Build REST client
      const buildClient = await getBuildClient();┬╖
      // Get latest successful build
      const builds = await buildClient.getBuilds(
        projectId,
        [pipelineId],
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined, // reasonFilter
        2, // statusFilter: Completed
        6, // resultFilter: Succeeded (2) | PartiallySucceeded (4)
        undefined,
        undefined,
        1, // top
      );┬╖
      if (!builds || builds.length === 0) {
        const definitions = await buildClient.getDefinitions(
          projectId,
          undefined,
          undefined,
          undefined,
          2,
          undefined,
          undefined,
          undefined,
          [pipelineId],
        );
        const name = definitions?.[0]?.name || `ID ${pipelineId}`;
        throw createNoSuccessfulBuildsError(name);
      }┬╖
      const latestBuild = builds[0];
      if (!latestBuild) throw new Error(\"Failed to retrieve latest build\");┬╖
      // Check for aggregates artifact
      if (!artifactClient) throw new Error(\"ArtifactClient not initialized\");
      const artifacts = await artifactClient.getArtifacts(latestBuild.id);
      const hasAggregates = artifacts.some((a) => a.name === \"aggregates\");┬╖
      if (!hasAggregates) {
        const definitions = await buildClient.getDefinitions(
          projectId,
          undefined,
          undefined,
          undefined,
          2,
          undefined,
          undefined,
          undefined,
          [pipelineId],
        );
        const name = definitions?.[0]?.name || `ID ${pipelineId}`;
        throw createArtifactsMissingError(name, latestBuild.id);
      }┬╖
      return { buildId: latestBuild.id, artifactName: \"aggregates\" };
    }┬╖
    /**
     * Discover pipelines with aggregates and resolve.
     */
    async function discoverAndResolve(
      projectId: string,
    ): Promise<{ buildId: number; artifactName: string }> {
      const matches = await discoverInsightsPipelines(projectId);┬╖
      if (matches.length === 0) {
        throw createSetupRequiredError();
      }┬╖
      const firstMatch = matches[0];
      if (!firstMatch) throw createSetupRequiredError();┬╖
      return { buildId: firstMatch.buildId, artifactName: \"aggregates\" };
    }┬╖
    /**
     * Discover pipelines with aggregates artifact.
     */
    async function discoverInsightsPipelines(
      projectId: string,
    ): Promise<Array<{ id: number; name: string; buildId: number }>> {
      const buildClient = await getBuildClient();
      const matches: Array<{ id: number; name: string; buildId: number }> = [];┬╖
      const definitions = await buildClient.getDefinitions(
        projectId,
        undefined,
        undefined,
        undefined,
        2,
        50,
      );┬╖
      for (const def of definitions) {
        const builds = await buildClient.getBuilds(
          projectId,
          [def.id],
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          2,
          6,
          undefined,
          undefined,
          1,
        );┬╖
        if (!builds || builds.length === 0) continue;┬╖
        const latestBuild = builds[0];
        if (!latestBuild) continue;┬╖
        try {
          if (!artifactClient) throw new Error(\"ArtifactClient not initialized\");
          const artifacts = await artifactClient.getArtifacts(latestBuild.id);
          if (!artifacts.some((a) => a.name === \"aggregates\")) continue;┬╖
          matches.push({
            id: def.id,
            name: def.name,
            buildId: latestBuild.id,
          });
        } catch (e) {
          console.debug(`Skipping pipeline ${def.name}:`, e);
        }
      }┬╖
      return matches;
    }┬╖
    /**
     * Get Build REST client from SDK.
     */
    async function getBuildClient(): Promise<IBuildRestClient> {
      return new Promise((resolve) => {
        VSS.require([\"TFS/Build/RestClient\"], (BuildRestClient: any) => {
          resolve(BuildRestClient.getClient());
        });
      });
    }┬╖
    // ============================================================================
    // Main Initialization
    // ============================================================================┬╖
    /**
     * Check if running in local dashboard mode.
     */
    function isLocalMode(): boolean {
      return (
        typeof window !== \"undefined\" &&
        (window as any).LOCAL_DASHBOARD_MODE === true
      );
    }┬╖
    /**
     * Get local dataset path from window config.
     */
    function getLocalDatasetPath(): string {
      return (
        (typeof window !== \"undefined\" && (window as any).DATASET_PATH) ||
        \"./dataset\"
      );
    }┬╖
    /**
     * Initialize the dashboard.
     */
    async function init(): Promise<void> {
      if (metricsCollector) metricsCollector.mark(\"dashboard-init\");┬╖
      cacheElements();
      setupEventListeners();
      initializePhase5Features();┬╖
      try {
        if (isLocalMode()) {
          console.log(\"[Dashboard] Running in local mode\");
          const datasetPath = getLocalDatasetPath();
          loader = new DatasetLoader(datasetPath);
          currentBuildId = null;┬╖
          const projectNameEl = document.getElementById(\"current-project-name\");
          if (projectNameEl) {
            projectNameEl.textContent = \"Local Dashboard\";
          }┬╖
          const exportRawZip = document.getElementById(\"export-raw-zip\");
          if (exportRawZip) {
            exportRawZip.style.display = \"none\";
          }┬╖
          await loadDataset();
          return;
        }┬╖
        await initializeAdoSdk();
        const config = await resolveConfiguration();┬╖
        if (config.directUrl) {
          loader = new DatasetLoader(config.directUrl);
          currentBuildId = null;
        } else if (config.buildId && config.artifactName && artifactClient) {
          loader = artifactClient.createDatasetLoader(
            config.buildId,
            config.artifactName,
          );
          currentBuildId = config.buildId;
        } else {
          throw new Error(\"Failed to resolve configuration\");
        }┬╖
        await loadDataset();
      } catch (error: any) {
        console.error(\"Dashboard initialization failed:\", error);
        handleError(error);
      }
    }┬╖
    /**
     * Handle errors with appropriate UI panels.
     */
    function handleError(error: any): void {
      hideAllPanels();┬╖
      if (error instanceof PrInsightsError) {
        switch (error.type) {
          case ErrorTypes.SETUP_REQUIRED:
            showSetupRequired(error);
            break;
          case ErrorTypes.MULTIPLE_PIPELINES:
            showMultiplePipelines(error);
            break;
          case ErrorTypes.ARTIFACTS_MISSING:
            showArtifactsMissing(error);
            break;
          case ErrorTypes.PERMISSION_DENIED:
            showPermissionDenied(error);
            break;
          default:
            showGenericError(error.title, error.message);
            break;
        }
      } else {
        showGenericError(\"Error\", error.message || \"An unexpected error occurred\");
      }
    }┬╖
    /**
     * Hide all error/setup panels.
     */
    function hideAllPanels(): void {
      [
        \"setup-required\",
        \"multiple-pipelines\",
        \"artifacts-missing\",
        \"permission-denied\",
        \"error-state\",
        \"loading-state\",
        \"main-content\",
      ].forEach((id) => {
        document.getElementById(id)?.classList.add(\"hidden\");
      });
    }┬╖
    /**
     * Show setup required panel.
     */
    function showSetupRequired(error: PrInsightsError): void {
      const panel = document.getElementById(\"setup-required\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"setup-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      const details = error.details as SetupRequiredDetails;
      if (details?.instructions && Array.isArray(details.instructions)) {
        const stepsList = document.getElementById(\"setup-steps\");
        if (stepsList) {
          stepsList.innerHTML = details.instructions
            .map((s: string) => `<li>${s}</li>`)
            .join(\"\");
        }
      }┬╖
      if (details?.docsUrl) {
        const docsLink = document.getElementById(
          \"docs-link\",
        ) as HTMLAnchorElement | null;
        if (docsLink) docsLink.href = String(details.docsUrl);
      }┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show multiple pipelines panel.
     */
    function showMultiplePipelines(error: PrInsightsError): void {
      const panel = document.getElementById(\"multiple-pipelines\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"multiple-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      const listEl = document.getElementById(\"pipeline-list\");
      const details = error.details as MultiplePipelinesDetails;
      if (listEl && details?.matches && Array.isArray(details.matches)) {
        listEl.innerHTML = details.matches
          .map(
            (m: any) => `
                    <a href=\"?pipelineId=${m.id}\" class=\"pipeline-option\">
                        <strong>${m.name}</strong>
                        <span class=\"pipeline-id\">ID: ${m.id}</span>
                    </a>
                `,
          )
          .join(\"\");
      }┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show permission denied panel.
     */
    function showPermissionDenied(error: PrInsightsError): void {
      const panel = document.getElementById(\"permission-denied\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"permission-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show generic error state.
     */
    function showGenericError(title: string, message: string): void {
      const panel = document.getElementById(\"error-state\");
      if (!panel) return;┬╖
      const titleEl = document.getElementById(\"error-title\");
      const messageEl = document.getElementById(\"error-message\");┬╖
      if (titleEl) titleEl.textContent = title;
      if (messageEl) messageEl.textContent = message;┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show artifacts missing panel.
     */
    function showArtifactsMissing(error: PrInsightsError): void {
      const panel = document.getElementById(\"artifacts-missing\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"missing-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      const details = error.details as ArtifactsMissingDetails;
      if (details?.instructions && Array.isArray(details.instructions)) {
        const stepsList = document.getElementById(\"missing-steps\");
        if (stepsList) {
          stepsList.innerHTML = details.instructions
            .map((s: string) => `<li>${s}</li>`)
            .join(\"\");
        }
      }┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    // ============================================================================
    // DOM and Event Handling
    // ============================================================================┬╖
    /**
     * Cache DOM elements for performance.
     */
    function cacheElements(): void {
      const ids = [
        \"app\",
        \"loading-state\",
        \"error-state\",
        \"main-content\",
        \"error-title\",
        \"error-message\",
        \"run-info\",
        \"date-range\",
        \"custom-dates\",
        \"start-date\",
        \"end-date\",
        \"retry-btn\",
        \"total-prs\",
        \"cycle-p50\",
        \"cycle-p90\",
        \"authors-count\",
        \"reviewers-count\",
        \"throughput-chart\",
        \"cycle-distribution\",
        \"total-prs-delta\",
        \"cycle-p50-delta\",
        \"cycle-p90-delta\",
        \"authors-delta\",
        \"reviewers-delta\",
        \"repo-filter\",
        \"team-filter\",
        \"repo-filter-group\",
        \"team-filter-group\",
        \"clear-filters\",
        \"active-filters\",
        \"filter-chips\",
        \"total-prs-sparkline\",
        \"cycle-p50-sparkline\",
        \"cycle-p90-sparkline\",
        \"authors-sparkline\",
        \"reviewers-sparkline\",
        \"cycle-time-trend\",
        \"reviewer-activity\",
        \"compare-toggle\",
        \"comparison-banner\",
        \"current-period-dates\",
        \"previous-period-dates\",
        \"exit-compare\",
        \"export-btn\",
        \"export-menu\",
        \"export-csv\",
        \"export-link\",
        \"export-raw-zip\",
      ];┬╖
      ids.forEach((id) => {
        elements[id] = document.getElementById(id);
      });┬╖
      elements.tabs = document.querySelectorAll(\".tab\");
    }┬╖
    /**
     * Initialize Phase 5 features.
     */
    function initializePhase5Features(): void {
      const phase5Tabs = document.querySelectorAll(\".phase5-tab\");┬╖
      if (ENABLE_PHASE5_FEATURES) {
        phase5Tabs.forEach((tab) => tab.classList.remove(\"hidden\"));
        console.log(\"Phase 5 features enabled\");
      } else {
        console.log(\"Phase 5 features disabled\");
      }
    }┬╖
    /**
     * Set up event listeners.
     */
    function setupEventListeners(): void {
      elements[\"date-range\"]?.addEventListener(\"change\", handleDateRangeChange);
      document
        .getElementById(\"apply-dates\")
        ?.addEventListener(\"click\", applyCustomDates);┬╖
      elements.tabs?.forEach((tab: HTMLElement) => {
        tab.addEventListener(\"click\", () => {
          const tabId = tab.dataset[\"tab\"];
          if (tabId) switchTab(tabId);
        });
      });┬╖
      elements[\"retry-btn\"]?.addEventListener(\"click\", () => init());
      document
        .getElementById(\"setup-retry-btn\")
        ?.addEventListener(\"click\", () => init());
      document
        .getElementById(\"permission-retry-btn\")
        ?.addEventListener(\"click\", () => init());┬╖
      elements[\"repo-filter\"]?.addEventListener(\"change\", handleFilterChange);
      elements[\"team-filter\"]?.addEventListener(\"change\", handleFilterChange);
      elements[\"clear-filters\"]?.addEventListener(\"click\", clearAllFilters);┬╖
      elements[\"compare-toggle\"]?.addEventListener(\"click\", toggleComparisonMode);
      elements[\"exit-compare\"]?.addEventListener(\"click\", exitComparisonMode);┬╖
      elements[\"export-btn\"]?.addEventListener(\"click\", toggleExportMenu);
      elements[\"export-csv\"]?.addEventListener(\"click\", exportToCsv);
      elements[\"export-link\"]?.addEventListener(\"click\", copyShareableLink);
      elements[\"export-raw-zip\"]?.addEventListener(\"click\", downloadRawDataZip);┬╖
      document.addEventListener(\"click\", (e: MouseEvent) => {
        const target = e.target as HTMLElement;
        if (!target.closest(\".export-dropdown\")) {
          elements[\"export-menu\"]?.classList.add(\"hidden\");
        }
      });
    }┬╖
    // ============================================================================
    // Data Loading and Rendering
    // ============================================================================┬╖
    /**
     * Load the dataset.
     */
    async function loadDataset(): Promise<void> {
      showLoading();┬╖
      try {
        if (!loader) throw new Error(\"Loader not initialized\");┬╖
        // Load manifest first
        const manifest = await loader.loadManifest();┬╖
        // Load dimensions
        const dimensions = await loader.loadDimensions();┬╖
        // Populate filter dropdowns from dimensions
        populateFilterDropdowns(dimensions);┬╖
        // Show dataset info
        updateDatasetInfo(manifest);┬╖
        // Restore state from URL if present
        restoreStateFromUrl();┬╖
        // Set initial date range from manifest defaults
        setInitialDateRange();┬╖
        // Load and render metrics
        await refreshMetrics();┬╖
        // Update feature tabs based on manifest
        await updateFeatureTabs();┬╖
        showContent();
      } catch (error) {
        console.error(\"Failed to load dataset:\", error);
        handleError(error);
      }
    }┬╖
    /**
     * Set initial date range from manifest defaults.
     */
    function setInitialDateRange(): void {
      // Skip if already restored from URL
      if (currentDateRange.start && currentDateRange.end) return;
      if (!loader) return;┬╖
      const coverage = loader.getCoverage() || null;
      const defaultDays = loader.getDefaultRangeDays() || 90;┬╖
      if (coverage?.date_range?.max) {
        const endDate = new Date(coverage.date_range.max);
        const startDate = new Date(endDate);
        startDate.setDate(startDate.getDate() - defaultDays);┬╖
        currentDateRange = { start: startDate, end: endDate };┬╖
        if (elements[\"start-date\"]) {
          elements[\"start-date\"].value = startDate.toISOString().split(\"T\")[0];
        }
        if (elements[\"end-date\"]) {
          elements[\"end-date\"].value = endDate.toISOString().split(\"T\")[0];
        }
      }
    }┬╖
    /**
     * Calculate the previous period date range for comparison.
     */
    function getPreviousPeriod(start: Date, end: Date): { start: Date; end: Date } {
      const durationMs = end.getTime() - start.getTime();
      const prevEnd = new Date(start.getTime() - 1); // Day before current start
      const prevStart = new Date(prevEnd.getTime() - durationMs);
      return { start: prevStart, end: prevEnd };
    }┬╖
    /**
     * Apply dimension filters to rollups data.
     * Uses by_repository slices when available for accurate filtering.
     */
    function applyFiltersToRollups(
      rollups: Rollup[],
      filters: { repos: string[]; teams: string[] },
    ): Rollup[] {
      // No filters active - return original data
      if (!filters.repos.length && !filters.teams.length) {
        return rollups;
      }┬╖
      return rollups.map((rollup) => {
        // If we have by_repository slices and repo filter is active, use them
        if (filters.repos.length && rollup.by_repository) {
          const selectedRepos = filters.repos
            .map((repoId) => {
              const repoData = rollup.by_repository![repoId];
              if (repoData) return repoData;┬╖
              return Object.entries(rollup.by_repository!).find(
                ([name]) => name === repoId,
              )?.[1];
            })
            .filter(Boolean) as any[];┬╖
          if (selectedRepos.length === 0) {
            return {
              ...rollup,
              pr_count: 0,
              cycle_time_p50: null,
              cycle_time_p90: null,
              authors_count: 0,
              reviewers_count: 0,
            };
          }┬╖
          // Aggregate metrics
          const totalPrCount = selectedRepos.reduce(
            (sum, r) => sum + (r.pr_count || 0),
            0,
          );
          const p50Values = selectedRepos
            .map((r) => r.cycle_time_p50)
            .filter((v) => v != null);
          const p90Values = selectedRepos
            .map((r) => r.cycle_time_p90)
            .filter((v) => v != null);┬╖
          const avgP50 =
            p50Values.length > 0
              ? p50Values.reduce((a, b) => a + b, 0) / p50Values.length
              : null;
          const avgP90 =
            p90Values.length > 0
              ? p90Values.reduce((a, b) => a + b, 0) / p90Values.length
              : null;┬╖
          const totalAuthors = selectedRepos.reduce(
            (sum, r) => sum + (r.authors_count || 0),
            0,
          );
          const totalReviewers = selectedRepos.reduce(
            (sum, r) => sum + (r.reviewers_count || 0),
            0,
          );┬╖
          return {
            ...rollup,
            pr_count: totalPrCount,
            cycle_time_p50: avgP50,
            cycle_time_p90: avgP90,
            authors_count: totalAuthors,
            reviewers_count: totalReviewers,
          } as Rollup;
        }┬╖
        // If we have by_team slices and team filter is active, use them
        if (filters.teams.length && rollup.by_team) {
          const selectedTeams = filters.teams
            .map((teamId) => rollup.by_team![teamId])
            .filter(Boolean) as any[];┬╖
          if (selectedTeams.length === 0) {
            return {
              ...rollup,
              pr_count: 0,
              cycle_time_p50: null,
              cycle_time_p90: null,
              authors_count: 0,
              reviewers_count: 0,
            };
          }┬╖
          const totalPrCount = selectedTeams.reduce(
            (sum, t) => sum + (t.pr_count || 0),
            0,
          );
          const p50Values = selectedTeams
            .map((t) => t.cycle_time_p50)
            .filter((v) => v != null);
          const avgP50 =
            p50Values.length > 0
              ? p50Values.reduce((a, b) => a + b, 0) / p50Values.length
              : null;┬╖
          return {
            ...rollup,
            pr_count: totalPrCount,
            cycle_time_p50: avgP50,
          } as Rollup;
        }┬╖
        return rollup;
      });
    }┬╖
    /**
     * Refresh metrics for current date range.
     */
    async function refreshMetrics(): Promise<void> {
      if (!currentDateRange.start || !currentDateRange.end || !loader) return;┬╖
      // Load current period data
      const rawRollups = await loader.getWeeklyRollups(
        currentDateRange.start,
        currentDateRange.end,
      );┬╖
      const distributions = await loader.getDistributions(
        currentDateRange.start,
        currentDateRange.end,
      );┬╖
      // Apply dimension filters to rollups
      const rollups = applyFiltersToRollups(rawRollups, currentFilters);┬╖
      // Load previous period data for comparison
      const prevPeriod = getPreviousPeriod(
        currentDateRange.start,
        currentDateRange.end,
      );
      let prevRollups: Rollup[] = [];
      try {
        const rawPrevRollups = await loader.getWeeklyRollups(
          prevPeriod.start,
          prevPeriod.end,
        );
        prevRollups = applyFiltersToRollups(rawPrevRollups, currentFilters);
      } catch (e) {
        console.debug(\"Previous period data not available:\", e);
      }┬╖
      // Cache filtered rollups for export
      cachedRollups = rollups;┬╖
      renderSummaryCards(rollups, prevRollups);
      renderThroughputChart(rollups);
      renderCycleTimeTrend(rollups);
      renderReviewerActivity(rollups);
      renderCycleDistribution(distributions);┬╖
      // Update comparison banner if in comparison mode
      if (comparisonMode) {
        updateComparisonBanner();
      }
    }┬╖
    interface CalculatedMetrics {
      totalPrs: number;
      cycleP50: number | null;
      cycleP90: number | null;
      avgAuthors: number;
      avgReviewers: number;
    }┬╖
    /**
     * Calculate metrics from rollups data.
     */
    function calculateMetrics(rollups: Rollup[]): CalculatedMetrics {
      if (!rollups || !rollups.length) {
        return {
          totalPrs: 0,
          cycleP50: null,
          cycleP90: null,
          avgAuthors: 0,
          avgReviewers: 0,
        };
      }┬╖
      const totalPrs = rollups.reduce((sum, r) => sum + (r.pr_count || 0), 0);┬╖
      const p50Values = rollups
        .map((r) => r.cycle_time_p50)
        .filter((v): v is number => v !== null && v !== undefined);
      const p90Values = rollups
        .map((r) => r.cycle_time_p90)
        .filter((v): v is number => v !== null && v !== undefined);┬╖
      const authorsSum = rollups.reduce(
        (sum, r) => sum + (r.authors_count || 0),
        0,
      );
      const reviewersSum = rollups.reduce(
        (sum, r) => sum + (r.reviewers_count || 0),
        0,
      );┬╖
      return {
        totalPrs,
        cycleP50: p50Values.length ? median(p50Values) : null,
        cycleP90: p90Values.length ? median(p90Values) : null,
        avgAuthors:
          rollups.length > 0 ? Math.round(authorsSum / rollups.length) : 0,
        avgReviewers:
          rollups.length > 0 ? Math.round(reviewersSum / rollups.length) : 0,
      };
    }┬╖
    /**
     * Calculate percentage change between two values.
     */
    function calculatePercentChange(
      current: number | null | undefined,
      previous: number | null | undefined,
    ): number | null {
      if (previous === null || previous === undefined || previous === 0) {
        return null;
      }
      if (current === null || current === undefined) {
        return null;
      }
      return ((current - previous) / previous) * 100;
    }┬╖
    /**
     * Render a delta indicator element.
     */
    function renderDelta(
      element: HTMLElement | null,
      percentChange: number | null,
      inverse = false,
    ): void {
      if (!element) return;┬╖
      if (percentChange === null) {
        element.innerHTML = \"\";
        element.className = \"metric-delta\";
        return;
      }┬╖
      const isNeutral = Math.abs(percentChange) < 2; // Within 2% is neutral
      const isPositive = percentChange > 0;
      const absChange = Math.abs(percentChange);┬╖
      let cssClass = \"metric-delta \";
      let arrow = \"\";┬╖
      if (isNeutral) {
        cssClass += \"delta-neutral\";
        arrow = \"~\";
      } else if (isPositive) {
        cssClass += inverse ? \"delta-negative-inverse\" : \"delta-positive\";
        arrow = \"&#9650;\"; // Up arrow
      } else {
        cssClass += inverse ? \"delta-positive-inverse\" : \"delta-negative\";
        arrow = \"&#9660;\"; // Down arrow
      }┬╖
      const sign = isPositive ? \"+\" : \"\";
      element.className = cssClass;
      element.innerHTML = `<span class=\"delta-arrow\">${arrow}</span> ${sign}${absChange.toFixed(0)}% <span class=\"delta-label\">vs prev</span>`;
    }┬╖
    /**
     * Render a sparkline SVG from data points.
     */
    function renderSparkline(element: HTMLElement | null, values: number[]): void {
      if (!element || !values || values.length < 2) {
        if (element) element.innerHTML = \"\";
        return;
      }┬╖
      // Take last 8 values for sparkline
      const data = values.slice(-8);
      const width = 60;
      const height = 24;
      const padding = 2;┬╖
      const minVal = Math.min(...data);
      const maxVal = Math.max(...data);
      const range = maxVal - minVal || 1;┬╖
      // Calculate points
      const points = data.map((val, i) => {
        const x = padding + (i / (data.length - 1)) * (width - padding * 2);
        const y =
          height - padding - ((val - minVal) / range) * (height - padding * 2);
        return { x, y };
      });┬╖
      // Create path
      const pathD = points
        .map((p, i) => `${i === 0 ? \"M\" : \"L\"} ${p.x.toFixed(1)} ${p.y.toFixed(1)}`)
        .join(\" \");┬╖
      // Create area path (closed)
      const areaD =
        pathD +
        ` L ${points[points.length - 1]!.x.toFixed(1)} ${height - padding} L ${points[0]!.x.toFixed(1)} ${height - padding} Z`;┬╖
      // Last point for dot
      const lastPoint = points[points.length - 1]!;┬╖
      element.innerHTML = `
            <svg viewBox=\"0 0 ${width} ${height}\" preserveAspectRatio=\"none\">
                <path class=\"sparkline-area\" d=\"${areaD}\"/>
                <path class=\"sparkline-line\" d=\"${pathD}\"/>
                <circle class=\"sparkline-dot\" cx=\"${lastPoint.x.toFixed(1)}\" cy=\"${lastPoint.y.toFixed(1)}\" r=\"2\"/>
            </svg>
        `;
    }┬╖
    /**
     * Extract sparkline data from rollups.
     */
    function extractSparklineData(rollups: Rollup[]): {
      prCounts: number[];
      p50s: number[];
      p90s: number[];
      authors: number[];
      reviewers: number[];
    } {
      if (!rollups || !rollups.length) {
        return { prCounts: [], p50s: [], p90s: [], authors: [], reviewers: [] };
      }┬╖
      return {
        prCounts: rollups.map((r) => r.pr_count || 0),
        p50s: rollups
          .map((r) => r.cycle_time_p50)
          .filter((v): v is number => v !== null && v !== undefined),
        p90s: rollups
          .map((r) => r.cycle_time_p90)
          .filter((v): v is number => v !== null && v !== undefined),
        authors: rollups.map((r) => r.authors_count || 0),
        reviewers: rollups.map((r) => r.reviewers_count || 0),
      };
    }┬╖
    /**
     * Render summary metric cards.
     */
    function renderSummaryCards(
      rollups: Rollup[],
      prevRollups: Rollup[] = [],
    ): void {
      if (metricsCollector) metricsCollector.mark(\"render-summary-cards-start\");┬╖
      const current = calculateMetrics(rollups);
      const previous = calculateMetrics(prevRollups);┬╖
      // Render metric values
      if (elements[\"total-prs\"])
        elements[\"total-prs\"].textContent = current.totalPrs.toLocaleString();
      if (elements[\"cycle-p50\"])
        elements[\"cycle-p50\"].textContent =
          current.cycleP50 !== null ? formatDuration(current.cycleP50) : \"-\";
      if (elements[\"cycle-p90\"])
        elements[\"cycle-p90\"].textContent =
          current.cycleP90 !== null ? formatDuration(current.cycleP90) : \"-\";
      if (elements[\"authors-count\"])
        elements[\"authors-count\"].textContent = current.avgAuthors.toLocaleString();
      if (elements[\"reviewers-count\"]) {
        elements[\"reviewers-count\"].textContent =
          current.avgReviewers.toLocaleString();
      }┬╖
      // Render sparklines
      const sparklineData = extractSparklineData(rollups);
      renderSparkline(elements[\"total-prs-sparkline\"], sparklineData.prCounts);
      renderSparkline(elements[\"cycle-p50-sparkline\"], sparklineData.p50s);
      renderSparkline(elements[\"cycle-p90-sparkline\"], sparklineData.p90s);
      renderSparkline(elements[\"authors-sparkline\"], sparklineData.authors);
      renderSparkline(elements[\"reviewers-sparkline\"], sparklineData.reviewers);┬╖
      // Render deltas (only if we have previous period data)
      if (prevRollups && prevRollups.length > 0) {
        renderDelta(
          elements[\"total-prs-delta\"],
          calculatePercentChange(current.totalPrs, previous.totalPrs),
          false,
        );
        renderDelta(
          elements[\"cycle-p50-delta\"],
          calculatePercentChange(current.cycleP50, previous.cycleP50),
          true,
        ); // Inverse: lower is better
        renderDelta(
          elements[\"cycle-p90-delta\"],
          calculatePercentChange(current.cycleP90, previous.cycleP90),
          true,
        ); // Inverse: lower is better
        renderDelta(
          elements[\"authors-delta\"],
          calculatePercentChange(current.avgAuthors, previous.avgAuthors),
          false,
        );
        renderDelta(
          elements[\"reviewers-delta\"],
          calculatePercentChange(current.avgReviewers, previous.avgReviewers),
          false,
        );
      } else {
        // Clear deltas if no previous data
        [
          \"total-prs-delta\",
          \"cycle-p50-delta\",
          \"cycle-p90-delta\",
          \"authors-delta\",
          \"reviewers-delta\",
        ].forEach((id) => {
          const el = elements[id];
          if (el) {
            el.innerHTML = \"\";
            el.className = \"metric-delta\";
          }
        });
      }┬╖
      if (metricsCollector) {
        metricsCollector.mark(\"render-summary-cards-end\");
        metricsCollector.mark(\"first-meaningful-paint\");
        metricsCollector.measure(
          \"init-to-fmp\",
          \"dashboard-init\",
          \"first-meaningful-paint\",
        );
      }
    }┬╖
    /**
     * Calculate moving average for trend line.
     */
    function calculateMovingAverage(
      values: number[],
      window = 4,
    ): (number | null)[] {
      const result: (number | null)[] = [];
      for (let i = 0; i < values.length; i++) {
        if (i < window - 1) {
          result.push(null);
        } else {
          const sum = values
            .slice(i - window + 1, i + 1)
            .reduce((a, b) => a + b, 0);
          result.push(sum / window);
        }
      }
      return result;
    }┬╖
    /**
     * Render throughput chart with trend line overlay.
     */
    function renderThroughputChart(rollups: Rollup[]): void {
      const chartEl = elements[\"throughput-chart\"];
      if (!chartEl) return;┬╖
      if (!rollups || !rollups.length) {
        chartEl.innerHTML = '<p class=\"no-data\">No data for selected range</p>';
        return;
      }┬╖
      const prCounts = rollups.map((r) => r.pr_count || 0);
      const maxCount = Math.max(...prCounts);
      const movingAvg = calculateMovingAverage(prCounts, 4);┬╖
      // Render bar chart
      const barsHtml = rollups
        .map((r) => {
          const height = maxCount > 0 ? ((r.pr_count || 0) / maxCount) * 100 : 0;
          return `
                <div class=\"bar-container\" title=\"${r.week}: ${r.pr_count || 0} PRs\">
                    <div class=\"bar\" style=\"height: ${height}%\"></div>
                    <div class=\"bar-label\">${r.week.split(\"-W\")[1]}</div>
                </div>
            `;
        })
        .join(\"\");┬╖
      // Render trend line SVG overlay
      let trendLineHtml = \"\";
      if (rollups.length >= 4) {
        const validPoints = movingAvg
          .map((val, i) => ({ val, i }))
          .filter((p): p is { val: number; i: number } => p.val !== null);┬╖
        if (validPoints.length >= 2) {
          const chartHeight = 200;
          const chartPadding = 8;┬╖
          // Calculate SVG path points
          const points = validPoints.map((p) => {
            const x = (p.i / (rollups.length - 1)) * 100;
            const y =
              maxCount > 0
                ? chartHeight -
                  chartPadding -
                  (p.val / maxCount) * (chartHeight - chartPadding * 2)
                : chartHeight / 2;
            return { x, y };
          });┬╖
          const pathD = points
            .map(
              (pt, i) =>
                `${i === 0 ? \"M\" : \"L\"} ${pt.x.toFixed(1)}% ${pt.y.toFixed(1)}`,
            )
            .join(\" \");┬╖
          trendLineHtml = `
                    <div class=\"trend-line-overlay\">
                        <svg viewBox=\"0 0 100 ${chartHeight}\" preserveAspectRatio=\"none\">
                            <path class=\"trend-line\" d=\"${pathD}\" vector-effect=\"non-scaling-stroke\"/>
                        </svg>
                    </div>
                `;
        }
      }┬╖
      // Legend
      const legendHtml = `
            <div class=\"chart-legend\">
                <div class=\"legend-item\">
                    <span class=\"legend-bar\"></span>
                    <span>Weekly PRs</span>
                </div>
                <div class=\"legend-item\">
                    <span class=\"legend-line\"></span>
                    <span>4-week avg</span>
                </div>
            </div>
        `;┬╖
      chartEl.innerHTML = `
            <div class=\"chart-with-trend\">
                <div class=\"bar-chart\">${barsHtml}</div>
                ${trendLineHtml}
            </div>
            ${legendHtml}
        `;
    }┬╖
    /**
     * Render cycle time distribution.
     */
    function renderCycleDistribution(distributions: any[]): void {
      const distEl = elements[\"cycle-distribution\"];
      if (!distEl) return;┬╖
      if (!distributions || !distributions.length) {
        distEl.innerHTML = '<p class=\"no-data\">No data for selected range</p>';
        return;
      }┬╖
      const buckets: Record<string, number> = {
        \"0-1h\": 0,
        \"1-4h\": 0,
        \"4-24h\": 0,
        \"1-3d\": 0,
        \"3-7d\": 0,
        \"7d+\": 0,
      };
      distributions.forEach((d) => {
        Object.entries(d.cycle_time_buckets || {}).forEach(([key, val]) => {
          buckets[key] = (buckets[key] || 0) + (val as number);
        });
      });┬╖
      const total = Object.values(buckets).reduce((a, b) => a + b, 0);
      if (total === 0) {
        distEl.innerHTML = '<p class=\"no-data\">No cycle time data</p>';
        return;
      }┬╖
      const html = Object.entries(buckets)
        .map(([label, count]) => {
          const pct = ((count / total) * 100).toFixed(1);
          return `
                <div class=\"dist-row\">
                    <span class=\"dist-label\">${label}</span>
                    <div class=\"dist-bar-bg\">
                        <div class=\"dist-bar\" style=\"width: ${pct}%\"></div>
                    </div>
                    <span class=\"dist-value\">${count} (${pct}%)</span>
                </div>
            `;
        })
        .join(\"\");┬╖
      distEl.innerHTML = html;
    }┬╖
    /**
     * Render cycle time trend chart (line chart with P50 and P90).
     */
    function renderCycleTimeTrend(rollups: Rollup[]): void {
      const trendEl = elements[\"cycle-time-trend\"];
      if (!trendEl) return;┬╖
      if (!rollups || rollups.length < 2) {
        trendEl.innerHTML = '<p class=\"no-data\">Not enough data for trend</p>';
        return;
      }┬╖
      const p50Data = rollups
        .map((r) => ({ week: r.week, value: r.cycle_time_p50 }))
        .filter((d): d is { week: string; value: number } => d.value !== null);
      const p90Data = rollups
        .map((r) => ({ week: r.week, value: r.cycle_time_p90 }))
        .filter((d): d is { week: string; value: number } => d.value !== null);┬╖
      if (p50Data.length < 2 && p90Data.length < 2) {
        trendEl.innerHTML = '<p class=\"no-data\">No cycle time data available</p>';
        return;
      }┬╖
      const allValues = [
        ...p50Data.map((d) => d.value),
        ...p90Data.map((d) => d.value),
      ];
      const maxVal = Math.max(...allValues);
      const minVal = Math.min(...allValues);
      const range = maxVal - minVal || 1;┬╖
      const width = 100;
      const height = 180;
      const padding = { top: 10, right: 10, bottom: 25, left: 40 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;┬╖
      // Generate paths
      const generatePath = (data: { week: string; value: number }[]) => {
        const points = data.map((d) => {
          const dataIndex = rollups.findIndex((r) => r.week === d.week);
          const x = padding.left + (dataIndex / (rollups.length - 1)) * chartWidth;
          const y =
            padding.top + chartHeight - ((d.value - minVal) / range) * chartHeight;
          return { x, y, week: d.week, value: d.value };
        });
        const pathD = points
          .map(
            (p, i) => `${i === 0 ? \"M\" : \"L\"} ${p.x.toFixed(1)} ${p.y.toFixed(1)}`,
          )
          .join(\" \");
        return { pathD, points };
      };┬╖
      const p50Path = p50Data.length >= 2 ? generatePath(p50Data) : null;
      const p90Path = p90Data.length >= 2 ? generatePath(p90Data) : null;┬╖
      // Y-axis labels
      const yLabels = [minVal, (minVal + maxVal) / 2, maxVal];┬╖
      const svgContent = `
            <svg viewBox=\"0 0 ${width} ${height}\" preserveAspectRatio=\"xMidYMid meet\">
                <!-- Grid lines -->
                ${yLabels
                  .map((val, i) => {
                    const y =
                      padding.top +
                      chartHeight -
                      (i / (yLabels.length - 1)) * chartHeight;
                    return `<line class=\"line-chart-grid\" x1=\"${padding.left}\" y1=\"${y}\" x2=\"${width - padding.right}\" y2=\"${y}\"/>`;
                  })
                  .join(\"\")}┬╖
                <!-- Y-axis labels -->
                ${yLabels
                  .map((val, i) => {
                    const y =
                      padding.top +
                      chartHeight -
                      (i / (yLabels.length - 1)) * chartHeight;
                    return `<text class=\"line-chart-axis\" x=\"${padding.left - 4}\" y=\"${y + 3}\" text-anchor=\"end\">${formatDuration(val)}</text>`;
                  })
                  .join(\"\")}┬╖
                <!-- Lines -->
                ${p90Path ? `<path class=\"line-chart-p90\" d=\"${p90Path.pathD}\" vector-effect=\"non-scaling-stroke\"/>` : \"\"}
                ${p50Path ? `<path class=\"line-chart-p50\" d=\"${p50Path.pathD}\" vector-effect=\"non-scaling-stroke\"/>` : \"\"}┬╖
                <!-- Dots -->
                ${p90Path ? p90Path.points.map((p) => `<circle class=\"line-chart-dot\" cx=\"${p.x}\" cy=\"${p.y}\" r=\"3\" fill=\"var(--warning)\" data-week=\"${p.week}\" data-value=\"${p.value}\" data-metric=\"P90\"/>`).join(\"\") : \"\"}
                ${p50Path ? p50Path.points.map((p) => `<circle class=\"line-chart-dot\" cx=\"${p.x}\" cy=\"${p.y}\" r=\"3\" fill=\"var(--primary)\" data-week=\"${p.week}\" data-value=\"${p.value}\" data-metric=\"P50\"/>`).join(\"\") : \"\"}
            </svg>
        `;┬╖
      const legendHtml = `
            <div class=\"chart-legend\">
                <div class=\"legend-item\">
                    <span class=\"chart-tooltip-dot legend-p50\"></span>
                    <span>P50 (Median)</span>
                </div>
                <div class=\"legend-item\">
                    <span class=\"chart-tooltip-dot legend-p90\"></span>
                    <span>P90</span>
                </div>
            </div>
        `;┬╖
      trendEl.innerHTML = `<div class=\"line-chart\">${svgContent}</div>${legendHtml}`;┬╖
      // Add tooltip interactions
      addChartTooltips(trendEl, (dot: HTMLElement) => {
        const week = dot.dataset[\"week\"];
        const value = parseFloat(dot.dataset[\"value\"] || \"0\");
        const metric = dot.dataset[\"metric\"];
        return `
                <div class=\"chart-tooltip-title\">${week}</div>
                <div class=\"chart-tooltip-row\">
                    <span class=\"chart-tooltip-label\">
                        <span class=\"chart-tooltip-dot ${metric === \"P50\" ? \"legend-p50\" : \"legend-p90\"}\"></span>
                        ${metric}
                    </span>
                    <span>${formatDuration(value)}</span>
                </div>
            `;
      });
    }┬╖
    /**
     * Render reviewer activity chart (horizontal bar chart).
     */
    function renderReviewerActivity(rollups: Rollup[]): void {
      const revEl = elements[\"reviewer-activity\"];
      if (!revEl) return;┬╖
      if (!rollups || !rollups.length) {
        revEl.innerHTML = '<p class=\"no-data\">No reviewer data available</p>';
        return;
      }┬╖
      // Take last 8 weeks for display
      const recentRollups = rollups.slice(-8);
      const maxReviewers = Math.max(
        ...recentRollups.map((r) => r.reviewers_count || 0),
      );┬╖
      if (maxReviewers === 0) {
        revEl.innerHTML = '<p class=\"no-data\">No reviewer data available</p>';
        return;
      }┬╖
      const barsHtml = recentRollups
        .map((r) => {
          const count = r.reviewers_count || 0;
          const pct = (count / maxReviewers) * 100;
          const weekLabel = r.week.split(\"-W\")[1];
          return `
                <div class=\"h-bar-row\" title=\"${r.week}: ${count} reviewers\">
                    <span class=\"h-bar-label\">W${weekLabel}</span>
                    <div class=\"h-bar-container\">
                        <div class=\"h-bar\" style=\"width: ${pct}%\"></div>
                    </div>
                    <span class=\"h-bar-value\">${count}</span>
                </div>
            `;
        })
        .join(\"\");┬╖
      revEl.innerHTML = `<div class=\"horizontal-bar-chart\">${barsHtml}</div>`;
    }┬╖
    /**
     * Add tooltip interactions to a chart.
     */
    function addChartTooltips(
      container: HTMLElement,
      contentFn: (dot: HTMLElement) => string,
    ): void {
      const dots = container.querySelectorAll(\".line-chart-dot\");
      let tooltip: HTMLElement | null = null;┬╖
      dots.forEach((dotNode) => {
        const dot = dotNode as HTMLElement;
        dot.addEventListener(\"mouseenter\", () => {
          if (!tooltip) {
            tooltip = document.createElement(\"div\");
            tooltip.className = \"chart-tooltip\";
            container.appendChild(tooltip);
          }
          tooltip.innerHTML = contentFn(dot);
          tooltip.style.display = \"block\";┬╖
          // Position tooltip
          const rect = container.getBoundingClientRect();
          const dotRect = dot.getBoundingClientRect();
          tooltip.style.left = `${dotRect.left - rect.left + 10}px`;
          tooltip.style.top = `${dotRect.top - rect.top - 40}px`;
        });┬╖
        dot.addEventListener(\"mouseleave\", () => {
          if (tooltip) {
            tooltip.style.display = \"none\";
          }
        });
      });
    }┬╖
    /**
     * Update feature tabs based on manifest.
     */
    async function updateFeatureTabs(): Promise<void> {
      if (!loader) return;┬╖
      // Check if loader supports loadPredictions/loadInsights
      if (typeof (loader as any).loadPredictions !== \"function\") return;┬╖
      const predictionsContent = document.getElementById(\"tab-predictions\");
      const predictionsUnavailable = document.getElementById(
        \"predictions-unavailable\",
      );
      if (predictionsContent) {
        const predictionsResult = await (loader as any).loadPredictions();┬╖
        if (
          predictionsResult?.state === \"ok\" &&
          predictionsResult.data?.forecasts?.length > 0
        ) {
          renderPredictions(predictionsContent, predictionsResult.data);
        } else if (predictionsUnavailable) {
          predictionsUnavailable.classList.remove(\"hidden\");
        }
      }┬╖
      const aiContent = document.getElementById(\"tab-ai-insights\");
      const aiUnavailable = document.getElementById(\"ai-unavailable\");
      if (aiContent) {
        const insightsResult = await (loader as any).loadInsights();┬╖
        if (
          insightsResult?.state === \"ok\" &&
          insightsResult.data?.insights?.length > 0
        ) {
          renderAIInsights(aiContent, insightsResult.data);
        } else if (aiUnavailable) {
          aiUnavailable.classList.remove(\"hidden\");
        }
      }
    }┬╖
    /**
     * Render predictions.
     */
    function renderPredictions(container: HTMLElement, predictions: any): void {
      const content = document.createElement(\"div\");
      content.className = \"predictions-content\";┬╖
      if (predictions.is_stub) {
        content.innerHTML += `<div class=\"stub-warning\">ΓÜá∩╕Å Demo data</div>`;
      }┬╖
      predictions.forecasts.forEach((forecast: any) => {
        const label = forecast.metric
          .replace(/_/g, \" \")
          .replace(/\\b\\w/g, (c: string) => c.toUpperCase());
        content.innerHTML += `
                <div class=\"forecast-section\">
                    <h4>${label} (${forecast.unit})</h4>
                    <table class=\"forecast-table\">
                        <thead><tr><th>Week</th><th>Predicted</th><th>Range</th></tr></thead>
                        <tbody>
                            ${forecast.values
                              .map(
                                (v: any) => `
                                <tr>
                                    <td>${v.period_start}</td>
                                    <td>${v.predicted}</td>
                                    <td>${v.lower_bound} - ${v.upper_bound}</td>
                                </tr>
                            `,
                              )
                              .join(\"\")}
                        </tbody>
                    </table>
                </div>
            `;
      });┬╖
      const unavailable = container.querySelector(\".feature-unavailable\");
      if (unavailable) unavailable.classList.add(\"hidden\");
      container.appendChild(content);
    }┬╖
    /**
     * Render AI insights.
     */
    function renderAIInsights(container: HTMLElement, insights: any): void {
      const content = document.createElement(\"div\");
      content.className = \"insights-content\";┬╖
      if (insights.is_stub) {
        content.innerHTML += `<div class=\"stub-warning\">ΓÜá∩╕Å Demo data</div>`;
      }┬╖
      const icons: Record<string, string> = {
        critical: \"≡ƒö┤\",
        warning: \"≡ƒƒí\",
        info: \"≡ƒö╡\",
      };
      [\"critical\", \"warning\", \"info\"].forEach((severity) => {
        const items = insights.insights.filter((i: any) => i.severity === severity);
        if (!items.length) return;┬╖
        content.innerHTML += `
                <div class=\"severity-section\">
                    <h4>${icons[severity]} ${severity.charAt(0).toUpperCase() + severity.slice(1)}</h4>
                    <div class=\"insight-cards\">
                        ${items
                          .map(
                            (i: any) => `
                            <div class=\"insight-card ${i.severity}\">
                                <div class=\"insight-category\">${i.category}</div>
                                <h5>${i.title}</h5>
                                <p>${i.description}</p>
                            </div>
                        `,
                          )
                          .join(\"\")}
                    </div>
                </div>
            `;
      });┬╖
      const unavailable = container.querySelector(\".feature-unavailable\");
      if (unavailable) unavailable.classList.add(\"hidden\");
      container.appendChild(content);
    }┬╖
    // ============================================================================
    // Event Handlers
    // ============================================================================┬╖
    function handleDateRangeChange(e: Event): void {
      const target = e.target as HTMLSelectElement;
      const value = target.value;┬╖
      if (value === \"custom\") {
        elements[\"custom-dates\"]?.classList.remove(\"hidden\");
        return;
      }┬╖
      elements[\"custom-dates\"]?.classList.add(\"hidden\");┬╖
      const days = parseInt(value, 10);
      const coverage = loader?.getCoverage() || null;
      const endDate = coverage?.date_range?.max
        ? new Date(coverage.date_range.max)
        : new Date();
      const startDate = new Date(endDate);
      startDate.setDate(startDate.getDate() - days);┬╖
      currentDateRange = { start: startDate, end: endDate };
      updateUrlState();
      refreshMetrics();
    }┬╖
    function applyCustomDates(): void {
      const start = (elements[\"start-date\"] as HTMLInputElement)?.value;
      const end = (elements[\"end-date\"] as HTMLInputElement)?.value;┬╖
      if (!start || !end) return;┬╖
      currentDateRange = { start: new Date(start), end: new Date(end) };
      updateUrlState();
      refreshMetrics();
    }┬╖
    function switchTab(tabId: string): void {
      elements.tabs?.forEach((tab: HTMLElement) => {
        tab.classList.toggle(\"active\", tab.dataset[\"tab\"] === tabId);
      });┬╖
      document.querySelectorAll(\".tab-content\").forEach((content) => {
        content.classList.toggle(\"active\", content.id === `tab-${tabId}`);
        content.classList.toggle(\"hidden\", content.id !== `tab-${tabId}`);
      });┬╖
      updateUrlState();
    }┬╖
    // ============================================================================
    // Filter Management
    // ============================================================================┬╖
    /**
     * Populate filter dropdowns from loaded dimensions.
     */
    function populateFilterDropdowns(dimensions: any): void {
      if (!dimensions) return;┬╖
      // Populate repository filter
      const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
      if (repoFilter && dimensions.repositories?.length > 0) {
        repoFilter.innerHTML = '<option value=\"\">All</option>';
        dimensions.repositories.forEach((repo: any) => {
          const option = document.createElement(\"option\");
          option.value = repo.id || repo.name;
          option.textContent = repo.name;
          repoFilter.appendChild(option);
        });
        elements[\"repo-filter-group\"]?.classList.remove(\"hidden\");
      } else {
        elements[\"repo-filter-group\"]?.classList.add(\"hidden\");
      }┬╖
      // Populate team filter
      const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
      if (teamFilter && dimensions.teams?.length > 0) {
        teamFilter.innerHTML = '<option value=\"\">All</option>';
        dimensions.teams.forEach((team: any) => {
          const option = document.createElement(\"option\");
          option.value = team.id || team.name;
          option.textContent = team.name;
          teamFilter.appendChild(option);
        });
        elements[\"team-filter-group\"]?.classList.remove(\"hidden\");
      } else {
        elements[\"team-filter-group\"]?.classList.add(\"hidden\");
      }┬╖
      // Restore filter state from URL
      restoreFiltersFromUrl();
    }┬╖
    /**
     * Handle filter dropdown change.
     */
    function handleFilterChange(): void {
      const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
      const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;┬╖
      const repoValues = repoFilter
        ? Array.from(repoFilter.selectedOptions)
            .map((o) => o.value)
            .filter((v) => v)
        : [];
      const teamValues = teamFilter
        ? Array.from(teamFilter.selectedOptions)
            .map((o) => o.value)
            .filter((v) => v)
        : [];┬╖
      currentFilters = { repos: repoValues, teams: teamValues };┬╖
      updateFilterUI();
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Clear all filters.
     */
    function clearAllFilters(): void {
      currentFilters = { repos: [], teams: [] };┬╖
      const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
      const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;┬╖
      if (repoFilter) {
        Array.from(repoFilter.options).forEach(
          (o) => (o.selected = o.value === \"\"),
        );
      }
      if (teamFilter) {
        Array.from(teamFilter.options).forEach(
          (o) => (o.selected = o.value === \"\"),
        );
      }┬╖
      updateFilterUI();
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Remove a specific filter.
     */
    function removeFilter(type: string, value: string): void {
      if (type === \"repo\") {
        currentFilters.repos = currentFilters.repos.filter((v) => v !== value);
        const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
        if (repoFilter) {
          const option = repoFilter.querySelector(
            `option[value=\"${value}\"]`,
          ) as HTMLOptionElement | null;
          if (option) option.selected = false;
        }
      } else if (type === \"team\") {
        currentFilters.teams = currentFilters.teams.filter((v) => v !== value);
        const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
        if (teamFilter) {
          const option = teamFilter.querySelector(
            `option[value=\"${value}\"]`,
          ) as HTMLOptionElement | null;
          if (option) option.selected = false;
        }
      }┬╖
      updateFilterUI();
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Update filter UI.
     */
    function updateFilterUI(): void {
      const hasFilters =
        currentFilters.repos.length > 0 || currentFilters.teams.length > 0;┬╖
      if (elements[\"clear-filters\"]) {
        elements[\"clear-filters\"].classList.toggle(\"hidden\", !hasFilters);
      }┬╖
      if (elements[\"active-filters\"] && elements[\"filter-chips\"]) {
        elements[\"active-filters\"].classList.toggle(\"hidden\", !hasFilters);┬╖
        if (hasFilters) {
          renderFilterChips();
        } else {
          elements[\"filter-chips\"].innerHTML = \"\";
        }
      }
    }┬╖
    /**
     * Render filter chips for active filters.
     */
    function renderFilterChips(): void {
      const chipsEl = elements[\"filter-chips\"] as HTMLElement | null;
      if (!chipsEl) return;┬╖
      const chips: string[] = [];┬╖
      currentFilters.repos.forEach((value) => {
        const label = getFilterLabel(\"repo\", value);
        chips.push(createFilterChip(\"repo\", value, label));
      });┬╖
      currentFilters.teams.forEach((value) => {
        const label = getFilterLabel(\"team\", value);
        chips.push(createFilterChip(\"team\", value, label));
      });┬╖
      chipsEl.innerHTML = chips.join(\"\");┬╖
      chipsEl.querySelectorAll(\".filter-chip-remove\").forEach((btnNode) => {
        const btn = btnNode as HTMLElement;
        btn.addEventListener(\"click\", () => {
          const type = btn.dataset[\"type\"];
          const val = btn.dataset[\"value\"];
          if (type && val) removeFilter(type, val);
        });
      });
    }┬╖
    /**
     * Get display label for a filter value.
     */
    function getFilterLabel(type: string, value: string): string {
      if (type === \"repo\") {
        const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
        const option = repoFilter?.querySelector(`option[value=\"${value}\"]`);
        return option?.textContent || value;
      }
      if (type === \"team\") {
        const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
        const option = teamFilter?.querySelector(`option[value=\"${value}\"]`);
        return option?.textContent || value;
      }
      return value;
    }┬╖
    /**
     * Create HTML for a filter chip.
     */
    function createFilterChip(type: string, value: string, label: string): string {
      const prefix = type === \"repo\" ? \"repo\" : \"team\";
      return `
            <span class=\"filter-chip\">
                <span class=\"filter-chip-label\">${prefix}: ${label}</span>
                <span class=\"filter-chip-remove\" data-type=\"${type}\" data-value=\"${value}\">&times;</span>
            </span>
        `;
    }┬╖
    /**
     * Restore filters from URL parameters.
     */
    function restoreFiltersFromUrl(): void {
      const params = new URLSearchParams(window.location.search);┬╖
      const reposParam = params.get(\"repos\");
      const teamsParam = params.get(\"teams\");┬╖
      if (reposParam) {
        currentFilters.repos = reposParam.split(\",\").filter((v) => v);
        const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
        if (repoFilter) {
          currentFilters.repos.forEach((value) => {
            const option = repoFilter.querySelector(
              `option[value=\"${value}\"]`,
            ) as HTMLOptionElement | null;
            if (option) option.selected = true;
          });
        }
      }┬╖
      if (teamsParam) {
        currentFilters.teams = teamsParam.split(\",\").filter((v) => v);
        const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
        if (teamFilter) {
          currentFilters.teams.forEach((value) => {
            const option = teamFilter.querySelector(
              `option[value=\"${value}\"]`,
            ) as HTMLOptionElement | null;
            if (option) option.selected = true;
          });
        }
      }┬╖
      updateFilterUI();
    }┬╖
    // ============================================================================
    // Comparison Mode
    // ============================================================================┬╖
    /**
     * Toggle comparison mode on/off.
     */
    function toggleComparisonMode(): void {
      comparisonMode = !comparisonMode;┬╖
      elements[\"compare-toggle\"]?.classList.toggle(\"active\", comparisonMode);
      elements[\"comparison-banner\"]?.classList.toggle(\"hidden\", !comparisonMode);┬╖
      if (comparisonMode) {
        updateComparisonBanner();
      }┬╖
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Exit comparison mode.
     */
    function exitComparisonMode(): void {
      comparisonMode = false;
      elements[\"compare-toggle\"]?.classList.remove(\"active\");
      elements[\"comparison-banner\"]?.classList.add(\"hidden\");
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Update the comparison banner with date ranges.
     */
    function updateComparisonBanner(): void {
      if (!currentDateRange.start || !currentDateRange.end) return;┬╖
      const formatDate = (date: Date) =>
        date.toLocaleDateString(\"en-US\", {
          month: \"short\",
          day: \"numeric\",
          year: \"numeric\",
        });┬╖
      // Current period
      const currentStart = formatDate(currentDateRange.start);
      const currentEnd = formatDate(currentDateRange.end);
      if (elements[\"current-period-dates\"]) {
        elements[\"current-period-dates\"].textContent =
          `${currentStart} - ${currentEnd}`;
      }┬╖
      // Previous period
      const prevPeriod = getPreviousPeriod(
        currentDateRange.start,
        currentDateRange.end,
      );
      const prevStart = formatDate(prevPeriod.start);
      const prevEnd = formatDate(prevPeriod.end);
      if (elements[\"previous-period-dates\"]) {
        elements[\"previous-period-dates\"].textContent = `${prevStart} - ${prevEnd}`;
      }
    }┬╖
    // ============================================================================
    // Export Functions
    // ============================================================================┬╖
    /**
     * Toggle export menu visibility.
     */
    function toggleExportMenu(e: Event): void {
      e.stopPropagation();
      elements[\"export-menu\"]?.classList.toggle(\"hidden\");
    }┬╖
    /**
     * Export current data to CSV.
     */
    function exportToCsv(): void {
      elements[\"export-menu\"]?.classList.add(\"hidden\");┬╖
      if (!cachedRollups || cachedRollups.length === 0) {
        showToast(\"No data to export\", \"error\");
        return;
      }┬╖
      // Build CSV content
      const headers = [
        \"Week\",
        \"Start Date\",
        \"End Date\",
        \"PR Count\",
        \"Cycle Time P50 (min)\",
        \"Cycle Time P90 (min)\",
        \"Authors\",
        \"Reviewers\",
      ];
      const rows = cachedRollups.map((r) => [
        r.week,
        r.start_date || \"\",
        r.end_date || \"\",
        r.pr_count || 0,
        r.cycle_time_p50 != null ? r.cycle_time_p50.toFixed(1) : \"\",
        r.cycle_time_p90 != null ? r.cycle_time_p90.toFixed(1) : \"\",
        r.authors_count || 0,
        r.reviewers_count || 0,
      ]);┬╖
      const csvContent = [headers, ...rows]
        .map((row) => row.map((cell) => `\"${cell}\"`).join(\",\"))
        .join(\"\\n\");┬╖
      // Download file
      const blob = new Blob([csvContent], { type: \"text/csv;charset=utf-8;\" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement(\"a\");
      link.href = url;┬╖
      const dateStr = new Date().toISOString().split(\"T\")[0];
      link.download = `pr-insights-${dateStr}.csv`;┬╖
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);┬╖
      showToast(\"CSV exported successfully\", \"success\");
    }┬╖
    /**
     * Copy shareable link to clipboard.
     */
    async function copyShareableLink(): Promise<void> {
      elements[\"export-menu\"]?.classList.add(\"hidden\");┬╖
      try {
        await navigator.clipboard.writeText(window.location.href);
        showToast(\"Link copied to clipboard\", \"success\");
      } catch (_err) {
        // Fallback
        const textArea = document.createElement(\"textarea\");
        textArea.value = window.location.href;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand(\"copy\");
        document.body.removeChild(textArea);
        showToast(\"Link copied to clipboard\", \"success\");
      }
    }┬╖
    /**
     * Download raw CSV data as a ZIP file.
     */
    async function downloadRawDataZip(): Promise<void> {
      elements[\"export-menu\"]?.classList.add(\"hidden\");┬╖
      if (!currentBuildId || !artifactClient) {
        showToast(\"Raw data not available in direct URL mode\", \"error\");
        return;
      }┬╖
      try {
        showToast(\"Preparing download...\", \"success\");┬╖
        const artifact = await artifactClient.getArtifactMetadata(
          currentBuildId,
          \"csv-output\",
        );┬╖
        if (!artifact) {
          showToast(\"Raw CSV artifact not found in this pipeline run\", \"error\");
          return;
        }┬╖
        const downloadUrl = artifact.resource?.downloadUrl;
        if (!downloadUrl) {
          showToast(\"Download URL not available\", \"error\");
          return;
        }┬╖
        let zipUrl = downloadUrl;
        if (!zipUrl.includes(\"format=zip\")) {
          const separator = zipUrl.includes(\"?\") ? \"&\" : \"?\";
          zipUrl = `${zipUrl}${separator}format=zip`;
        }┬╖
        // Use the protected method from ArtifactClient
        const response = await (artifactClient as any)._authenticatedFetch(zipUrl);┬╖
        if (!response.ok) {
          if (response.status === 403 || response.status === 401) {
            showToast(\"Permission denied to download artifacts\", \"error\");
          } else {
            showToast(`Download failed: ${response.statusText}`, \"error\");
          }
          return;
        }┬╖
        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        const link = document.createElement(\"a\");
        link.href = url;┬╖
        const dateStr = new Date().toISOString().split(\"T\")[0];
        link.download = `pr-insights-raw-data-${dateStr}.zip`;┬╖
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);┬╖
        showToast(\"Download started\", \"success\");
      } catch (err) {
        console.error(\"Failed to download raw data:\", err);
        showToast(\"Failed to download raw data\", \"error\");
      }
    }┬╖
    /**
     * Show a toast notification.
     */
    function showToast(
      message: string,
      type: \"success\" | \"error\" = \"success\",
    ): void {
      const toast = document.createElement(\"div\");
      toast.className = `toast ${type}`;
      toast.textContent = message;
      document.body.appendChild(toast);┬╖
      setTimeout(() => {
        toast.remove();
      }, 3000);
    }┬╖
    // ============================================================================
    // Utility Functions
    // ============================================================================┬╖
    function showLoading(): void {
      hideAllPanels();
      elements[\"loading-state\"]?.classList.remove(\"hidden\");
    }┬╖
    function showContent(): void {
      hideAllPanels();
      elements[\"main-content\"]?.classList.remove(\"hidden\");
    }┬╖
    function updateDatasetInfo(manifest: any): void {
      const generatedAt = manifest?.generated_at
        ? new Date(manifest.generated_at).toLocaleString()
        : \"Unknown\";
      const runId = manifest?.run_id || \"\";┬╖
      const runInfo = elements[\"run-info\"];
      if (runInfo) {
        runInfo.textContent = `Generated: ${generatedAt}`;
        if (runId) runInfo.textContent += ` | Run: ${runId.slice(0, 8)}`;
      }
    }┬╖
    function formatDuration(minutes: number): string {
      if (minutes < 60) return `${Math.round(minutes)}m`;
      if (minutes < 1440) return `${(minutes / 60).toFixed(1)}h`;
      return `${(minutes / 1440).toFixed(1)}d`;
    }┬╖
    function median(arr: number[]): number {
      const sorted = [...arr].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      return sorted.length % 2
        ? sorted[mid]!
        : (sorted[mid - 1]! + sorted[mid]!) / 2;
    }┬╖
    function updateUrlState(): void {
      const params = new URLSearchParams(window.location.search);
      const newParams = new URLSearchParams();┬╖
      // Preserve config params
      if (params.get(\"dataset\")) newParams.set(\"dataset\", params.get(\"dataset\")!);
      if (params.get(\"pipelineId\"))
        newParams.set(\"pipelineId\", params.get(\"pipelineId\")!);┬╖
      // Add date range
      if (currentDateRange.start) {
        newParams.set(\"start\", currentDateRange.start.toISOString().split(\"T\")[0]!);
      }
      if (currentDateRange.end) {
        newParams.set(\"end\", currentDateRange.end.toISOString().split(\"T\")[0]!);
      }┬╖
      // Add active tab
      const activeTab = document.querySelector(\".tab.active\") as HTMLElement | null;
      if (activeTab && activeTab.dataset[\"tab\"] !== \"metrics\") {
        newParams.set(\"tab\", activeTab.dataset[\"tab\"]!);
      }┬╖
      // Add filters
      if (currentFilters.repos.length > 0) {
        newParams.set(\"repos\", currentFilters.repos.join(\",\"));
      }
      if (currentFilters.teams.length > 0) {
        newParams.set(\"teams\", currentFilters.teams.join(\",\"));
      }┬╖
      // Add comparison mode
      if (comparisonMode) {
        newParams.set(\"compare\", \"1\");
      }┬╖
      window.history.replaceState(
        {},
        \"\",
        `${window.location.pathname}?${newParams.toString()}`,
      );
    }┬╖
    function restoreStateFromUrl(): void {
      const params = new URLSearchParams(window.location.search);┬╖
      const startParam = params.get(\"start\");
      const endParam = params.get(\"end\");
      if (startParam && endParam) {
        currentDateRange = { start: new Date(startParam), end: new Date(endParam) };
        const dateRangeEl = elements[\"date-range\"] as HTMLSelectElement | null;
        if (dateRangeEl) {
          dateRangeEl.value = \"custom\";
          elements[\"custom-dates\"]?.classList.remove(\"hidden\");
        }
        if (elements[\"start-date\"]) elements[\"start-date\"].value = startParam;
        if (elements[\"end-date\"]) elements[\"end-date\"].value = endParam;
      }┬╖
      const tabParam = params.get(\"tab\");
      if (tabParam) {
        setTimeout(() => switchTab(tabParam), 0);
      }┬╖
      // Restore comparison mode
      const compareParam = params.get(\"compare\");
      if (compareParam === \"1\") {
        comparisonMode = true;
        elements[\"compare-toggle\"]?.classList.add(\"active\");
        elements[\"comparison-banner\"]?.classList.remove(\"hidden\");
      }
    }┬╖
    // ============================================================================
    // Initialize
    // ============================================================================┬╖
    if (document.readyState === \"loading\") {
      document.addEventListener(\"DOMContentLoaded\", init);
    } else {
      init();
    }
    "

      32 |     it("should have getSourceConfig function that returns both projectId and pipelineId", () => {
      33 |       expect(dashboardCode).toContain("async function getSourceConfig()");
    > 34 |       expect(dashboardCode).toContain(
         |                             ^
      35 |         "const result: { projectId: string | null; pipelineId: number | null } = { projectId: null, pipelineId: null }",
      36 |       );
      37 |     });

      at Object.<anonymous> (tests/cross-project-settings.test.ts:34:29)

  ΓùÅ Cross-Project Settings ΓÇ║ dashboard.ts configuration ΓÇ║ should read project setting with SETTINGS_KEY_PROJECT

    expect(received).toContain(expected) // indexOf

    Expected substring: "SETTINGS_KEY_PROJECT, { scopeType: 'User' }"
    Received string:    "/**
     * PR Insights Dashboard
     *
     * Project-level hub that loads data from pipeline artifacts.
     * Uses Azure DevOps Extension SDK for authentication.
     *
     * Configuration precedence:
     * 1. ?dataset=<url> - Direct URL (DEV ONLY)
     * 2. ?pipelineId=<id> - Query parameter override
     * 3. Extension settings - User-scoped saved preference
     * 4. Auto-discovery - Find pipelines with 'aggregates' artifact
     */┬╖
    import { DatasetLoader, IDatasetLoader, Rollup } from \"./dataset-loader\";
    import { ArtifactClient } from \"./artifact-client\";
    import {
      PrInsightsError,
      ErrorTypes,
      createSetupRequiredError,
      createNoSuccessfulBuildsError,
      createArtifactsMissingError,
      createInvalidConfigError,
      SetupRequiredDetails,
      MultiplePipelinesDetails,
      ArtifactsMissingDetails,
    } from \"./error-types\";┬╖
    // Dashboard state
    let loader: IDatasetLoader | null = null;
    let artifactClient: ArtifactClient | null = null;
    let currentDateRange: { start: Date | null; end: Date | null } = {
      start: null,
      end: null,
    };
    let currentFilters: { repos: string[]; teams: string[] } = {
      repos: [],
      teams: [],
    };
    let comparisonMode = false;
    let cachedRollups: Rollup[] = []; // Cache for export
    let currentBuildId: number | null = null; // Store build ID for raw data download
    let sdkInitialized = false;┬╖
    // Settings keys for extension data storage (must match settings.js)
    const SETTINGS_KEY_PROJECT = \"pr-insights-source-project\";
    const SETTINGS_KEY_PIPELINE = \"pr-insights-pipeline-id\";┬╖
    // Feature flags
    const ENABLE_PHASE5_FEATURES = true;┬╖
    // DOM element cache
    const elements: Record<string, any> = {};┬╖
    /**
     * Phase 4: Production-safe metrics collector
     */
    const IS_PRODUCTION =
      typeof window !== \"undefined\" &&
      (window as any).process?.env?.NODE_ENV === \"production\";
    const DEBUG_ENABLED =
      !IS_PRODUCTION &&
      ((typeof window !== \"undefined\" && (window as any).__DASHBOARD_DEBUG__) ||
        (typeof window !== \"undefined\" &&
          new URLSearchParams(window.location.search).has(\"debug\")));┬╖
    interface PerformanceMetric {
      name: string;
      duration: number;
      timestamp: number;
    }┬╖
    const metricsCollector = DEBUG_ENABLED
      ? {
          marks: new Map<string, number>(),
          measures: [] as PerformanceMetric[],
          mark(name: string) {
            if (!performance || !performance.mark) return;
            try {
              performance.mark(name);
              this.marks.set(name, performance.now());
            } catch (_e) {
              /* ignore */
            }
          },
          measure(name: string, startMark: string, endMark: string) {
            if (!performance || !performance.measure) return;
            try {
              performance.measure(name, startMark, endMark);
              const entries = performance.getEntriesByName(name, \"measure\");
              if (entries.length > 0) {
                const lastEntry = entries[entries.length - 1];
                if (lastEntry) {
                  this.measures.push({
                    name,
                    duration: lastEntry.duration,
                    timestamp: Date.now(),
                  });
                }
              }
            } catch (_e) {
              /* ignore */
            }
          },
          getMetrics() {
            return {
              marks: Array.from(this.marks.entries()).map(([name, time]) => ({
                name,
                time,
              })),
              measures: [...this.measures],
            };
          },
          reset() {
            this.marks.clear();
            this.measures = [];
            if (performance && performance.clearMarks) performance.clearMarks();
            if (performance && performance.clearMeasures)
              performance.clearMeasures();
          },
        }
      : null;┬╖
    if (DEBUG_ENABLED && typeof window !== \"undefined\") {
      (window as any).__dashboardMetrics = metricsCollector;
    }┬╖
    // ============================================================================
    // SDK Initialization
    // ============================================================================┬╖
    /**
     * Initialize Azure DevOps Extension SDK.
     */
    async function initializeAdoSdk(): Promise<void> {
      if (sdkInitialized) return;┬╖
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error(\"Azure DevOps SDK initialization timed out\"));
        }, 10000);┬╖
        VSS.init({
          explicitNotifyLoaded: true,
          usePlatformScripts: true,
          usePlatformStyles: true,
        });┬╖
        VSS.ready(() => {
          clearTimeout(timeout);
          sdkInitialized = true;┬╖
          // Update project name in UI
          const webContext = VSS.getWebContext();
          const projectNameEl = document.getElementById(\"current-project-name\");
          if (projectNameEl && webContext?.project?.name) {
            projectNameEl.textContent = webContext.project.name;
          }┬╖
          VSS.notifyLoadSucceeded();
          resolve();
        });
      });
    }┬╖
    // ============================================================================
    // Configuration Resolution
    // ============================================================================┬╖
    /**
     * Parse and validate query parameters.
     */
    function parseQueryParams():
      | { mode: string; value: any; warning?: string | null }
      | PrInsightsError {
      const params = new URLSearchParams(window.location.search);┬╖
      const datasetUrl = params.get(\"dataset\");
      const pipelineIdStr = params.get(\"pipelineId\");┬╖
      // Check for dataset URL (highest priority)
      if (datasetUrl) {
        // Validate URL
        if (!datasetUrl.startsWith(\"https://\")) {
          return createInvalidConfigError(
            \"dataset\",
            datasetUrl,
            \"Must be a valid HTTPS URL\",
          );
        }┬╖
        // Security warning for non-ADO domains
        const IS_DEV =
          window.location.hostname === \"localhost\" || params.has(\"devMode\");┬╖
        if (!IS_DEV) {
          try {
            const urlHost = new URL(datasetUrl).hostname;
            const isAdoDomain =
              urlHost.endsWith(\"dev.azure.com\") ||
              urlHost.endsWith(\".visualstudio.com\") ||
              urlHost.endsWith(\".azure.com\");
            if (!isAdoDomain) {
              console.warn(
                `SECURITY: ?dataset= URL \"${urlHost}\" is not an Azure DevOps domain. ` +
                  `This parameter is intended for development only.`,
              );
            }
          } catch (_e) {
            return createInvalidConfigError(
              \"dataset\",
              datasetUrl,
              \"Invalid URL format\",
            );
          }
        }┬╖
        let warning: string | null = null;
        if (pipelineIdStr) {
          warning = \"Both dataset and pipelineId specified; using dataset\";
          console.warn(warning);
        }┬╖
        return { mode: \"direct\", value: datasetUrl, warning };
      }┬╖
      // Check for pipelineId
      if (pipelineIdStr) {
        const pipelineId = parseInt(pipelineIdStr, 10);
        if (isNaN(pipelineId) || pipelineId <= 0) {
          return createInvalidConfigError(
            \"pipelineId\",
            pipelineIdStr,
            \"Must be a positive integer\",
          );
        }
        return { mode: \"explicit\", value: pipelineId };
      }┬╖
      return { mode: \"discover\", value: null };
    }┬╖
    /**
     * Get source configuration from extension settings.
     */
    async function getSourceConfig(): Promise<{
      projectId: string | null;
      pipelineId: number | null;
    }> {
      const result: { projectId: string | null; pipelineId: number | null } = {
        projectId: null,
        pipelineId: null,
      };
      try {
        const dataService = await VSS.getService<IExtensionDataService>(
          VSS.ServiceIds.ExtensionData,
        );┬╖
        // Get source project ID
        const savedProjectId = await dataService.getValue<string>(
          SETTINGS_KEY_PROJECT,
          { scopeType: \"User\" },
        );
        if (
          savedProjectId &&
          typeof savedProjectId === \"string\" &&
          savedProjectId.trim()
        ) {
          result.projectId = savedProjectId.trim();
        }┬╖
        // Get pipeline definition ID
        const savedPipelineId = await dataService.getValue<number>(
          SETTINGS_KEY_PIPELINE,
          { scopeType: \"User\" },
        );
        if (
          savedPipelineId &&
          typeof savedPipelineId === \"number\" &&
          savedPipelineId > 0
        ) {
          result.pipelineId = savedPipelineId;
        }
      } catch (e) {
        console.log(\"Could not read extension settings:\", e);
      }
      return result;
    }┬╖
    /**
     * Clear stale pipeline ID setting.
     */
    async function clearStalePipelineSetting(): Promise<void> {
      try {
        const dataService = await VSS.getService<IExtensionDataService>(
          VSS.ServiceIds.ExtensionData,
        );
        await dataService.setValue(SETTINGS_KEY_PIPELINE, null, {
          scopeType: \"User\",
        });
        console.log(\"Cleared stale pipeline setting to re-enable auto-discovery\");
      } catch (e) {
        console.warn(\"Could not clear stale pipeline setting:\", e);
      }
    }┬╖
    /**
     * Resolve configuration using precedence rules.
     */
    async function resolveConfiguration(): Promise<{
      buildId?: number;
      artifactName?: string;
      directUrl?: string;
    }> {
      const queryResult = parseQueryParams();┬╖
      // Check for parsing error
      if (queryResult instanceof PrInsightsError) {
        throw queryResult;
      }┬╖
      // Mode: direct URL
      if (queryResult.mode === \"direct\") {
        return { directUrl: queryResult.value };
      }┬╖
      // Get current project context
      const webContext = VSS.getWebContext();
      const currentProjectId = webContext.project?.id;
      if (!currentProjectId) {
        throw new Error(\"No project context available\");
      }┬╖
      // Get configured source from settings
      const sourceConfig = await getSourceConfig();┬╖
      // Determine which project to use for artifact access
      const targetProjectId = sourceConfig.projectId || currentProjectId;┬╖
      console.log(
        `Source project: ${targetProjectId}${sourceConfig.projectId ? \" (from settings)\" : \" (current context)\"}`,
      );┬╖
      // Initialize artifact client with target project
      artifactClient = new ArtifactClient(targetProjectId);
      await artifactClient.initialize();┬╖
      // Mode: explicit pipelineId from query
      if (queryResult.mode === \"explicit\") {
        return await resolveFromPipelineId(queryResult.value, targetProjectId);
      }┬╖
      // Check settings for pipeline ID
      if (sourceConfig.pipelineId) {
        console.log(
          `Using pipeline definition ID from settings: ${sourceConfig.pipelineId}`,
        );
        try {
          return await resolveFromPipelineId(
            sourceConfig.pipelineId,
            targetProjectId,
          );
        } catch (error: any) {
          console.warn(
            `Saved pipeline ${sourceConfig.pipelineId} is invalid, falling back to auto-discovery:`,
            error.message,
          );
          await clearStalePipelineSetting();
        }
      }┬╖
      // Mode: discovery in target project
      return await discoverAndResolve(targetProjectId);
    }┬╖
    /**
     * Resolve artifact info from a specific pipeline ID.
     */
    async function resolveFromPipelineId(
      pipelineId: number,
      projectId: string,
    ): Promise<{ buildId: number; artifactName: string }> {
      // Get Build REST client
      const buildClient = await getBuildClient();┬╖
      // Get latest successful build
      const builds = await buildClient.getBuilds(
        projectId,
        [pipelineId],
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined, // reasonFilter
        2, // statusFilter: Completed
        6, // resultFilter: Succeeded (2) | PartiallySucceeded (4)
        undefined,
        undefined,
        1, // top
      );┬╖
      if (!builds || builds.length === 0) {
        const definitions = await buildClient.getDefinitions(
          projectId,
          undefined,
          undefined,
          undefined,
          2,
          undefined,
          undefined,
          undefined,
          [pipelineId],
        );
        const name = definitions?.[0]?.name || `ID ${pipelineId}`;
        throw createNoSuccessfulBuildsError(name);
      }┬╖
      const latestBuild = builds[0];
      if (!latestBuild) throw new Error(\"Failed to retrieve latest build\");┬╖
      // Check for aggregates artifact
      if (!artifactClient) throw new Error(\"ArtifactClient not initialized\");
      const artifacts = await artifactClient.getArtifacts(latestBuild.id);
      const hasAggregates = artifacts.some((a) => a.name === \"aggregates\");┬╖
      if (!hasAggregates) {
        const definitions = await buildClient.getDefinitions(
          projectId,
          undefined,
          undefined,
          undefined,
          2,
          undefined,
          undefined,
          undefined,
          [pipelineId],
        );
        const name = definitions?.[0]?.name || `ID ${pipelineId}`;
        throw createArtifactsMissingError(name, latestBuild.id);
      }┬╖
      return { buildId: latestBuild.id, artifactName: \"aggregates\" };
    }┬╖
    /**
     * Discover pipelines with aggregates and resolve.
     */
    async function discoverAndResolve(
      projectId: string,
    ): Promise<{ buildId: number; artifactName: string }> {
      const matches = await discoverInsightsPipelines(projectId);┬╖
      if (matches.length === 0) {
        throw createSetupRequiredError();
      }┬╖
      const firstMatch = matches[0];
      if (!firstMatch) throw createSetupRequiredError();┬╖
      return { buildId: firstMatch.buildId, artifactName: \"aggregates\" };
    }┬╖
    /**
     * Discover pipelines with aggregates artifact.
     */
    async function discoverInsightsPipelines(
      projectId: string,
    ): Promise<Array<{ id: number; name: string; buildId: number }>> {
      const buildClient = await getBuildClient();
      const matches: Array<{ id: number; name: string; buildId: number }> = [];┬╖
      const definitions = await buildClient.getDefinitions(
        projectId,
        undefined,
        undefined,
        undefined,
        2,
        50,
      );┬╖
      for (const def of definitions) {
        const builds = await buildClient.getBuilds(
          projectId,
          [def.id],
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          2,
          6,
          undefined,
          undefined,
          1,
        );┬╖
        if (!builds || builds.length === 0) continue;┬╖
        const latestBuild = builds[0];
        if (!latestBuild) continue;┬╖
        try {
          if (!artifactClient) throw new Error(\"ArtifactClient not initialized\");
          const artifacts = await artifactClient.getArtifacts(latestBuild.id);
          if (!artifacts.some((a) => a.name === \"aggregates\")) continue;┬╖
          matches.push({
            id: def.id,
            name: def.name,
            buildId: latestBuild.id,
          });
        } catch (e) {
          console.debug(`Skipping pipeline ${def.name}:`, e);
        }
      }┬╖
      return matches;
    }┬╖
    /**
     * Get Build REST client from SDK.
     */
    async function getBuildClient(): Promise<IBuildRestClient> {
      return new Promise((resolve) => {
        VSS.require([\"TFS/Build/RestClient\"], (BuildRestClient: any) => {
          resolve(BuildRestClient.getClient());
        });
      });
    }┬╖
    // ============================================================================
    // Main Initialization
    // ============================================================================┬╖
    /**
     * Check if running in local dashboard mode.
     */
    function isLocalMode(): boolean {
      return (
        typeof window !== \"undefined\" &&
        (window as any).LOCAL_DASHBOARD_MODE === true
      );
    }┬╖
    /**
     * Get local dataset path from window config.
     */
    function getLocalDatasetPath(): string {
      return (
        (typeof window !== \"undefined\" && (window as any).DATASET_PATH) ||
        \"./dataset\"
      );
    }┬╖
    /**
     * Initialize the dashboard.
     */
    async function init(): Promise<void> {
      if (metricsCollector) metricsCollector.mark(\"dashboard-init\");┬╖
      cacheElements();
      setupEventListeners();
      initializePhase5Features();┬╖
      try {
        if (isLocalMode()) {
          console.log(\"[Dashboard] Running in local mode\");
          const datasetPath = getLocalDatasetPath();
          loader = new DatasetLoader(datasetPath);
          currentBuildId = null;┬╖
          const projectNameEl = document.getElementById(\"current-project-name\");
          if (projectNameEl) {
            projectNameEl.textContent = \"Local Dashboard\";
          }┬╖
          const exportRawZip = document.getElementById(\"export-raw-zip\");
          if (exportRawZip) {
            exportRawZip.style.display = \"none\";
          }┬╖
          await loadDataset();
          return;
        }┬╖
        await initializeAdoSdk();
        const config = await resolveConfiguration();┬╖
        if (config.directUrl) {
          loader = new DatasetLoader(config.directUrl);
          currentBuildId = null;
        } else if (config.buildId && config.artifactName && artifactClient) {
          loader = artifactClient.createDatasetLoader(
            config.buildId,
            config.artifactName,
          );
          currentBuildId = config.buildId;
        } else {
          throw new Error(\"Failed to resolve configuration\");
        }┬╖
        await loadDataset();
      } catch (error: any) {
        console.error(\"Dashboard initialization failed:\", error);
        handleError(error);
      }
    }┬╖
    /**
     * Handle errors with appropriate UI panels.
     */
    function handleError(error: any): void {
      hideAllPanels();┬╖
      if (error instanceof PrInsightsError) {
        switch (error.type) {
          case ErrorTypes.SETUP_REQUIRED:
            showSetupRequired(error);
            break;
          case ErrorTypes.MULTIPLE_PIPELINES:
            showMultiplePipelines(error);
            break;
          case ErrorTypes.ARTIFACTS_MISSING:
            showArtifactsMissing(error);
            break;
          case ErrorTypes.PERMISSION_DENIED:
            showPermissionDenied(error);
            break;
          default:
            showGenericError(error.title, error.message);
            break;
        }
      } else {
        showGenericError(\"Error\", error.message || \"An unexpected error occurred\");
      }
    }┬╖
    /**
     * Hide all error/setup panels.
     */
    function hideAllPanels(): void {
      [
        \"setup-required\",
        \"multiple-pipelines\",
        \"artifacts-missing\",
        \"permission-denied\",
        \"error-state\",
        \"loading-state\",
        \"main-content\",
      ].forEach((id) => {
        document.getElementById(id)?.classList.add(\"hidden\");
      });
    }┬╖
    /**
     * Show setup required panel.
     */
    function showSetupRequired(error: PrInsightsError): void {
      const panel = document.getElementById(\"setup-required\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"setup-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      const details = error.details as SetupRequiredDetails;
      if (details?.instructions && Array.isArray(details.instructions)) {
        const stepsList = document.getElementById(\"setup-steps\");
        if (stepsList) {
          stepsList.innerHTML = details.instructions
            .map((s: string) => `<li>${s}</li>`)
            .join(\"\");
        }
      }┬╖
      if (details?.docsUrl) {
        const docsLink = document.getElementById(
          \"docs-link\",
        ) as HTMLAnchorElement | null;
        if (docsLink) docsLink.href = String(details.docsUrl);
      }┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show multiple pipelines panel.
     */
    function showMultiplePipelines(error: PrInsightsError): void {
      const panel = document.getElementById(\"multiple-pipelines\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"multiple-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      const listEl = document.getElementById(\"pipeline-list\");
      const details = error.details as MultiplePipelinesDetails;
      if (listEl && details?.matches && Array.isArray(details.matches)) {
        listEl.innerHTML = details.matches
          .map(
            (m: any) => `
                    <a href=\"?pipelineId=${m.id}\" class=\"pipeline-option\">
                        <strong>${m.name}</strong>
                        <span class=\"pipeline-id\">ID: ${m.id}</span>
                    </a>
                `,
          )
          .join(\"\");
      }┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show permission denied panel.
     */
    function showPermissionDenied(error: PrInsightsError): void {
      const panel = document.getElementById(\"permission-denied\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"permission-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show generic error state.
     */
    function showGenericError(title: string, message: string): void {
      const panel = document.getElementById(\"error-state\");
      if (!panel) return;┬╖
      const titleEl = document.getElementById(\"error-title\");
      const messageEl = document.getElementById(\"error-message\");┬╖
      if (titleEl) titleEl.textContent = title;
      if (messageEl) messageEl.textContent = message;┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show artifacts missing panel.
     */
    function showArtifactsMissing(error: PrInsightsError): void {
      const panel = document.getElementById(\"artifacts-missing\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"missing-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      const details = error.details as ArtifactsMissingDetails;
      if (details?.instructions && Array.isArray(details.instructions)) {
        const stepsList = document.getElementById(\"missing-steps\");
        if (stepsList) {
          stepsList.innerHTML = details.instructions
            .map((s: string) => `<li>${s}</li>`)
            .join(\"\");
        }
      }┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    // ============================================================================
    // DOM and Event Handling
    // ============================================================================┬╖
    /**
     * Cache DOM elements for performance.
     */
    function cacheElements(): void {
      const ids = [
        \"app\",
        \"loading-state\",
        \"error-state\",
        \"main-content\",
        \"error-title\",
        \"error-message\",
        \"run-info\",
        \"date-range\",
        \"custom-dates\",
        \"start-date\",
        \"end-date\",
        \"retry-btn\",
        \"total-prs\",
        \"cycle-p50\",
        \"cycle-p90\",
        \"authors-count\",
        \"reviewers-count\",
        \"throughput-chart\",
        \"cycle-distribution\",
        \"total-prs-delta\",
        \"cycle-p50-delta\",
        \"cycle-p90-delta\",
        \"authors-delta\",
        \"reviewers-delta\",
        \"repo-filter\",
        \"team-filter\",
        \"repo-filter-group\",
        \"team-filter-group\",
        \"clear-filters\",
        \"active-filters\",
        \"filter-chips\",
        \"total-prs-sparkline\",
        \"cycle-p50-sparkline\",
        \"cycle-p90-sparkline\",
        \"authors-sparkline\",
        \"reviewers-sparkline\",
        \"cycle-time-trend\",
        \"reviewer-activity\",
        \"compare-toggle\",
        \"comparison-banner\",
        \"current-period-dates\",
        \"previous-period-dates\",
        \"exit-compare\",
        \"export-btn\",
        \"export-menu\",
        \"export-csv\",
        \"export-link\",
        \"export-raw-zip\",
      ];┬╖
      ids.forEach((id) => {
        elements[id] = document.getElementById(id);
      });┬╖
      elements.tabs = document.querySelectorAll(\".tab\");
    }┬╖
    /**
     * Initialize Phase 5 features.
     */
    function initializePhase5Features(): void {
      const phase5Tabs = document.querySelectorAll(\".phase5-tab\");┬╖
      if (ENABLE_PHASE5_FEATURES) {
        phase5Tabs.forEach((tab) => tab.classList.remove(\"hidden\"));
        console.log(\"Phase 5 features enabled\");
      } else {
        console.log(\"Phase 5 features disabled\");
      }
    }┬╖
    /**
     * Set up event listeners.
     */
    function setupEventListeners(): void {
      elements[\"date-range\"]?.addEventListener(\"change\", handleDateRangeChange);
      document
        .getElementById(\"apply-dates\")
        ?.addEventListener(\"click\", applyCustomDates);┬╖
      elements.tabs?.forEach((tab: HTMLElement) => {
        tab.addEventListener(\"click\", () => {
          const tabId = tab.dataset[\"tab\"];
          if (tabId) switchTab(tabId);
        });
      });┬╖
      elements[\"retry-btn\"]?.addEventListener(\"click\", () => init());
      document
        .getElementById(\"setup-retry-btn\")
        ?.addEventListener(\"click\", () => init());
      document
        .getElementById(\"permission-retry-btn\")
        ?.addEventListener(\"click\", () => init());┬╖
      elements[\"repo-filter\"]?.addEventListener(\"change\", handleFilterChange);
      elements[\"team-filter\"]?.addEventListener(\"change\", handleFilterChange);
      elements[\"clear-filters\"]?.addEventListener(\"click\", clearAllFilters);┬╖
      elements[\"compare-toggle\"]?.addEventListener(\"click\", toggleComparisonMode);
      elements[\"exit-compare\"]?.addEventListener(\"click\", exitComparisonMode);┬╖
      elements[\"export-btn\"]?.addEventListener(\"click\", toggleExportMenu);
      elements[\"export-csv\"]?.addEventListener(\"click\", exportToCsv);
      elements[\"export-link\"]?.addEventListener(\"click\", copyShareableLink);
      elements[\"export-raw-zip\"]?.addEventListener(\"click\", downloadRawDataZip);┬╖
      document.addEventListener(\"click\", (e: MouseEvent) => {
        const target = e.target as HTMLElement;
        if (!target.closest(\".export-dropdown\")) {
          elements[\"export-menu\"]?.classList.add(\"hidden\");
        }
      });
    }┬╖
    // ============================================================================
    // Data Loading and Rendering
    // ============================================================================┬╖
    /**
     * Load the dataset.
     */
    async function loadDataset(): Promise<void> {
      showLoading();┬╖
      try {
        if (!loader) throw new Error(\"Loader not initialized\");┬╖
        // Load manifest first
        const manifest = await loader.loadManifest();┬╖
        // Load dimensions
        const dimensions = await loader.loadDimensions();┬╖
        // Populate filter dropdowns from dimensions
        populateFilterDropdowns(dimensions);┬╖
        // Show dataset info
        updateDatasetInfo(manifest);┬╖
        // Restore state from URL if present
        restoreStateFromUrl();┬╖
        // Set initial date range from manifest defaults
        setInitialDateRange();┬╖
        // Load and render metrics
        await refreshMetrics();┬╖
        // Update feature tabs based on manifest
        await updateFeatureTabs();┬╖
        showContent();
      } catch (error) {
        console.error(\"Failed to load dataset:\", error);
        handleError(error);
      }
    }┬╖
    /**
     * Set initial date range from manifest defaults.
     */
    function setInitialDateRange(): void {
      // Skip if already restored from URL
      if (currentDateRange.start && currentDateRange.end) return;
      if (!loader) return;┬╖
      const coverage = loader.getCoverage() || null;
      const defaultDays = loader.getDefaultRangeDays() || 90;┬╖
      if (coverage?.date_range?.max) {
        const endDate = new Date(coverage.date_range.max);
        const startDate = new Date(endDate);
        startDate.setDate(startDate.getDate() - defaultDays);┬╖
        currentDateRange = { start: startDate, end: endDate };┬╖
        if (elements[\"start-date\"]) {
          elements[\"start-date\"].value = startDate.toISOString().split(\"T\")[0];
        }
        if (elements[\"end-date\"]) {
          elements[\"end-date\"].value = endDate.toISOString().split(\"T\")[0];
        }
      }
    }┬╖
    /**
     * Calculate the previous period date range for comparison.
     */
    function getPreviousPeriod(start: Date, end: Date): { start: Date; end: Date } {
      const durationMs = end.getTime() - start.getTime();
      const prevEnd = new Date(start.getTime() - 1); // Day before current start
      const prevStart = new Date(prevEnd.getTime() - durationMs);
      return { start: prevStart, end: prevEnd };
    }┬╖
    /**
     * Apply dimension filters to rollups data.
     * Uses by_repository slices when available for accurate filtering.
     */
    function applyFiltersToRollups(
      rollups: Rollup[],
      filters: { repos: string[]; teams: string[] },
    ): Rollup[] {
      // No filters active - return original data
      if (!filters.repos.length && !filters.teams.length) {
        return rollups;
      }┬╖
      return rollups.map((rollup) => {
        // If we have by_repository slices and repo filter is active, use them
        if (filters.repos.length && rollup.by_repository) {
          const selectedRepos = filters.repos
            .map((repoId) => {
              const repoData = rollup.by_repository![repoId];
              if (repoData) return repoData;┬╖
              return Object.entries(rollup.by_repository!).find(
                ([name]) => name === repoId,
              )?.[1];
            })
            .filter(Boolean) as any[];┬╖
          if (selectedRepos.length === 0) {
            return {
              ...rollup,
              pr_count: 0,
              cycle_time_p50: null,
              cycle_time_p90: null,
              authors_count: 0,
              reviewers_count: 0,
            };
          }┬╖
          // Aggregate metrics
          const totalPrCount = selectedRepos.reduce(
            (sum, r) => sum + (r.pr_count || 0),
            0,
          );
          const p50Values = selectedRepos
            .map((r) => r.cycle_time_p50)
            .filter((v) => v != null);
          const p90Values = selectedRepos
            .map((r) => r.cycle_time_p90)
            .filter((v) => v != null);┬╖
          const avgP50 =
            p50Values.length > 0
              ? p50Values.reduce((a, b) => a + b, 0) / p50Values.length
              : null;
          const avgP90 =
            p90Values.length > 0
              ? p90Values.reduce((a, b) => a + b, 0) / p90Values.length
              : null;┬╖
          const totalAuthors = selectedRepos.reduce(
            (sum, r) => sum + (r.authors_count || 0),
            0,
          );
          const totalReviewers = selectedRepos.reduce(
            (sum, r) => sum + (r.reviewers_count || 0),
            0,
          );┬╖
          return {
            ...rollup,
            pr_count: totalPrCount,
            cycle_time_p50: avgP50,
            cycle_time_p90: avgP90,
            authors_count: totalAuthors,
            reviewers_count: totalReviewers,
          } as Rollup;
        }┬╖
        // If we have by_team slices and team filter is active, use them
        if (filters.teams.length && rollup.by_team) {
          const selectedTeams = filters.teams
            .map((teamId) => rollup.by_team![teamId])
            .filter(Boolean) as any[];┬╖
          if (selectedTeams.length === 0) {
            return {
              ...rollup,
              pr_count: 0,
              cycle_time_p50: null,
              cycle_time_p90: null,
              authors_count: 0,
              reviewers_count: 0,
            };
          }┬╖
          const totalPrCount = selectedTeams.reduce(
            (sum, t) => sum + (t.pr_count || 0),
            0,
          );
          const p50Values = selectedTeams
            .map((t) => t.cycle_time_p50)
            .filter((v) => v != null);
          const avgP50 =
            p50Values.length > 0
              ? p50Values.reduce((a, b) => a + b, 0) / p50Values.length
              : null;┬╖
          return {
            ...rollup,
            pr_count: totalPrCount,
            cycle_time_p50: avgP50,
          } as Rollup;
        }┬╖
        return rollup;
      });
    }┬╖
    /**
     * Refresh metrics for current date range.
     */
    async function refreshMetrics(): Promise<void> {
      if (!currentDateRange.start || !currentDateRange.end || !loader) return;┬╖
      // Load current period data
      const rawRollups = await loader.getWeeklyRollups(
        currentDateRange.start,
        currentDateRange.end,
      );┬╖
      const distributions = await loader.getDistributions(
        currentDateRange.start,
        currentDateRange.end,
      );┬╖
      // Apply dimension filters to rollups
      const rollups = applyFiltersToRollups(rawRollups, currentFilters);┬╖
      // Load previous period data for comparison
      const prevPeriod = getPreviousPeriod(
        currentDateRange.start,
        currentDateRange.end,
      );
      let prevRollups: Rollup[] = [];
      try {
        const rawPrevRollups = await loader.getWeeklyRollups(
          prevPeriod.start,
          prevPeriod.end,
        );
        prevRollups = applyFiltersToRollups(rawPrevRollups, currentFilters);
      } catch (e) {
        console.debug(\"Previous period data not available:\", e);
      }┬╖
      // Cache filtered rollups for export
      cachedRollups = rollups;┬╖
      renderSummaryCards(rollups, prevRollups);
      renderThroughputChart(rollups);
      renderCycleTimeTrend(rollups);
      renderReviewerActivity(rollups);
      renderCycleDistribution(distributions);┬╖
      // Update comparison banner if in comparison mode
      if (comparisonMode) {
        updateComparisonBanner();
      }
    }┬╖
    interface CalculatedMetrics {
      totalPrs: number;
      cycleP50: number | null;
      cycleP90: number | null;
      avgAuthors: number;
      avgReviewers: number;
    }┬╖
    /**
     * Calculate metrics from rollups data.
     */
    function calculateMetrics(rollups: Rollup[]): CalculatedMetrics {
      if (!rollups || !rollups.length) {
        return {
          totalPrs: 0,
          cycleP50: null,
          cycleP90: null,
          avgAuthors: 0,
          avgReviewers: 0,
        };
      }┬╖
      const totalPrs = rollups.reduce((sum, r) => sum + (r.pr_count || 0), 0);┬╖
      const p50Values = rollups
        .map((r) => r.cycle_time_p50)
        .filter((v): v is number => v !== null && v !== undefined);
      const p90Values = rollups
        .map((r) => r.cycle_time_p90)
        .filter((v): v is number => v !== null && v !== undefined);┬╖
      const authorsSum = rollups.reduce(
        (sum, r) => sum + (r.authors_count || 0),
        0,
      );
      const reviewersSum = rollups.reduce(
        (sum, r) => sum + (r.reviewers_count || 0),
        0,
      );┬╖
      return {
        totalPrs,
        cycleP50: p50Values.length ? median(p50Values) : null,
        cycleP90: p90Values.length ? median(p90Values) : null,
        avgAuthors:
          rollups.length > 0 ? Math.round(authorsSum / rollups.length) : 0,
        avgReviewers:
          rollups.length > 0 ? Math.round(reviewersSum / rollups.length) : 0,
      };
    }┬╖
    /**
     * Calculate percentage change between two values.
     */
    function calculatePercentChange(
      current: number | null | undefined,
      previous: number | null | undefined,
    ): number | null {
      if (previous === null || previous === undefined || previous === 0) {
        return null;
      }
      if (current === null || current === undefined) {
        return null;
      }
      return ((current - previous) / previous) * 100;
    }┬╖
    /**
     * Render a delta indicator element.
     */
    function renderDelta(
      element: HTMLElement | null,
      percentChange: number | null,
      inverse = false,
    ): void {
      if (!element) return;┬╖
      if (percentChange === null) {
        element.innerHTML = \"\";
        element.className = \"metric-delta\";
        return;
      }┬╖
      const isNeutral = Math.abs(percentChange) < 2; // Within 2% is neutral
      const isPositive = percentChange > 0;
      const absChange = Math.abs(percentChange);┬╖
      let cssClass = \"metric-delta \";
      let arrow = \"\";┬╖
      if (isNeutral) {
        cssClass += \"delta-neutral\";
        arrow = \"~\";
      } else if (isPositive) {
        cssClass += inverse ? \"delta-negative-inverse\" : \"delta-positive\";
        arrow = \"&#9650;\"; // Up arrow
      } else {
        cssClass += inverse ? \"delta-positive-inverse\" : \"delta-negative\";
        arrow = \"&#9660;\"; // Down arrow
      }┬╖
      const sign = isPositive ? \"+\" : \"\";
      element.className = cssClass;
      element.innerHTML = `<span class=\"delta-arrow\">${arrow}</span> ${sign}${absChange.toFixed(0)}% <span class=\"delta-label\">vs prev</span>`;
    }┬╖
    /**
     * Render a sparkline SVG from data points.
     */
    function renderSparkline(element: HTMLElement | null, values: number[]): void {
      if (!element || !values || values.length < 2) {
        if (element) element.innerHTML = \"\";
        return;
      }┬╖
      // Take last 8 values for sparkline
      const data = values.slice(-8);
      const width = 60;
      const height = 24;
      const padding = 2;┬╖
      const minVal = Math.min(...data);
      const maxVal = Math.max(...data);
      const range = maxVal - minVal || 1;┬╖
      // Calculate points
      const points = data.map((val, i) => {
        const x = padding + (i / (data.length - 1)) * (width - padding * 2);
        const y =
          height - padding - ((val - minVal) / range) * (height - padding * 2);
        return { x, y };
      });┬╖
      // Create path
      const pathD = points
        .map((p, i) => `${i === 0 ? \"M\" : \"L\"} ${p.x.toFixed(1)} ${p.y.toFixed(1)}`)
        .join(\" \");┬╖
      // Create area path (closed)
      const areaD =
        pathD +
        ` L ${points[points.length - 1]!.x.toFixed(1)} ${height - padding} L ${points[0]!.x.toFixed(1)} ${height - padding} Z`;┬╖
      // Last point for dot
      const lastPoint = points[points.length - 1]!;┬╖
      element.innerHTML = `
            <svg viewBox=\"0 0 ${width} ${height}\" preserveAspectRatio=\"none\">
                <path class=\"sparkline-area\" d=\"${areaD}\"/>
                <path class=\"sparkline-line\" d=\"${pathD}\"/>
                <circle class=\"sparkline-dot\" cx=\"${lastPoint.x.toFixed(1)}\" cy=\"${lastPoint.y.toFixed(1)}\" r=\"2\"/>
            </svg>
        `;
    }┬╖
    /**
     * Extract sparkline data from rollups.
     */
    function extractSparklineData(rollups: Rollup[]): {
      prCounts: number[];
      p50s: number[];
      p90s: number[];
      authors: number[];
      reviewers: number[];
    } {
      if (!rollups || !rollups.length) {
        return { prCounts: [], p50s: [], p90s: [], authors: [], reviewers: [] };
      }┬╖
      return {
        prCounts: rollups.map((r) => r.pr_count || 0),
        p50s: rollups
          .map((r) => r.cycle_time_p50)
          .filter((v): v is number => v !== null && v !== undefined),
        p90s: rollups
          .map((r) => r.cycle_time_p90)
          .filter((v): v is number => v !== null && v !== undefined),
        authors: rollups.map((r) => r.authors_count || 0),
        reviewers: rollups.map((r) => r.reviewers_count || 0),
      };
    }┬╖
    /**
     * Render summary metric cards.
     */
    function renderSummaryCards(
      rollups: Rollup[],
      prevRollups: Rollup[] = [],
    ): void {
      if (metricsCollector) metricsCollector.mark(\"render-summary-cards-start\");┬╖
      const current = calculateMetrics(rollups);
      const previous = calculateMetrics(prevRollups);┬╖
      // Render metric values
      if (elements[\"total-prs\"])
        elements[\"total-prs\"].textContent = current.totalPrs.toLocaleString();
      if (elements[\"cycle-p50\"])
        elements[\"cycle-p50\"].textContent =
          current.cycleP50 !== null ? formatDuration(current.cycleP50) : \"-\";
      if (elements[\"cycle-p90\"])
        elements[\"cycle-p90\"].textContent =
          current.cycleP90 !== null ? formatDuration(current.cycleP90) : \"-\";
      if (elements[\"authors-count\"])
        elements[\"authors-count\"].textContent = current.avgAuthors.toLocaleString();
      if (elements[\"reviewers-count\"]) {
        elements[\"reviewers-count\"].textContent =
          current.avgReviewers.toLocaleString();
      }┬╖
      // Render sparklines
      const sparklineData = extractSparklineData(rollups);
      renderSparkline(elements[\"total-prs-sparkline\"], sparklineData.prCounts);
      renderSparkline(elements[\"cycle-p50-sparkline\"], sparklineData.p50s);
      renderSparkline(elements[\"cycle-p90-sparkline\"], sparklineData.p90s);
      renderSparkline(elements[\"authors-sparkline\"], sparklineData.authors);
      renderSparkline(elements[\"reviewers-sparkline\"], sparklineData.reviewers);┬╖
      // Render deltas (only if we have previous period data)
      if (prevRollups && prevRollups.length > 0) {
        renderDelta(
          elements[\"total-prs-delta\"],
          calculatePercentChange(current.totalPrs, previous.totalPrs),
          false,
        );
        renderDelta(
          elements[\"cycle-p50-delta\"],
          calculatePercentChange(current.cycleP50, previous.cycleP50),
          true,
        ); // Inverse: lower is better
        renderDelta(
          elements[\"cycle-p90-delta\"],
          calculatePercentChange(current.cycleP90, previous.cycleP90),
          true,
        ); // Inverse: lower is better
        renderDelta(
          elements[\"authors-delta\"],
          calculatePercentChange(current.avgAuthors, previous.avgAuthors),
          false,
        );
        renderDelta(
          elements[\"reviewers-delta\"],
          calculatePercentChange(current.avgReviewers, previous.avgReviewers),
          false,
        );
      } else {
        // Clear deltas if no previous data
        [
          \"total-prs-delta\",
          \"cycle-p50-delta\",
          \"cycle-p90-delta\",
          \"authors-delta\",
          \"reviewers-delta\",
        ].forEach((id) => {
          const el = elements[id];
          if (el) {
            el.innerHTML = \"\";
            el.className = \"metric-delta\";
          }
        });
      }┬╖
      if (metricsCollector) {
        metricsCollector.mark(\"render-summary-cards-end\");
        metricsCollector.mark(\"first-meaningful-paint\");
        metricsCollector.measure(
          \"init-to-fmp\",
          \"dashboard-init\",
          \"first-meaningful-paint\",
        );
      }
    }┬╖
    /**
     * Calculate moving average for trend line.
     */
    function calculateMovingAverage(
      values: number[],
      window = 4,
    ): (number | null)[] {
      const result: (number | null)[] = [];
      for (let i = 0; i < values.length; i++) {
        if (i < window - 1) {
          result.push(null);
        } else {
          const sum = values
            .slice(i - window + 1, i + 1)
            .reduce((a, b) => a + b, 0);
          result.push(sum / window);
        }
      }
      return result;
    }┬╖
    /**
     * Render throughput chart with trend line overlay.
     */
    function renderThroughputChart(rollups: Rollup[]): void {
      const chartEl = elements[\"throughput-chart\"];
      if (!chartEl) return;┬╖
      if (!rollups || !rollups.length) {
        chartEl.innerHTML = '<p class=\"no-data\">No data for selected range</p>';
        return;
      }┬╖
      const prCounts = rollups.map((r) => r.pr_count || 0);
      const maxCount = Math.max(...prCounts);
      const movingAvg = calculateMovingAverage(prCounts, 4);┬╖
      // Render bar chart
      const barsHtml = rollups
        .map((r) => {
          const height = maxCount > 0 ? ((r.pr_count || 0) / maxCount) * 100 : 0;
          return `
                <div class=\"bar-container\" title=\"${r.week}: ${r.pr_count || 0} PRs\">
                    <div class=\"bar\" style=\"height: ${height}%\"></div>
                    <div class=\"bar-label\">${r.week.split(\"-W\")[1]}</div>
                </div>
            `;
        })
        .join(\"\");┬╖
      // Render trend line SVG overlay
      let trendLineHtml = \"\";
      if (rollups.length >= 4) {
        const validPoints = movingAvg
          .map((val, i) => ({ val, i }))
          .filter((p): p is { val: number; i: number } => p.val !== null);┬╖
        if (validPoints.length >= 2) {
          const chartHeight = 200;
          const chartPadding = 8;┬╖
          // Calculate SVG path points
          const points = validPoints.map((p) => {
            const x = (p.i / (rollups.length - 1)) * 100;
            const y =
              maxCount > 0
                ? chartHeight -
                  chartPadding -
                  (p.val / maxCount) * (chartHeight - chartPadding * 2)
                : chartHeight / 2;
            return { x, y };
          });┬╖
          const pathD = points
            .map(
              (pt, i) =>
                `${i === 0 ? \"M\" : \"L\"} ${pt.x.toFixed(1)}% ${pt.y.toFixed(1)}`,
            )
            .join(\" \");┬╖
          trendLineHtml = `
                    <div class=\"trend-line-overlay\">
                        <svg viewBox=\"0 0 100 ${chartHeight}\" preserveAspectRatio=\"none\">
                            <path class=\"trend-line\" d=\"${pathD}\" vector-effect=\"non-scaling-stroke\"/>
                        </svg>
                    </div>
                `;
        }
      }┬╖
      // Legend
      const legendHtml = `
            <div class=\"chart-legend\">
                <div class=\"legend-item\">
                    <span class=\"legend-bar\"></span>
                    <span>Weekly PRs</span>
                </div>
                <div class=\"legend-item\">
                    <span class=\"legend-line\"></span>
                    <span>4-week avg</span>
                </div>
            </div>
        `;┬╖
      chartEl.innerHTML = `
            <div class=\"chart-with-trend\">
                <div class=\"bar-chart\">${barsHtml}</div>
                ${trendLineHtml}
            </div>
            ${legendHtml}
        `;
    }┬╖
    /**
     * Render cycle time distribution.
     */
    function renderCycleDistribution(distributions: any[]): void {
      const distEl = elements[\"cycle-distribution\"];
      if (!distEl) return;┬╖
      if (!distributions || !distributions.length) {
        distEl.innerHTML = '<p class=\"no-data\">No data for selected range</p>';
        return;
      }┬╖
      const buckets: Record<string, number> = {
        \"0-1h\": 0,
        \"1-4h\": 0,
        \"4-24h\": 0,
        \"1-3d\": 0,
        \"3-7d\": 0,
        \"7d+\": 0,
      };
      distributions.forEach((d) => {
        Object.entries(d.cycle_time_buckets || {}).forEach(([key, val]) => {
          buckets[key] = (buckets[key] || 0) + (val as number);
        });
      });┬╖
      const total = Object.values(buckets).reduce((a, b) => a + b, 0);
      if (total === 0) {
        distEl.innerHTML = '<p class=\"no-data\">No cycle time data</p>';
        return;
      }┬╖
      const html = Object.entries(buckets)
        .map(([label, count]) => {
          const pct = ((count / total) * 100).toFixed(1);
          return `
                <div class=\"dist-row\">
                    <span class=\"dist-label\">${label}</span>
                    <div class=\"dist-bar-bg\">
                        <div class=\"dist-bar\" style=\"width: ${pct}%\"></div>
                    </div>
                    <span class=\"dist-value\">${count} (${pct}%)</span>
                </div>
            `;
        })
        .join(\"\");┬╖
      distEl.innerHTML = html;
    }┬╖
    /**
     * Render cycle time trend chart (line chart with P50 and P90).
     */
    function renderCycleTimeTrend(rollups: Rollup[]): void {
      const trendEl = elements[\"cycle-time-trend\"];
      if (!trendEl) return;┬╖
      if (!rollups || rollups.length < 2) {
        trendEl.innerHTML = '<p class=\"no-data\">Not enough data for trend</p>';
        return;
      }┬╖
      const p50Data = rollups
        .map((r) => ({ week: r.week, value: r.cycle_time_p50 }))
        .filter((d): d is { week: string; value: number } => d.value !== null);
      const p90Data = rollups
        .map((r) => ({ week: r.week, value: r.cycle_time_p90 }))
        .filter((d): d is { week: string; value: number } => d.value !== null);┬╖
      if (p50Data.length < 2 && p90Data.length < 2) {
        trendEl.innerHTML = '<p class=\"no-data\">No cycle time data available</p>';
        return;
      }┬╖
      const allValues = [
        ...p50Data.map((d) => d.value),
        ...p90Data.map((d) => d.value),
      ];
      const maxVal = Math.max(...allValues);
      const minVal = Math.min(...allValues);
      const range = maxVal - minVal || 1;┬╖
      const width = 100;
      const height = 180;
      const padding = { top: 10, right: 10, bottom: 25, left: 40 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;┬╖
      // Generate paths
      const generatePath = (data: { week: string; value: number }[]) => {
        const points = data.map((d) => {
          const dataIndex = rollups.findIndex((r) => r.week === d.week);
          const x = padding.left + (dataIndex / (rollups.length - 1)) * chartWidth;
          const y =
            padding.top + chartHeight - ((d.value - minVal) / range) * chartHeight;
          return { x, y, week: d.week, value: d.value };
        });
        const pathD = points
          .map(
            (p, i) => `${i === 0 ? \"M\" : \"L\"} ${p.x.toFixed(1)} ${p.y.toFixed(1)}`,
          )
          .join(\" \");
        return { pathD, points };
      };┬╖
      const p50Path = p50Data.length >= 2 ? generatePath(p50Data) : null;
      const p90Path = p90Data.length >= 2 ? generatePath(p90Data) : null;┬╖
      // Y-axis labels
      const yLabels = [minVal, (minVal + maxVal) / 2, maxVal];┬╖
      const svgContent = `
            <svg viewBox=\"0 0 ${width} ${height}\" preserveAspectRatio=\"xMidYMid meet\">
                <!-- Grid lines -->
                ${yLabels
                  .map((val, i) => {
                    const y =
                      padding.top +
                      chartHeight -
                      (i / (yLabels.length - 1)) * chartHeight;
                    return `<line class=\"line-chart-grid\" x1=\"${padding.left}\" y1=\"${y}\" x2=\"${width - padding.right}\" y2=\"${y}\"/>`;
                  })
                  .join(\"\")}┬╖
                <!-- Y-axis labels -->
                ${yLabels
                  .map((val, i) => {
                    const y =
                      padding.top +
                      chartHeight -
                      (i / (yLabels.length - 1)) * chartHeight;
                    return `<text class=\"line-chart-axis\" x=\"${padding.left - 4}\" y=\"${y + 3}\" text-anchor=\"end\">${formatDuration(val)}</text>`;
                  })
                  .join(\"\")}┬╖
                <!-- Lines -->
                ${p90Path ? `<path class=\"line-chart-p90\" d=\"${p90Path.pathD}\" vector-effect=\"non-scaling-stroke\"/>` : \"\"}
                ${p50Path ? `<path class=\"line-chart-p50\" d=\"${p50Path.pathD}\" vector-effect=\"non-scaling-stroke\"/>` : \"\"}┬╖
                <!-- Dots -->
                ${p90Path ? p90Path.points.map((p) => `<circle class=\"line-chart-dot\" cx=\"${p.x}\" cy=\"${p.y}\" r=\"3\" fill=\"var(--warning)\" data-week=\"${p.week}\" data-value=\"${p.value}\" data-metric=\"P90\"/>`).join(\"\") : \"\"}
                ${p50Path ? p50Path.points.map((p) => `<circle class=\"line-chart-dot\" cx=\"${p.x}\" cy=\"${p.y}\" r=\"3\" fill=\"var(--primary)\" data-week=\"${p.week}\" data-value=\"${p.value}\" data-metric=\"P50\"/>`).join(\"\") : \"\"}
            </svg>
        `;┬╖
      const legendHtml = `
            <div class=\"chart-legend\">
                <div class=\"legend-item\">
                    <span class=\"chart-tooltip-dot legend-p50\"></span>
                    <span>P50 (Median)</span>
                </div>
                <div class=\"legend-item\">
                    <span class=\"chart-tooltip-dot legend-p90\"></span>
                    <span>P90</span>
                </div>
            </div>
        `;┬╖
      trendEl.innerHTML = `<div class=\"line-chart\">${svgContent}</div>${legendHtml}`;┬╖
      // Add tooltip interactions
      addChartTooltips(trendEl, (dot: HTMLElement) => {
        const week = dot.dataset[\"week\"];
        const value = parseFloat(dot.dataset[\"value\"] || \"0\");
        const metric = dot.dataset[\"metric\"];
        return `
                <div class=\"chart-tooltip-title\">${week}</div>
                <div class=\"chart-tooltip-row\">
                    <span class=\"chart-tooltip-label\">
                        <span class=\"chart-tooltip-dot ${metric === \"P50\" ? \"legend-p50\" : \"legend-p90\"}\"></span>
                        ${metric}
                    </span>
                    <span>${formatDuration(value)}</span>
                </div>
            `;
      });
    }┬╖
    /**
     * Render reviewer activity chart (horizontal bar chart).
     */
    function renderReviewerActivity(rollups: Rollup[]): void {
      const revEl = elements[\"reviewer-activity\"];
      if (!revEl) return;┬╖
      if (!rollups || !rollups.length) {
        revEl.innerHTML = '<p class=\"no-data\">No reviewer data available</p>';
        return;
      }┬╖
      // Take last 8 weeks for display
      const recentRollups = rollups.slice(-8);
      const maxReviewers = Math.max(
        ...recentRollups.map((r) => r.reviewers_count || 0),
      );┬╖
      if (maxReviewers === 0) {
        revEl.innerHTML = '<p class=\"no-data\">No reviewer data available</p>';
        return;
      }┬╖
      const barsHtml = recentRollups
        .map((r) => {
          const count = r.reviewers_count || 0;
          const pct = (count / maxReviewers) * 100;
          const weekLabel = r.week.split(\"-W\")[1];
          return `
                <div class=\"h-bar-row\" title=\"${r.week}: ${count} reviewers\">
                    <span class=\"h-bar-label\">W${weekLabel}</span>
                    <div class=\"h-bar-container\">
                        <div class=\"h-bar\" style=\"width: ${pct}%\"></div>
                    </div>
                    <span class=\"h-bar-value\">${count}</span>
                </div>
            `;
        })
        .join(\"\");┬╖
      revEl.innerHTML = `<div class=\"horizontal-bar-chart\">${barsHtml}</div>`;
    }┬╖
    /**
     * Add tooltip interactions to a chart.
     */
    function addChartTooltips(
      container: HTMLElement,
      contentFn: (dot: HTMLElement) => string,
    ): void {
      const dots = container.querySelectorAll(\".line-chart-dot\");
      let tooltip: HTMLElement | null = null;┬╖
      dots.forEach((dotNode) => {
        const dot = dotNode as HTMLElement;
        dot.addEventListener(\"mouseenter\", () => {
          if (!tooltip) {
            tooltip = document.createElement(\"div\");
            tooltip.className = \"chart-tooltip\";
            container.appendChild(tooltip);
          }
          tooltip.innerHTML = contentFn(dot);
          tooltip.style.display = \"block\";┬╖
          // Position tooltip
          const rect = container.getBoundingClientRect();
          const dotRect = dot.getBoundingClientRect();
          tooltip.style.left = `${dotRect.left - rect.left + 10}px`;
          tooltip.style.top = `${dotRect.top - rect.top - 40}px`;
        });┬╖
        dot.addEventListener(\"mouseleave\", () => {
          if (tooltip) {
            tooltip.style.display = \"none\";
          }
        });
      });
    }┬╖
    /**
     * Update feature tabs based on manifest.
     */
    async function updateFeatureTabs(): Promise<void> {
      if (!loader) return;┬╖
      // Check if loader supports loadPredictions/loadInsights
      if (typeof (loader as any).loadPredictions !== \"function\") return;┬╖
      const predictionsContent = document.getElementById(\"tab-predictions\");
      const predictionsUnavailable = document.getElementById(
        \"predictions-unavailable\",
      );
      if (predictionsContent) {
        const predictionsResult = await (loader as any).loadPredictions();┬╖
        if (
          predictionsResult?.state === \"ok\" &&
          predictionsResult.data?.forecasts?.length > 0
        ) {
          renderPredictions(predictionsContent, predictionsResult.data);
        } else if (predictionsUnavailable) {
          predictionsUnavailable.classList.remove(\"hidden\");
        }
      }┬╖
      const aiContent = document.getElementById(\"tab-ai-insights\");
      const aiUnavailable = document.getElementById(\"ai-unavailable\");
      if (aiContent) {
        const insightsResult = await (loader as any).loadInsights();┬╖
        if (
          insightsResult?.state === \"ok\" &&
          insightsResult.data?.insights?.length > 0
        ) {
          renderAIInsights(aiContent, insightsResult.data);
        } else if (aiUnavailable) {
          aiUnavailable.classList.remove(\"hidden\");
        }
      }
    }┬╖
    /**
     * Render predictions.
     */
    function renderPredictions(container: HTMLElement, predictions: any): void {
      const content = document.createElement(\"div\");
      content.className = \"predictions-content\";┬╖
      if (predictions.is_stub) {
        content.innerHTML += `<div class=\"stub-warning\">ΓÜá∩╕Å Demo data</div>`;
      }┬╖
      predictions.forecasts.forEach((forecast: any) => {
        const label = forecast.metric
          .replace(/_/g, \" \")
          .replace(/\\b\\w/g, (c: string) => c.toUpperCase());
        content.innerHTML += `
                <div class=\"forecast-section\">
                    <h4>${label} (${forecast.unit})</h4>
                    <table class=\"forecast-table\">
                        <thead><tr><th>Week</th><th>Predicted</th><th>Range</th></tr></thead>
                        <tbody>
                            ${forecast.values
                              .map(
                                (v: any) => `
                                <tr>
                                    <td>${v.period_start}</td>
                                    <td>${v.predicted}</td>
                                    <td>${v.lower_bound} - ${v.upper_bound}</td>
                                </tr>
                            `,
                              )
                              .join(\"\")}
                        </tbody>
                    </table>
                </div>
            `;
      });┬╖
      const unavailable = container.querySelector(\".feature-unavailable\");
      if (unavailable) unavailable.classList.add(\"hidden\");
      container.appendChild(content);
    }┬╖
    /**
     * Render AI insights.
     */
    function renderAIInsights(container: HTMLElement, insights: any): void {
      const content = document.createElement(\"div\");
      content.className = \"insights-content\";┬╖
      if (insights.is_stub) {
        content.innerHTML += `<div class=\"stub-warning\">ΓÜá∩╕Å Demo data</div>`;
      }┬╖
      const icons: Record<string, string> = {
        critical: \"≡ƒö┤\",
        warning: \"≡ƒƒí\",
        info: \"≡ƒö╡\",
      };
      [\"critical\", \"warning\", \"info\"].forEach((severity) => {
        const items = insights.insights.filter((i: any) => i.severity === severity);
        if (!items.length) return;┬╖
        content.innerHTML += `
                <div class=\"severity-section\">
                    <h4>${icons[severity]} ${severity.charAt(0).toUpperCase() + severity.slice(1)}</h4>
                    <div class=\"insight-cards\">
                        ${items
                          .map(
                            (i: any) => `
                            <div class=\"insight-card ${i.severity}\">
                                <div class=\"insight-category\">${i.category}</div>
                                <h5>${i.title}</h5>
                                <p>${i.description}</p>
                            </div>
                        `,
                          )
                          .join(\"\")}
                    </div>
                </div>
            `;
      });┬╖
      const unavailable = container.querySelector(\".feature-unavailable\");
      if (unavailable) unavailable.classList.add(\"hidden\");
      container.appendChild(content);
    }┬╖
    // ============================================================================
    // Event Handlers
    // ============================================================================┬╖
    function handleDateRangeChange(e: Event): void {
      const target = e.target as HTMLSelectElement;
      const value = target.value;┬╖
      if (value === \"custom\") {
        elements[\"custom-dates\"]?.classList.remove(\"hidden\");
        return;
      }┬╖
      elements[\"custom-dates\"]?.classList.add(\"hidden\");┬╖
      const days = parseInt(value, 10);
      const coverage = loader?.getCoverage() || null;
      const endDate = coverage?.date_range?.max
        ? new Date(coverage.date_range.max)
        : new Date();
      const startDate = new Date(endDate);
      startDate.setDate(startDate.getDate() - days);┬╖
      currentDateRange = { start: startDate, end: endDate };
      updateUrlState();
      refreshMetrics();
    }┬╖
    function applyCustomDates(): void {
      const start = (elements[\"start-date\"] as HTMLInputElement)?.value;
      const end = (elements[\"end-date\"] as HTMLInputElement)?.value;┬╖
      if (!start || !end) return;┬╖
      currentDateRange = { start: new Date(start), end: new Date(end) };
      updateUrlState();
      refreshMetrics();
    }┬╖
    function switchTab(tabId: string): void {
      elements.tabs?.forEach((tab: HTMLElement) => {
        tab.classList.toggle(\"active\", tab.dataset[\"tab\"] === tabId);
      });┬╖
      document.querySelectorAll(\".tab-content\").forEach((content) => {
        content.classList.toggle(\"active\", content.id === `tab-${tabId}`);
        content.classList.toggle(\"hidden\", content.id !== `tab-${tabId}`);
      });┬╖
      updateUrlState();
    }┬╖
    // ============================================================================
    // Filter Management
    // ============================================================================┬╖
    /**
     * Populate filter dropdowns from loaded dimensions.
     */
    function populateFilterDropdowns(dimensions: any): void {
      if (!dimensions) return;┬╖
      // Populate repository filter
      const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
      if (repoFilter && dimensions.repositories?.length > 0) {
        repoFilter.innerHTML = '<option value=\"\">All</option>';
        dimensions.repositories.forEach((repo: any) => {
          const option = document.createElement(\"option\");
          option.value = repo.id || repo.name;
          option.textContent = repo.name;
          repoFilter.appendChild(option);
        });
        elements[\"repo-filter-group\"]?.classList.remove(\"hidden\");
      } else {
        elements[\"repo-filter-group\"]?.classList.add(\"hidden\");
      }┬╖
      // Populate team filter
      const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
      if (teamFilter && dimensions.teams?.length > 0) {
        teamFilter.innerHTML = '<option value=\"\">All</option>';
        dimensions.teams.forEach((team: any) => {
          const option = document.createElement(\"option\");
          option.value = team.id || team.name;
          option.textContent = team.name;
          teamFilter.appendChild(option);
        });
        elements[\"team-filter-group\"]?.classList.remove(\"hidden\");
      } else {
        elements[\"team-filter-group\"]?.classList.add(\"hidden\");
      }┬╖
      // Restore filter state from URL
      restoreFiltersFromUrl();
    }┬╖
    /**
     * Handle filter dropdown change.
     */
    function handleFilterChange(): void {
      const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
      const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;┬╖
      const repoValues = repoFilter
        ? Array.from(repoFilter.selectedOptions)
            .map((o) => o.value)
            .filter((v) => v)
        : [];
      const teamValues = teamFilter
        ? Array.from(teamFilter.selectedOptions)
            .map((o) => o.value)
            .filter((v) => v)
        : [];┬╖
      currentFilters = { repos: repoValues, teams: teamValues };┬╖
      updateFilterUI();
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Clear all filters.
     */
    function clearAllFilters(): void {
      currentFilters = { repos: [], teams: [] };┬╖
      const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
      const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;┬╖
      if (repoFilter) {
        Array.from(repoFilter.options).forEach(
          (o) => (o.selected = o.value === \"\"),
        );
      }
      if (teamFilter) {
        Array.from(teamFilter.options).forEach(
          (o) => (o.selected = o.value === \"\"),
        );
      }┬╖
      updateFilterUI();
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Remove a specific filter.
     */
    function removeFilter(type: string, value: string): void {
      if (type === \"repo\") {
        currentFilters.repos = currentFilters.repos.filter((v) => v !== value);
        const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
        if (repoFilter) {
          const option = repoFilter.querySelector(
            `option[value=\"${value}\"]`,
          ) as HTMLOptionElement | null;
          if (option) option.selected = false;
        }
      } else if (type === \"team\") {
        currentFilters.teams = currentFilters.teams.filter((v) => v !== value);
        const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
        if (teamFilter) {
          const option = teamFilter.querySelector(
            `option[value=\"${value}\"]`,
          ) as HTMLOptionElement | null;
          if (option) option.selected = false;
        }
      }┬╖
      updateFilterUI();
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Update filter UI.
     */
    function updateFilterUI(): void {
      const hasFilters =
        currentFilters.repos.length > 0 || currentFilters.teams.length > 0;┬╖
      if (elements[\"clear-filters\"]) {
        elements[\"clear-filters\"].classList.toggle(\"hidden\", !hasFilters);
      }┬╖
      if (elements[\"active-filters\"] && elements[\"filter-chips\"]) {
        elements[\"active-filters\"].classList.toggle(\"hidden\", !hasFilters);┬╖
        if (hasFilters) {
          renderFilterChips();
        } else {
          elements[\"filter-chips\"].innerHTML = \"\";
        }
      }
    }┬╖
    /**
     * Render filter chips for active filters.
     */
    function renderFilterChips(): void {
      const chipsEl = elements[\"filter-chips\"] as HTMLElement | null;
      if (!chipsEl) return;┬╖
      const chips: string[] = [];┬╖
      currentFilters.repos.forEach((value) => {
        const label = getFilterLabel(\"repo\", value);
        chips.push(createFilterChip(\"repo\", value, label));
      });┬╖
      currentFilters.teams.forEach((value) => {
        const label = getFilterLabel(\"team\", value);
        chips.push(createFilterChip(\"team\", value, label));
      });┬╖
      chipsEl.innerHTML = chips.join(\"\");┬╖
      chipsEl.querySelectorAll(\".filter-chip-remove\").forEach((btnNode) => {
        const btn = btnNode as HTMLElement;
        btn.addEventListener(\"click\", () => {
          const type = btn.dataset[\"type\"];
          const val = btn.dataset[\"value\"];
          if (type && val) removeFilter(type, val);
        });
      });
    }┬╖
    /**
     * Get display label for a filter value.
     */
    function getFilterLabel(type: string, value: string): string {
      if (type === \"repo\") {
        const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
        const option = repoFilter?.querySelector(`option[value=\"${value}\"]`);
        return option?.textContent || value;
      }
      if (type === \"team\") {
        const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
        const option = teamFilter?.querySelector(`option[value=\"${value}\"]`);
        return option?.textContent || value;
      }
      return value;
    }┬╖
    /**
     * Create HTML for a filter chip.
     */
    function createFilterChip(type: string, value: string, label: string): string {
      const prefix = type === \"repo\" ? \"repo\" : \"team\";
      return `
            <span class=\"filter-chip\">
                <span class=\"filter-chip-label\">${prefix}: ${label}</span>
                <span class=\"filter-chip-remove\" data-type=\"${type}\" data-value=\"${value}\">&times;</span>
            </span>
        `;
    }┬╖
    /**
     * Restore filters from URL parameters.
     */
    function restoreFiltersFromUrl(): void {
      const params = new URLSearchParams(window.location.search);┬╖
      const reposParam = params.get(\"repos\");
      const teamsParam = params.get(\"teams\");┬╖
      if (reposParam) {
        currentFilters.repos = reposParam.split(\",\").filter((v) => v);
        const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
        if (repoFilter) {
          currentFilters.repos.forEach((value) => {
            const option = repoFilter.querySelector(
              `option[value=\"${value}\"]`,
            ) as HTMLOptionElement | null;
            if (option) option.selected = true;
          });
        }
      }┬╖
      if (teamsParam) {
        currentFilters.teams = teamsParam.split(\",\").filter((v) => v);
        const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
        if (teamFilter) {
          currentFilters.teams.forEach((value) => {
            const option = teamFilter.querySelector(
              `option[value=\"${value}\"]`,
            ) as HTMLOptionElement | null;
            if (option) option.selected = true;
          });
        }
      }┬╖
      updateFilterUI();
    }┬╖
    // ============================================================================
    // Comparison Mode
    // ============================================================================┬╖
    /**
     * Toggle comparison mode on/off.
     */
    function toggleComparisonMode(): void {
      comparisonMode = !comparisonMode;┬╖
      elements[\"compare-toggle\"]?.classList.toggle(\"active\", comparisonMode);
      elements[\"comparison-banner\"]?.classList.toggle(\"hidden\", !comparisonMode);┬╖
      if (comparisonMode) {
        updateComparisonBanner();
      }┬╖
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Exit comparison mode.
     */
    function exitComparisonMode(): void {
      comparisonMode = false;
      elements[\"compare-toggle\"]?.classList.remove(\"active\");
      elements[\"comparison-banner\"]?.classList.add(\"hidden\");
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Update the comparison banner with date ranges.
     */
    function updateComparisonBanner(): void {
      if (!currentDateRange.start || !currentDateRange.end) return;┬╖
      const formatDate = (date: Date) =>
        date.toLocaleDateString(\"en-US\", {
          month: \"short\",
          day: \"numeric\",
          year: \"numeric\",
        });┬╖
      // Current period
      const currentStart = formatDate(currentDateRange.start);
      const currentEnd = formatDate(currentDateRange.end);
      if (elements[\"current-period-dates\"]) {
        elements[\"current-period-dates\"].textContent =
          `${currentStart} - ${currentEnd}`;
      }┬╖
      // Previous period
      const prevPeriod = getPreviousPeriod(
        currentDateRange.start,
        currentDateRange.end,
      );
      const prevStart = formatDate(prevPeriod.start);
      const prevEnd = formatDate(prevPeriod.end);
      if (elements[\"previous-period-dates\"]) {
        elements[\"previous-period-dates\"].textContent = `${prevStart} - ${prevEnd}`;
      }
    }┬╖
    // ============================================================================
    // Export Functions
    // ============================================================================┬╖
    /**
     * Toggle export menu visibility.
     */
    function toggleExportMenu(e: Event): void {
      e.stopPropagation();
      elements[\"export-menu\"]?.classList.toggle(\"hidden\");
    }┬╖
    /**
     * Export current data to CSV.
     */
    function exportToCsv(): void {
      elements[\"export-menu\"]?.classList.add(\"hidden\");┬╖
      if (!cachedRollups || cachedRollups.length === 0) {
        showToast(\"No data to export\", \"error\");
        return;
      }┬╖
      // Build CSV content
      const headers = [
        \"Week\",
        \"Start Date\",
        \"End Date\",
        \"PR Count\",
        \"Cycle Time P50 (min)\",
        \"Cycle Time P90 (min)\",
        \"Authors\",
        \"Reviewers\",
      ];
      const rows = cachedRollups.map((r) => [
        r.week,
        r.start_date || \"\",
        r.end_date || \"\",
        r.pr_count || 0,
        r.cycle_time_p50 != null ? r.cycle_time_p50.toFixed(1) : \"\",
        r.cycle_time_p90 != null ? r.cycle_time_p90.toFixed(1) : \"\",
        r.authors_count || 0,
        r.reviewers_count || 0,
      ]);┬╖
      const csvContent = [headers, ...rows]
        .map((row) => row.map((cell) => `\"${cell}\"`).join(\",\"))
        .join(\"\\n\");┬╖
      // Download file
      const blob = new Blob([csvContent], { type: \"text/csv;charset=utf-8;\" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement(\"a\");
      link.href = url;┬╖
      const dateStr = new Date().toISOString().split(\"T\")[0];
      link.download = `pr-insights-${dateStr}.csv`;┬╖
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);┬╖
      showToast(\"CSV exported successfully\", \"success\");
    }┬╖
    /**
     * Copy shareable link to clipboard.
     */
    async function copyShareableLink(): Promise<void> {
      elements[\"export-menu\"]?.classList.add(\"hidden\");┬╖
      try {
        await navigator.clipboard.writeText(window.location.href);
        showToast(\"Link copied to clipboard\", \"success\");
      } catch (_err) {
        // Fallback
        const textArea = document.createElement(\"textarea\");
        textArea.value = window.location.href;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand(\"copy\");
        document.body.removeChild(textArea);
        showToast(\"Link copied to clipboard\", \"success\");
      }
    }┬╖
    /**
     * Download raw CSV data as a ZIP file.
     */
    async function downloadRawDataZip(): Promise<void> {
      elements[\"export-menu\"]?.classList.add(\"hidden\");┬╖
      if (!currentBuildId || !artifactClient) {
        showToast(\"Raw data not available in direct URL mode\", \"error\");
        return;
      }┬╖
      try {
        showToast(\"Preparing download...\", \"success\");┬╖
        const artifact = await artifactClient.getArtifactMetadata(
          currentBuildId,
          \"csv-output\",
        );┬╖
        if (!artifact) {
          showToast(\"Raw CSV artifact not found in this pipeline run\", \"error\");
          return;
        }┬╖
        const downloadUrl = artifact.resource?.downloadUrl;
        if (!downloadUrl) {
          showToast(\"Download URL not available\", \"error\");
          return;
        }┬╖
        let zipUrl = downloadUrl;
        if (!zipUrl.includes(\"format=zip\")) {
          const separator = zipUrl.includes(\"?\") ? \"&\" : \"?\";
          zipUrl = `${zipUrl}${separator}format=zip`;
        }┬╖
        // Use the protected method from ArtifactClient
        const response = await (artifactClient as any)._authenticatedFetch(zipUrl);┬╖
        if (!response.ok) {
          if (response.status === 403 || response.status === 401) {
            showToast(\"Permission denied to download artifacts\", \"error\");
          } else {
            showToast(`Download failed: ${response.statusText}`, \"error\");
          }
          return;
        }┬╖
        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        const link = document.createElement(\"a\");
        link.href = url;┬╖
        const dateStr = new Date().toISOString().split(\"T\")[0];
        link.download = `pr-insights-raw-data-${dateStr}.zip`;┬╖
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);┬╖
        showToast(\"Download started\", \"success\");
      } catch (err) {
        console.error(\"Failed to download raw data:\", err);
        showToast(\"Failed to download raw data\", \"error\");
      }
    }┬╖
    /**
     * Show a toast notification.
     */
    function showToast(
      message: string,
      type: \"success\" | \"error\" = \"success\",
    ): void {
      const toast = document.createElement(\"div\");
      toast.className = `toast ${type}`;
      toast.textContent = message;
      document.body.appendChild(toast);┬╖
      setTimeout(() => {
        toast.remove();
      }, 3000);
    }┬╖
    // ============================================================================
    // Utility Functions
    // ============================================================================┬╖
    function showLoading(): void {
      hideAllPanels();
      elements[\"loading-state\"]?.classList.remove(\"hidden\");
    }┬╖
    function showContent(): void {
      hideAllPanels();
      elements[\"main-content\"]?.classList.remove(\"hidden\");
    }┬╖
    function updateDatasetInfo(manifest: any): void {
      const generatedAt = manifest?.generated_at
        ? new Date(manifest.generated_at).toLocaleString()
        : \"Unknown\";
      const runId = manifest?.run_id || \"\";┬╖
      const runInfo = elements[\"run-info\"];
      if (runInfo) {
        runInfo.textContent = `Generated: ${generatedAt}`;
        if (runId) runInfo.textContent += ` | Run: ${runId.slice(0, 8)}`;
      }
    }┬╖
    function formatDuration(minutes: number): string {
      if (minutes < 60) return `${Math.round(minutes)}m`;
      if (minutes < 1440) return `${(minutes / 60).toFixed(1)}h`;
      return `${(minutes / 1440).toFixed(1)}d`;
    }┬╖
    function median(arr: number[]): number {
      const sorted = [...arr].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      return sorted.length % 2
        ? sorted[mid]!
        : (sorted[mid - 1]! + sorted[mid]!) / 2;
    }┬╖
    function updateUrlState(): void {
      const params = new URLSearchParams(window.location.search);
      const newParams = new URLSearchParams();┬╖
      // Preserve config params
      if (params.get(\"dataset\")) newParams.set(\"dataset\", params.get(\"dataset\")!);
      if (params.get(\"pipelineId\"))
        newParams.set(\"pipelineId\", params.get(\"pipelineId\")!);┬╖
      // Add date range
      if (currentDateRange.start) {
        newParams.set(\"start\", currentDateRange.start.toISOString().split(\"T\")[0]!);
      }
      if (currentDateRange.end) {
        newParams.set(\"end\", currentDateRange.end.toISOString().split(\"T\")[0]!);
      }┬╖
      // Add active tab
      const activeTab = document.querySelector(\".tab.active\") as HTMLElement | null;
      if (activeTab && activeTab.dataset[\"tab\"] !== \"metrics\") {
        newParams.set(\"tab\", activeTab.dataset[\"tab\"]!);
      }┬╖
      // Add filters
      if (currentFilters.repos.length > 0) {
        newParams.set(\"repos\", currentFilters.repos.join(\",\"));
      }
      if (currentFilters.teams.length > 0) {
        newParams.set(\"teams\", currentFilters.teams.join(\",\"));
      }┬╖
      // Add comparison mode
      if (comparisonMode) {
        newParams.set(\"compare\", \"1\");
      }┬╖
      window.history.replaceState(
        {},
        \"\",
        `${window.location.pathname}?${newParams.toString()}`,
      );
    }┬╖
    function restoreStateFromUrl(): void {
      const params = new URLSearchParams(window.location.search);┬╖
      const startParam = params.get(\"start\");
      const endParam = params.get(\"end\");
      if (startParam && endParam) {
        currentDateRange = { start: new Date(startParam), end: new Date(endParam) };
        const dateRangeEl = elements[\"date-range\"] as HTMLSelectElement | null;
        if (dateRangeEl) {
          dateRangeEl.value = \"custom\";
          elements[\"custom-dates\"]?.classList.remove(\"hidden\");
        }
        if (elements[\"start-date\"]) elements[\"start-date\"].value = startParam;
        if (elements[\"end-date\"]) elements[\"end-date\"].value = endParam;
      }┬╖
      const tabParam = params.get(\"tab\");
      if (tabParam) {
        setTimeout(() => switchTab(tabParam), 0);
      }┬╖
      // Restore comparison mode
      const compareParam = params.get(\"compare\");
      if (compareParam === \"1\") {
        comparisonMode = true;
        elements[\"compare-toggle\"]?.classList.add(\"active\");
        elements[\"comparison-banner\"]?.classList.remove(\"hidden\");
      }
    }┬╖
    // ============================================================================
    // Initialize
    // ============================================================================┬╖
    if (document.readyState === \"loading\") {
      document.addEventListener(\"DOMContentLoaded\", init);
    } else {
      init();
    }
    "

      38 |
      39 |     it("should read project setting with SETTINGS_KEY_PROJECT", () => {
    > 40 |       expect(dashboardCode).toContain(
         |                             ^
      41 |         "SETTINGS_KEY_PROJECT, { scopeType: 'User' }",
      42 |       );
      43 |     });

      at Object.<anonymous> (tests/cross-project-settings.test.ts:40:29)

  ΓùÅ Cross-Project Settings ΓÇ║ dashboard.ts configuration ΓÇ║ should log source project origin

    expect(received).toMatch(expected)

    Expected pattern: /console\.log.*Source project/
    Received string:  "/**
     * PR Insights Dashboard
     *
     * Project-level hub that loads data from pipeline artifacts.
     * Uses Azure DevOps Extension SDK for authentication.
     *
     * Configuration precedence:
     * 1. ?dataset=<url> - Direct URL (DEV ONLY)
     * 2. ?pipelineId=<id> - Query parameter override
     * 3. Extension settings - User-scoped saved preference
     * 4. Auto-discovery - Find pipelines with 'aggregates' artifact
     */┬╖
    import { DatasetLoader, IDatasetLoader, Rollup } from \"./dataset-loader\";
    import { ArtifactClient } from \"./artifact-client\";
    import {
      PrInsightsError,
      ErrorTypes,
      createSetupRequiredError,
      createNoSuccessfulBuildsError,
      createArtifactsMissingError,
      createInvalidConfigError,
      SetupRequiredDetails,
      MultiplePipelinesDetails,
      ArtifactsMissingDetails,
    } from \"./error-types\";┬╖
    // Dashboard state
    let loader: IDatasetLoader | null = null;
    let artifactClient: ArtifactClient | null = null;
    let currentDateRange: { start: Date | null; end: Date | null } = {
      start: null,
      end: null,
    };
    let currentFilters: { repos: string[]; teams: string[] } = {
      repos: [],
      teams: [],
    };
    let comparisonMode = false;
    let cachedRollups: Rollup[] = []; // Cache for export
    let currentBuildId: number | null = null; // Store build ID for raw data download
    let sdkInitialized = false;┬╖
    // Settings keys for extension data storage (must match settings.js)
    const SETTINGS_KEY_PROJECT = \"pr-insights-source-project\";
    const SETTINGS_KEY_PIPELINE = \"pr-insights-pipeline-id\";┬╖
    // Feature flags
    const ENABLE_PHASE5_FEATURES = true;┬╖
    // DOM element cache
    const elements: Record<string, any> = {};┬╖
    /**
     * Phase 4: Production-safe metrics collector
     */
    const IS_PRODUCTION =
      typeof window !== \"undefined\" &&
      (window as any).process?.env?.NODE_ENV === \"production\";
    const DEBUG_ENABLED =
      !IS_PRODUCTION &&
      ((typeof window !== \"undefined\" && (window as any).__DASHBOARD_DEBUG__) ||
        (typeof window !== \"undefined\" &&
          new URLSearchParams(window.location.search).has(\"debug\")));┬╖
    interface PerformanceMetric {
      name: string;
      duration: number;
      timestamp: number;
    }┬╖
    const metricsCollector = DEBUG_ENABLED
      ? {
          marks: new Map<string, number>(),
          measures: [] as PerformanceMetric[],
          mark(name: string) {
            if (!performance || !performance.mark) return;
            try {
              performance.mark(name);
              this.marks.set(name, performance.now());
            } catch (_e) {
              /* ignore */
            }
          },
          measure(name: string, startMark: string, endMark: string) {
            if (!performance || !performance.measure) return;
            try {
              performance.measure(name, startMark, endMark);
              const entries = performance.getEntriesByName(name, \"measure\");
              if (entries.length > 0) {
                const lastEntry = entries[entries.length - 1];
                if (lastEntry) {
                  this.measures.push({
                    name,
                    duration: lastEntry.duration,
                    timestamp: Date.now(),
                  });
                }
              }
            } catch (_e) {
              /* ignore */
            }
          },
          getMetrics() {
            return {
              marks: Array.from(this.marks.entries()).map(([name, time]) => ({
                name,
                time,
              })),
              measures: [...this.measures],
            };
          },
          reset() {
            this.marks.clear();
            this.measures = [];
            if (performance && performance.clearMarks) performance.clearMarks();
            if (performance && performance.clearMeasures)
              performance.clearMeasures();
          },
        }
      : null;┬╖
    if (DEBUG_ENABLED && typeof window !== \"undefined\") {
      (window as any).__dashboardMetrics = metricsCollector;
    }┬╖
    // ============================================================================
    // SDK Initialization
    // ============================================================================┬╖
    /**
     * Initialize Azure DevOps Extension SDK.
     */
    async function initializeAdoSdk(): Promise<void> {
      if (sdkInitialized) return;┬╖
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error(\"Azure DevOps SDK initialization timed out\"));
        }, 10000);┬╖
        VSS.init({
          explicitNotifyLoaded: true,
          usePlatformScripts: true,
          usePlatformStyles: true,
        });┬╖
        VSS.ready(() => {
          clearTimeout(timeout);
          sdkInitialized = true;┬╖
          // Update project name in UI
          const webContext = VSS.getWebContext();
          const projectNameEl = document.getElementById(\"current-project-name\");
          if (projectNameEl && webContext?.project?.name) {
            projectNameEl.textContent = webContext.project.name;
          }┬╖
          VSS.notifyLoadSucceeded();
          resolve();
        });
      });
    }┬╖
    // ============================================================================
    // Configuration Resolution
    // ============================================================================┬╖
    /**
     * Parse and validate query parameters.
     */
    function parseQueryParams():
      | { mode: string; value: any; warning?: string | null }
      | PrInsightsError {
      const params = new URLSearchParams(window.location.search);┬╖
      const datasetUrl = params.get(\"dataset\");
      const pipelineIdStr = params.get(\"pipelineId\");┬╖
      // Check for dataset URL (highest priority)
      if (datasetUrl) {
        // Validate URL
        if (!datasetUrl.startsWith(\"https://\")) {
          return createInvalidConfigError(
            \"dataset\",
            datasetUrl,
            \"Must be a valid HTTPS URL\",
          );
        }┬╖
        // Security warning for non-ADO domains
        const IS_DEV =
          window.location.hostname === \"localhost\" || params.has(\"devMode\");┬╖
        if (!IS_DEV) {
          try {
            const urlHost = new URL(datasetUrl).hostname;
            const isAdoDomain =
              urlHost.endsWith(\"dev.azure.com\") ||
              urlHost.endsWith(\".visualstudio.com\") ||
              urlHost.endsWith(\".azure.com\");
            if (!isAdoDomain) {
              console.warn(
                `SECURITY: ?dataset= URL \"${urlHost}\" is not an Azure DevOps domain. ` +
                  `This parameter is intended for development only.`,
              );
            }
          } catch (_e) {
            return createInvalidConfigError(
              \"dataset\",
              datasetUrl,
              \"Invalid URL format\",
            );
          }
        }┬╖
        let warning: string | null = null;
        if (pipelineIdStr) {
          warning = \"Both dataset and pipelineId specified; using dataset\";
          console.warn(warning);
        }┬╖
        return { mode: \"direct\", value: datasetUrl, warning };
      }┬╖
      // Check for pipelineId
      if (pipelineIdStr) {
        const pipelineId = parseInt(pipelineIdStr, 10);
        if (isNaN(pipelineId) || pipelineId <= 0) {
          return createInvalidConfigError(
            \"pipelineId\",
            pipelineIdStr,
            \"Must be a positive integer\",
          );
        }
        return { mode: \"explicit\", value: pipelineId };
      }┬╖
      return { mode: \"discover\", value: null };
    }┬╖
    /**
     * Get source configuration from extension settings.
     */
    async function getSourceConfig(): Promise<{
      projectId: string | null;
      pipelineId: number | null;
    }> {
      const result: { projectId: string | null; pipelineId: number | null } = {
        projectId: null,
        pipelineId: null,
      };
      try {
        const dataService = await VSS.getService<IExtensionDataService>(
          VSS.ServiceIds.ExtensionData,
        );┬╖
        // Get source project ID
        const savedProjectId = await dataService.getValue<string>(
          SETTINGS_KEY_PROJECT,
          { scopeType: \"User\" },
        );
        if (
          savedProjectId &&
          typeof savedProjectId === \"string\" &&
          savedProjectId.trim()
        ) {
          result.projectId = savedProjectId.trim();
        }┬╖
        // Get pipeline definition ID
        const savedPipelineId = await dataService.getValue<number>(
          SETTINGS_KEY_PIPELINE,
          { scopeType: \"User\" },
        );
        if (
          savedPipelineId &&
          typeof savedPipelineId === \"number\" &&
          savedPipelineId > 0
        ) {
          result.pipelineId = savedPipelineId;
        }
      } catch (e) {
        console.log(\"Could not read extension settings:\", e);
      }
      return result;
    }┬╖
    /**
     * Clear stale pipeline ID setting.
     */
    async function clearStalePipelineSetting(): Promise<void> {
      try {
        const dataService = await VSS.getService<IExtensionDataService>(
          VSS.ServiceIds.ExtensionData,
        );
        await dataService.setValue(SETTINGS_KEY_PIPELINE, null, {
          scopeType: \"User\",
        });
        console.log(\"Cleared stale pipeline setting to re-enable auto-discovery\");
      } catch (e) {
        console.warn(\"Could not clear stale pipeline setting:\", e);
      }
    }┬╖
    /**
     * Resolve configuration using precedence rules.
     */
    async function resolveConfiguration(): Promise<{
      buildId?: number;
      artifactName?: string;
      directUrl?: string;
    }> {
      const queryResult = parseQueryParams();┬╖
      // Check for parsing error
      if (queryResult instanceof PrInsightsError) {
        throw queryResult;
      }┬╖
      // Mode: direct URL
      if (queryResult.mode === \"direct\") {
        return { directUrl: queryResult.value };
      }┬╖
      // Get current project context
      const webContext = VSS.getWebContext();
      const currentProjectId = webContext.project?.id;
      if (!currentProjectId) {
        throw new Error(\"No project context available\");
      }┬╖
      // Get configured source from settings
      const sourceConfig = await getSourceConfig();┬╖
      // Determine which project to use for artifact access
      const targetProjectId = sourceConfig.projectId || currentProjectId;┬╖
      console.log(
        `Source project: ${targetProjectId}${sourceConfig.projectId ? \" (from settings)\" : \" (current context)\"}`,
      );┬╖
      // Initialize artifact client with target project
      artifactClient = new ArtifactClient(targetProjectId);
      await artifactClient.initialize();┬╖
      // Mode: explicit pipelineId from query
      if (queryResult.mode === \"explicit\") {
        return await resolveFromPipelineId(queryResult.value, targetProjectId);
      }┬╖
      // Check settings for pipeline ID
      if (sourceConfig.pipelineId) {
        console.log(
          `Using pipeline definition ID from settings: ${sourceConfig.pipelineId}`,
        );
        try {
          return await resolveFromPipelineId(
            sourceConfig.pipelineId,
            targetProjectId,
          );
        } catch (error: any) {
          console.warn(
            `Saved pipeline ${sourceConfig.pipelineId} is invalid, falling back to auto-discovery:`,
            error.message,
          );
          await clearStalePipelineSetting();
        }
      }┬╖
      // Mode: discovery in target project
      return await discoverAndResolve(targetProjectId);
    }┬╖
    /**
     * Resolve artifact info from a specific pipeline ID.
     */
    async function resolveFromPipelineId(
      pipelineId: number,
      projectId: string,
    ): Promise<{ buildId: number; artifactName: string }> {
      // Get Build REST client
      const buildClient = await getBuildClient();┬╖
      // Get latest successful build
      const builds = await buildClient.getBuilds(
        projectId,
        [pipelineId],
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined, // reasonFilter
        2, // statusFilter: Completed
        6, // resultFilter: Succeeded (2) | PartiallySucceeded (4)
        undefined,
        undefined,
        1, // top
      );┬╖
      if (!builds || builds.length === 0) {
        const definitions = await buildClient.getDefinitions(
          projectId,
          undefined,
          undefined,
          undefined,
          2,
          undefined,
          undefined,
          undefined,
          [pipelineId],
        );
        const name = definitions?.[0]?.name || `ID ${pipelineId}`;
        throw createNoSuccessfulBuildsError(name);
      }┬╖
      const latestBuild = builds[0];
      if (!latestBuild) throw new Error(\"Failed to retrieve latest build\");┬╖
      // Check for aggregates artifact
      if (!artifactClient) throw new Error(\"ArtifactClient not initialized\");
      const artifacts = await artifactClient.getArtifacts(latestBuild.id);
      const hasAggregates = artifacts.some((a) => a.name === \"aggregates\");┬╖
      if (!hasAggregates) {
        const definitions = await buildClient.getDefinitions(
          projectId,
          undefined,
          undefined,
          undefined,
          2,
          undefined,
          undefined,
          undefined,
          [pipelineId],
        );
        const name = definitions?.[0]?.name || `ID ${pipelineId}`;
        throw createArtifactsMissingError(name, latestBuild.id);
      }┬╖
      return { buildId: latestBuild.id, artifactName: \"aggregates\" };
    }┬╖
    /**
     * Discover pipelines with aggregates and resolve.
     */
    async function discoverAndResolve(
      projectId: string,
    ): Promise<{ buildId: number; artifactName: string }> {
      const matches = await discoverInsightsPipelines(projectId);┬╖
      if (matches.length === 0) {
        throw createSetupRequiredError();
      }┬╖
      const firstMatch = matches[0];
      if (!firstMatch) throw createSetupRequiredError();┬╖
      return { buildId: firstMatch.buildId, artifactName: \"aggregates\" };
    }┬╖
    /**
     * Discover pipelines with aggregates artifact.
     */
    async function discoverInsightsPipelines(
      projectId: string,
    ): Promise<Array<{ id: number; name: string; buildId: number }>> {
      const buildClient = await getBuildClient();
      const matches: Array<{ id: number; name: string; buildId: number }> = [];┬╖
      const definitions = await buildClient.getDefinitions(
        projectId,
        undefined,
        undefined,
        undefined,
        2,
        50,
      );┬╖
      for (const def of definitions) {
        const builds = await buildClient.getBuilds(
          projectId,
          [def.id],
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          2,
          6,
          undefined,
          undefined,
          1,
        );┬╖
        if (!builds || builds.length === 0) continue;┬╖
        const latestBuild = builds[0];
        if (!latestBuild) continue;┬╖
        try {
          if (!artifactClient) throw new Error(\"ArtifactClient not initialized\");
          const artifacts = await artifactClient.getArtifacts(latestBuild.id);
          if (!artifacts.some((a) => a.name === \"aggregates\")) continue;┬╖
          matches.push({
            id: def.id,
            name: def.name,
            buildId: latestBuild.id,
          });
        } catch (e) {
          console.debug(`Skipping pipeline ${def.name}:`, e);
        }
      }┬╖
      return matches;
    }┬╖
    /**
     * Get Build REST client from SDK.
     */
    async function getBuildClient(): Promise<IBuildRestClient> {
      return new Promise((resolve) => {
        VSS.require([\"TFS/Build/RestClient\"], (BuildRestClient: any) => {
          resolve(BuildRestClient.getClient());
        });
      });
    }┬╖
    // ============================================================================
    // Main Initialization
    // ============================================================================┬╖
    /**
     * Check if running in local dashboard mode.
     */
    function isLocalMode(): boolean {
      return (
        typeof window !== \"undefined\" &&
        (window as any).LOCAL_DASHBOARD_MODE === true
      );
    }┬╖
    /**
     * Get local dataset path from window config.
     */
    function getLocalDatasetPath(): string {
      return (
        (typeof window !== \"undefined\" && (window as any).DATASET_PATH) ||
        \"./dataset\"
      );
    }┬╖
    /**
     * Initialize the dashboard.
     */
    async function init(): Promise<void> {
      if (metricsCollector) metricsCollector.mark(\"dashboard-init\");┬╖
      cacheElements();
      setupEventListeners();
      initializePhase5Features();┬╖
      try {
        if (isLocalMode()) {
          console.log(\"[Dashboard] Running in local mode\");
          const datasetPath = getLocalDatasetPath();
          loader = new DatasetLoader(datasetPath);
          currentBuildId = null;┬╖
          const projectNameEl = document.getElementById(\"current-project-name\");
          if (projectNameEl) {
            projectNameEl.textContent = \"Local Dashboard\";
          }┬╖
          const exportRawZip = document.getElementById(\"export-raw-zip\");
          if (exportRawZip) {
            exportRawZip.style.display = \"none\";
          }┬╖
          await loadDataset();
          return;
        }┬╖
        await initializeAdoSdk();
        const config = await resolveConfiguration();┬╖
        if (config.directUrl) {
          loader = new DatasetLoader(config.directUrl);
          currentBuildId = null;
        } else if (config.buildId && config.artifactName && artifactClient) {
          loader = artifactClient.createDatasetLoader(
            config.buildId,
            config.artifactName,
          );
          currentBuildId = config.buildId;
        } else {
          throw new Error(\"Failed to resolve configuration\");
        }┬╖
        await loadDataset();
      } catch (error: any) {
        console.error(\"Dashboard initialization failed:\", error);
        handleError(error);
      }
    }┬╖
    /**
     * Handle errors with appropriate UI panels.
     */
    function handleError(error: any): void {
      hideAllPanels();┬╖
      if (error instanceof PrInsightsError) {
        switch (error.type) {
          case ErrorTypes.SETUP_REQUIRED:
            showSetupRequired(error);
            break;
          case ErrorTypes.MULTIPLE_PIPELINES:
            showMultiplePipelines(error);
            break;
          case ErrorTypes.ARTIFACTS_MISSING:
            showArtifactsMissing(error);
            break;
          case ErrorTypes.PERMISSION_DENIED:
            showPermissionDenied(error);
            break;
          default:
            showGenericError(error.title, error.message);
            break;
        }
      } else {
        showGenericError(\"Error\", error.message || \"An unexpected error occurred\");
      }
    }┬╖
    /**
     * Hide all error/setup panels.
     */
    function hideAllPanels(): void {
      [
        \"setup-required\",
        \"multiple-pipelines\",
        \"artifacts-missing\",
        \"permission-denied\",
        \"error-state\",
        \"loading-state\",
        \"main-content\",
      ].forEach((id) => {
        document.getElementById(id)?.classList.add(\"hidden\");
      });
    }┬╖
    /**
     * Show setup required panel.
     */
    function showSetupRequired(error: PrInsightsError): void {
      const panel = document.getElementById(\"setup-required\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"setup-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      const details = error.details as SetupRequiredDetails;
      if (details?.instructions && Array.isArray(details.instructions)) {
        const stepsList = document.getElementById(\"setup-steps\");
        if (stepsList) {
          stepsList.innerHTML = details.instructions
            .map((s: string) => `<li>${s}</li>`)
            .join(\"\");
        }
      }┬╖
      if (details?.docsUrl) {
        const docsLink = document.getElementById(
          \"docs-link\",
        ) as HTMLAnchorElement | null;
        if (docsLink) docsLink.href = String(details.docsUrl);
      }┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show multiple pipelines panel.
     */
    function showMultiplePipelines(error: PrInsightsError): void {
      const panel = document.getElementById(\"multiple-pipelines\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"multiple-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      const listEl = document.getElementById(\"pipeline-list\");
      const details = error.details as MultiplePipelinesDetails;
      if (listEl && details?.matches && Array.isArray(details.matches)) {
        listEl.innerHTML = details.matches
          .map(
            (m: any) => `
                    <a href=\"?pipelineId=${m.id}\" class=\"pipeline-option\">
                        <strong>${m.name}</strong>
                        <span class=\"pipeline-id\">ID: ${m.id}</span>
                    </a>
                `,
          )
          .join(\"\");
      }┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show permission denied panel.
     */
    function showPermissionDenied(error: PrInsightsError): void {
      const panel = document.getElementById(\"permission-denied\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"permission-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show generic error state.
     */
    function showGenericError(title: string, message: string): void {
      const panel = document.getElementById(\"error-state\");
      if (!panel) return;┬╖
      const titleEl = document.getElementById(\"error-title\");
      const messageEl = document.getElementById(\"error-message\");┬╖
      if (titleEl) titleEl.textContent = title;
      if (messageEl) messageEl.textContent = message;┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show artifacts missing panel.
     */
    function showArtifactsMissing(error: PrInsightsError): void {
      const panel = document.getElementById(\"artifacts-missing\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"missing-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      const details = error.details as ArtifactsMissingDetails;
      if (details?.instructions && Array.isArray(details.instructions)) {
        const stepsList = document.getElementById(\"missing-steps\");
        if (stepsList) {
          stepsList.innerHTML = details.instructions
            .map((s: string) => `<li>${s}</li>`)
            .join(\"\");
        }
      }┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    // ============================================================================
    // DOM and Event Handling
    // ============================================================================┬╖
    /**
     * Cache DOM elements for performance.
     */
    function cacheElements(): void {
      const ids = [
        \"app\",
        \"loading-state\",
        \"error-state\",
        \"main-content\",
        \"error-title\",
        \"error-message\",
        \"run-info\",
        \"date-range\",
        \"custom-dates\",
        \"start-date\",
        \"end-date\",
        \"retry-btn\",
        \"total-prs\",
        \"cycle-p50\",
        \"cycle-p90\",
        \"authors-count\",
        \"reviewers-count\",
        \"throughput-chart\",
        \"cycle-distribution\",
        \"total-prs-delta\",
        \"cycle-p50-delta\",
        \"cycle-p90-delta\",
        \"authors-delta\",
        \"reviewers-delta\",
        \"repo-filter\",
        \"team-filter\",
        \"repo-filter-group\",
        \"team-filter-group\",
        \"clear-filters\",
        \"active-filters\",
        \"filter-chips\",
        \"total-prs-sparkline\",
        \"cycle-p50-sparkline\",
        \"cycle-p90-sparkline\",
        \"authors-sparkline\",
        \"reviewers-sparkline\",
        \"cycle-time-trend\",
        \"reviewer-activity\",
        \"compare-toggle\",
        \"comparison-banner\",
        \"current-period-dates\",
        \"previous-period-dates\",
        \"exit-compare\",
        \"export-btn\",
        \"export-menu\",
        \"export-csv\",
        \"export-link\",
        \"export-raw-zip\",
      ];┬╖
      ids.forEach((id) => {
        elements[id] = document.getElementById(id);
      });┬╖
      elements.tabs = document.querySelectorAll(\".tab\");
    }┬╖
    /**
     * Initialize Phase 5 features.
     */
    function initializePhase5Features(): void {
      const phase5Tabs = document.querySelectorAll(\".phase5-tab\");┬╖
      if (ENABLE_PHASE5_FEATURES) {
        phase5Tabs.forEach((tab) => tab.classList.remove(\"hidden\"));
        console.log(\"Phase 5 features enabled\");
      } else {
        console.log(\"Phase 5 features disabled\");
      }
    }┬╖
    /**
     * Set up event listeners.
     */
    function setupEventListeners(): void {
      elements[\"date-range\"]?.addEventListener(\"change\", handleDateRangeChange);
      document
        .getElementById(\"apply-dates\")
        ?.addEventListener(\"click\", applyCustomDates);┬╖
      elements.tabs?.forEach((tab: HTMLElement) => {
        tab.addEventListener(\"click\", () => {
          const tabId = tab.dataset[\"tab\"];
          if (tabId) switchTab(tabId);
        });
      });┬╖
      elements[\"retry-btn\"]?.addEventListener(\"click\", () => init());
      document
        .getElementById(\"setup-retry-btn\")
        ?.addEventListener(\"click\", () => init());
      document
        .getElementById(\"permission-retry-btn\")
        ?.addEventListener(\"click\", () => init());┬╖
      elements[\"repo-filter\"]?.addEventListener(\"change\", handleFilterChange);
      elements[\"team-filter\"]?.addEventListener(\"change\", handleFilterChange);
      elements[\"clear-filters\"]?.addEventListener(\"click\", clearAllFilters);┬╖
      elements[\"compare-toggle\"]?.addEventListener(\"click\", toggleComparisonMode);
      elements[\"exit-compare\"]?.addEventListener(\"click\", exitComparisonMode);┬╖
      elements[\"export-btn\"]?.addEventListener(\"click\", toggleExportMenu);
      elements[\"export-csv\"]?.addEventListener(\"click\", exportToCsv);
      elements[\"export-link\"]?.addEventListener(\"click\", copyShareableLink);
      elements[\"export-raw-zip\"]?.addEventListener(\"click\", downloadRawDataZip);┬╖
      document.addEventListener(\"click\", (e: MouseEvent) => {
        const target = e.target as HTMLElement;
        if (!target.closest(\".export-dropdown\")) {
          elements[\"export-menu\"]?.classList.add(\"hidden\");
        }
      });
    }┬╖
    // ============================================================================
    // Data Loading and Rendering
    // ============================================================================┬╖
    /**
     * Load the dataset.
     */
    async function loadDataset(): Promise<void> {
      showLoading();┬╖
      try {
        if (!loader) throw new Error(\"Loader not initialized\");┬╖
        // Load manifest first
        const manifest = await loader.loadManifest();┬╖
        // Load dimensions
        const dimensions = await loader.loadDimensions();┬╖
        // Populate filter dropdowns from dimensions
        populateFilterDropdowns(dimensions);┬╖
        // Show dataset info
        updateDatasetInfo(manifest);┬╖
        // Restore state from URL if present
        restoreStateFromUrl();┬╖
        // Set initial date range from manifest defaults
        setInitialDateRange();┬╖
        // Load and render metrics
        await refreshMetrics();┬╖
        // Update feature tabs based on manifest
        await updateFeatureTabs();┬╖
        showContent();
      } catch (error) {
        console.error(\"Failed to load dataset:\", error);
        handleError(error);
      }
    }┬╖
    /**
     * Set initial date range from manifest defaults.
     */
    function setInitialDateRange(): void {
      // Skip if already restored from URL
      if (currentDateRange.start && currentDateRange.end) return;
      if (!loader) return;┬╖
      const coverage = loader.getCoverage() || null;
      const defaultDays = loader.getDefaultRangeDays() || 90;┬╖
      if (coverage?.date_range?.max) {
        const endDate = new Date(coverage.date_range.max);
        const startDate = new Date(endDate);
        startDate.setDate(startDate.getDate() - defaultDays);┬╖
        currentDateRange = { start: startDate, end: endDate };┬╖
        if (elements[\"start-date\"]) {
          elements[\"start-date\"].value = startDate.toISOString().split(\"T\")[0];
        }
        if (elements[\"end-date\"]) {
          elements[\"end-date\"].value = endDate.toISOString().split(\"T\")[0];
        }
      }
    }┬╖
    /**
     * Calculate the previous period date range for comparison.
     */
    function getPreviousPeriod(start: Date, end: Date): { start: Date; end: Date } {
      const durationMs = end.getTime() - start.getTime();
      const prevEnd = new Date(start.getTime() - 1); // Day before current start
      const prevStart = new Date(prevEnd.getTime() - durationMs);
      return { start: prevStart, end: prevEnd };
    }┬╖
    /**
     * Apply dimension filters to rollups data.
     * Uses by_repository slices when available for accurate filtering.
     */
    function applyFiltersToRollups(
      rollups: Rollup[],
      filters: { repos: string[]; teams: string[] },
    ): Rollup[] {
      // No filters active - return original data
      if (!filters.repos.length && !filters.teams.length) {
        return rollups;
      }┬╖
      return rollups.map((rollup) => {
        // If we have by_repository slices and repo filter is active, use them
        if (filters.repos.length && rollup.by_repository) {
          const selectedRepos = filters.repos
            .map((repoId) => {
              const repoData = rollup.by_repository![repoId];
              if (repoData) return repoData;┬╖
              return Object.entries(rollup.by_repository!).find(
                ([name]) => name === repoId,
              )?.[1];
            })
            .filter(Boolean) as any[];┬╖
          if (selectedRepos.length === 0) {
            return {
              ...rollup,
              pr_count: 0,
              cycle_time_p50: null,
              cycle_time_p90: null,
              authors_count: 0,
              reviewers_count: 0,
            };
          }┬╖
          // Aggregate metrics
          const totalPrCount = selectedRepos.reduce(
            (sum, r) => sum + (r.pr_count || 0),
            0,
          );
          const p50Values = selectedRepos
            .map((r) => r.cycle_time_p50)
            .filter((v) => v != null);
          const p90Values = selectedRepos
            .map((r) => r.cycle_time_p90)
            .filter((v) => v != null);┬╖
          const avgP50 =
            p50Values.length > 0
              ? p50Values.reduce((a, b) => a + b, 0) / p50Values.length
              : null;
          const avgP90 =
            p90Values.length > 0
              ? p90Values.reduce((a, b) => a + b, 0) / p90Values.length
              : null;┬╖
          const totalAuthors = selectedRepos.reduce(
            (sum, r) => sum + (r.authors_count || 0),
            0,
          );
          const totalReviewers = selectedRepos.reduce(
            (sum, r) => sum + (r.reviewers_count || 0),
            0,
          );┬╖
          return {
            ...rollup,
            pr_count: totalPrCount,
            cycle_time_p50: avgP50,
            cycle_time_p90: avgP90,
            authors_count: totalAuthors,
            reviewers_count: totalReviewers,
          } as Rollup;
        }┬╖
        // If we have by_team slices and team filter is active, use them
        if (filters.teams.length && rollup.by_team) {
          const selectedTeams = filters.teams
            .map((teamId) => rollup.by_team![teamId])
            .filter(Boolean) as any[];┬╖
          if (selectedTeams.length === 0) {
            return {
              ...rollup,
              pr_count: 0,
              cycle_time_p50: null,
              cycle_time_p90: null,
              authors_count: 0,
              reviewers_count: 0,
            };
          }┬╖
          const totalPrCount = selectedTeams.reduce(
            (sum, t) => sum + (t.pr_count || 0),
            0,
          );
          const p50Values = selectedTeams
            .map((t) => t.cycle_time_p50)
            .filter((v) => v != null);
          const avgP50 =
            p50Values.length > 0
              ? p50Values.reduce((a, b) => a + b, 0) / p50Values.length
              : null;┬╖
          return {
            ...rollup,
            pr_count: totalPrCount,
            cycle_time_p50: avgP50,
          } as Rollup;
        }┬╖
        return rollup;
      });
    }┬╖
    /**
     * Refresh metrics for current date range.
     */
    async function refreshMetrics(): Promise<void> {
      if (!currentDateRange.start || !currentDateRange.end || !loader) return;┬╖
      // Load current period data
      const rawRollups = await loader.getWeeklyRollups(
        currentDateRange.start,
        currentDateRange.end,
      );┬╖
      const distributions = await loader.getDistributions(
        currentDateRange.start,
        currentDateRange.end,
      );┬╖
      // Apply dimension filters to rollups
      const rollups = applyFiltersToRollups(rawRollups, currentFilters);┬╖
      // Load previous period data for comparison
      const prevPeriod = getPreviousPeriod(
        currentDateRange.start,
        currentDateRange.end,
      );
      let prevRollups: Rollup[] = [];
      try {
        const rawPrevRollups = await loader.getWeeklyRollups(
          prevPeriod.start,
          prevPeriod.end,
        );
        prevRollups = applyFiltersToRollups(rawPrevRollups, currentFilters);
      } catch (e) {
        console.debug(\"Previous period data not available:\", e);
      }┬╖
      // Cache filtered rollups for export
      cachedRollups = rollups;┬╖
      renderSummaryCards(rollups, prevRollups);
      renderThroughputChart(rollups);
      renderCycleTimeTrend(rollups);
      renderReviewerActivity(rollups);
      renderCycleDistribution(distributions);┬╖
      // Update comparison banner if in comparison mode
      if (comparisonMode) {
        updateComparisonBanner();
      }
    }┬╖
    interface CalculatedMetrics {
      totalPrs: number;
      cycleP50: number | null;
      cycleP90: number | null;
      avgAuthors: number;
      avgReviewers: number;
    }┬╖
    /**
     * Calculate metrics from rollups data.
     */
    function calculateMetrics(rollups: Rollup[]): CalculatedMetrics {
      if (!rollups || !rollups.length) {
        return {
          totalPrs: 0,
          cycleP50: null,
          cycleP90: null,
          avgAuthors: 0,
          avgReviewers: 0,
        };
      }┬╖
      const totalPrs = rollups.reduce((sum, r) => sum + (r.pr_count || 0), 0);┬╖
      const p50Values = rollups
        .map((r) => r.cycle_time_p50)
        .filter((v): v is number => v !== null && v !== undefined);
      const p90Values = rollups
        .map((r) => r.cycle_time_p90)
        .filter((v): v is number => v !== null && v !== undefined);┬╖
      const authorsSum = rollups.reduce(
        (sum, r) => sum + (r.authors_count || 0),
        0,
      );
      const reviewersSum = rollups.reduce(
        (sum, r) => sum + (r.reviewers_count || 0),
        0,
      );┬╖
      return {
        totalPrs,
        cycleP50: p50Values.length ? median(p50Values) : null,
        cycleP90: p90Values.length ? median(p90Values) : null,
        avgAuthors:
          rollups.length > 0 ? Math.round(authorsSum / rollups.length) : 0,
        avgReviewers:
          rollups.length > 0 ? Math.round(reviewersSum / rollups.length) : 0,
      };
    }┬╖
    /**
     * Calculate percentage change between two values.
     */
    function calculatePercentChange(
      current: number | null | undefined,
      previous: number | null | undefined,
    ): number | null {
      if (previous === null || previous === undefined || previous === 0) {
        return null;
      }
      if (current === null || current === undefined) {
        return null;
      }
      return ((current - previous) / previous) * 100;
    }┬╖
    /**
     * Render a delta indicator element.
     */
    function renderDelta(
      element: HTMLElement | null,
      percentChange: number | null,
      inverse = false,
    ): void {
      if (!element) return;┬╖
      if (percentChange === null) {
        element.innerHTML = \"\";
        element.className = \"metric-delta\";
        return;
      }┬╖
      const isNeutral = Math.abs(percentChange) < 2; // Within 2% is neutral
      const isPositive = percentChange > 0;
      const absChange = Math.abs(percentChange);┬╖
      let cssClass = \"metric-delta \";
      let arrow = \"\";┬╖
      if (isNeutral) {
        cssClass += \"delta-neutral\";
        arrow = \"~\";
      } else if (isPositive) {
        cssClass += inverse ? \"delta-negative-inverse\" : \"delta-positive\";
        arrow = \"&#9650;\"; // Up arrow
      } else {
        cssClass += inverse ? \"delta-positive-inverse\" : \"delta-negative\";
        arrow = \"&#9660;\"; // Down arrow
      }┬╖
      const sign = isPositive ? \"+\" : \"\";
      element.className = cssClass;
      element.innerHTML = `<span class=\"delta-arrow\">${arrow}</span> ${sign}${absChange.toFixed(0)}% <span class=\"delta-label\">vs prev</span>`;
    }┬╖
    /**
     * Render a sparkline SVG from data points.
     */
    function renderSparkline(element: HTMLElement | null, values: number[]): void {
      if (!element || !values || values.length < 2) {
        if (element) element.innerHTML = \"\";
        return;
      }┬╖
      // Take last 8 values for sparkline
      const data = values.slice(-8);
      const width = 60;
      const height = 24;
      const padding = 2;┬╖
      const minVal = Math.min(...data);
      const maxVal = Math.max(...data);
      const range = maxVal - minVal || 1;┬╖
      // Calculate points
      const points = data.map((val, i) => {
        const x = padding + (i / (data.length - 1)) * (width - padding * 2);
        const y =
          height - padding - ((val - minVal) / range) * (height - padding * 2);
        return { x, y };
      });┬╖
      // Create path
      const pathD = points
        .map((p, i) => `${i === 0 ? \"M\" : \"L\"} ${p.x.toFixed(1)} ${p.y.toFixed(1)}`)
        .join(\" \");┬╖
      // Create area path (closed)
      const areaD =
        pathD +
        ` L ${points[points.length - 1]!.x.toFixed(1)} ${height - padding} L ${points[0]!.x.toFixed(1)} ${height - padding} Z`;┬╖
      // Last point for dot
      const lastPoint = points[points.length - 1]!;┬╖
      element.innerHTML = `
            <svg viewBox=\"0 0 ${width} ${height}\" preserveAspectRatio=\"none\">
                <path class=\"sparkline-area\" d=\"${areaD}\"/>
                <path class=\"sparkline-line\" d=\"${pathD}\"/>
                <circle class=\"sparkline-dot\" cx=\"${lastPoint.x.toFixed(1)}\" cy=\"${lastPoint.y.toFixed(1)}\" r=\"2\"/>
            </svg>
        `;
    }┬╖
    /**
     * Extract sparkline data from rollups.
     */
    function extractSparklineData(rollups: Rollup[]): {
      prCounts: number[];
      p50s: number[];
      p90s: number[];
      authors: number[];
      reviewers: number[];
    } {
      if (!rollups || !rollups.length) {
        return { prCounts: [], p50s: [], p90s: [], authors: [], reviewers: [] };
      }┬╖
      return {
        prCounts: rollups.map((r) => r.pr_count || 0),
        p50s: rollups
          .map((r) => r.cycle_time_p50)
          .filter((v): v is number => v !== null && v !== undefined),
        p90s: rollups
          .map((r) => r.cycle_time_p90)
          .filter((v): v is number => v !== null && v !== undefined),
        authors: rollups.map((r) => r.authors_count || 0),
        reviewers: rollups.map((r) => r.reviewers_count || 0),
      };
    }┬╖
    /**
     * Render summary metric cards.
     */
    function renderSummaryCards(
      rollups: Rollup[],
      prevRollups: Rollup[] = [],
    ): void {
      if (metricsCollector) metricsCollector.mark(\"render-summary-cards-start\");┬╖
      const current = calculateMetrics(rollups);
      const previous = calculateMetrics(prevRollups);┬╖
      // Render metric values
      if (elements[\"total-prs\"])
        elements[\"total-prs\"].textContent = current.totalPrs.toLocaleString();
      if (elements[\"cycle-p50\"])
        elements[\"cycle-p50\"].textContent =
          current.cycleP50 !== null ? formatDuration(current.cycleP50) : \"-\";
      if (elements[\"cycle-p90\"])
        elements[\"cycle-p90\"].textContent =
          current.cycleP90 !== null ? formatDuration(current.cycleP90) : \"-\";
      if (elements[\"authors-count\"])
        elements[\"authors-count\"].textContent = current.avgAuthors.toLocaleString();
      if (elements[\"reviewers-count\"]) {
        elements[\"reviewers-count\"].textContent =
          current.avgReviewers.toLocaleString();
      }┬╖
      // Render sparklines
      const sparklineData = extractSparklineData(rollups);
      renderSparkline(elements[\"total-prs-sparkline\"], sparklineData.prCounts);
      renderSparkline(elements[\"cycle-p50-sparkline\"], sparklineData.p50s);
      renderSparkline(elements[\"cycle-p90-sparkline\"], sparklineData.p90s);
      renderSparkline(elements[\"authors-sparkline\"], sparklineData.authors);
      renderSparkline(elements[\"reviewers-sparkline\"], sparklineData.reviewers);┬╖
      // Render deltas (only if we have previous period data)
      if (prevRollups && prevRollups.length > 0) {
        renderDelta(
          elements[\"total-prs-delta\"],
          calculatePercentChange(current.totalPrs, previous.totalPrs),
          false,
        );
        renderDelta(
          elements[\"cycle-p50-delta\"],
          calculatePercentChange(current.cycleP50, previous.cycleP50),
          true,
        ); // Inverse: lower is better
        renderDelta(
          elements[\"cycle-p90-delta\"],
          calculatePercentChange(current.cycleP90, previous.cycleP90),
          true,
        ); // Inverse: lower is better
        renderDelta(
          elements[\"authors-delta\"],
          calculatePercentChange(current.avgAuthors, previous.avgAuthors),
          false,
        );
        renderDelta(
          elements[\"reviewers-delta\"],
          calculatePercentChange(current.avgReviewers, previous.avgReviewers),
          false,
        );
      } else {
        // Clear deltas if no previous data
        [
          \"total-prs-delta\",
          \"cycle-p50-delta\",
          \"cycle-p90-delta\",
          \"authors-delta\",
          \"reviewers-delta\",
        ].forEach((id) => {
          const el = elements[id];
          if (el) {
            el.innerHTML = \"\";
            el.className = \"metric-delta\";
          }
        });
      }┬╖
      if (metricsCollector) {
        metricsCollector.mark(\"render-summary-cards-end\");
        metricsCollector.mark(\"first-meaningful-paint\");
        metricsCollector.measure(
          \"init-to-fmp\",
          \"dashboard-init\",
          \"first-meaningful-paint\",
        );
      }
    }┬╖
    /**
     * Calculate moving average for trend line.
     */
    function calculateMovingAverage(
      values: number[],
      window = 4,
    ): (number | null)[] {
      const result: (number | null)[] = [];
      for (let i = 0; i < values.length; i++) {
        if (i < window - 1) {
          result.push(null);
        } else {
          const sum = values
            .slice(i - window + 1, i + 1)
            .reduce((a, b) => a + b, 0);
          result.push(sum / window);
        }
      }
      return result;
    }┬╖
    /**
     * Render throughput chart with trend line overlay.
     */
    function renderThroughputChart(rollups: Rollup[]): void {
      const chartEl = elements[\"throughput-chart\"];
      if (!chartEl) return;┬╖
      if (!rollups || !rollups.length) {
        chartEl.innerHTML = '<p class=\"no-data\">No data for selected range</p>';
        return;
      }┬╖
      const prCounts = rollups.map((r) => r.pr_count || 0);
      const maxCount = Math.max(...prCounts);
      const movingAvg = calculateMovingAverage(prCounts, 4);┬╖
      // Render bar chart
      const barsHtml = rollups
        .map((r) => {
          const height = maxCount > 0 ? ((r.pr_count || 0) / maxCount) * 100 : 0;
          return `
                <div class=\"bar-container\" title=\"${r.week}: ${r.pr_count || 0} PRs\">
                    <div class=\"bar\" style=\"height: ${height}%\"></div>
                    <div class=\"bar-label\">${r.week.split(\"-W\")[1]}</div>
                </div>
            `;
        })
        .join(\"\");┬╖
      // Render trend line SVG overlay
      let trendLineHtml = \"\";
      if (rollups.length >= 4) {
        const validPoints = movingAvg
          .map((val, i) => ({ val, i }))
          .filter((p): p is { val: number; i: number } => p.val !== null);┬╖
        if (validPoints.length >= 2) {
          const chartHeight = 200;
          const chartPadding = 8;┬╖
          // Calculate SVG path points
          const points = validPoints.map((p) => {
            const x = (p.i / (rollups.length - 1)) * 100;
            const y =
              maxCount > 0
                ? chartHeight -
                  chartPadding -
                  (p.val / maxCount) * (chartHeight - chartPadding * 2)
                : chartHeight / 2;
            return { x, y };
          });┬╖
          const pathD = points
            .map(
              (pt, i) =>
                `${i === 0 ? \"M\" : \"L\"} ${pt.x.toFixed(1)}% ${pt.y.toFixed(1)}`,
            )
            .join(\" \");┬╖
          trendLineHtml = `
                    <div class=\"trend-line-overlay\">
                        <svg viewBox=\"0 0 100 ${chartHeight}\" preserveAspectRatio=\"none\">
                            <path class=\"trend-line\" d=\"${pathD}\" vector-effect=\"non-scaling-stroke\"/>
                        </svg>
                    </div>
                `;
        }
      }┬╖
      // Legend
      const legendHtml = `
            <div class=\"chart-legend\">
                <div class=\"legend-item\">
                    <span class=\"legend-bar\"></span>
                    <span>Weekly PRs</span>
                </div>
                <div class=\"legend-item\">
                    <span class=\"legend-line\"></span>
                    <span>4-week avg</span>
                </div>
            </div>
        `;┬╖
      chartEl.innerHTML = `
            <div class=\"chart-with-trend\">
                <div class=\"bar-chart\">${barsHtml}</div>
                ${trendLineHtml}
            </div>
            ${legendHtml}
        `;
    }┬╖
    /**
     * Render cycle time distribution.
     */
    function renderCycleDistribution(distributions: any[]): void {
      const distEl = elements[\"cycle-distribution\"];
      if (!distEl) return;┬╖
      if (!distributions || !distributions.length) {
        distEl.innerHTML = '<p class=\"no-data\">No data for selected range</p>';
        return;
      }┬╖
      const buckets: Record<string, number> = {
        \"0-1h\": 0,
        \"1-4h\": 0,
        \"4-24h\": 0,
        \"1-3d\": 0,
        \"3-7d\": 0,
        \"7d+\": 0,
      };
      distributions.forEach((d) => {
        Object.entries(d.cycle_time_buckets || {}).forEach(([key, val]) => {
          buckets[key] = (buckets[key] || 0) + (val as number);
        });
      });┬╖
      const total = Object.values(buckets).reduce((a, b) => a + b, 0);
      if (total === 0) {
        distEl.innerHTML = '<p class=\"no-data\">No cycle time data</p>';
        return;
      }┬╖
      const html = Object.entries(buckets)
        .map(([label, count]) => {
          const pct = ((count / total) * 100).toFixed(1);
          return `
                <div class=\"dist-row\">
                    <span class=\"dist-label\">${label}</span>
                    <div class=\"dist-bar-bg\">
                        <div class=\"dist-bar\" style=\"width: ${pct}%\"></div>
                    </div>
                    <span class=\"dist-value\">${count} (${pct}%)</span>
                </div>
            `;
        })
        .join(\"\");┬╖
      distEl.innerHTML = html;
    }┬╖
    /**
     * Render cycle time trend chart (line chart with P50 and P90).
     */
    function renderCycleTimeTrend(rollups: Rollup[]): void {
      const trendEl = elements[\"cycle-time-trend\"];
      if (!trendEl) return;┬╖
      if (!rollups || rollups.length < 2) {
        trendEl.innerHTML = '<p class=\"no-data\">Not enough data for trend</p>';
        return;
      }┬╖
      const p50Data = rollups
        .map((r) => ({ week: r.week, value: r.cycle_time_p50 }))
        .filter((d): d is { week: string; value: number } => d.value !== null);
      const p90Data = rollups
        .map((r) => ({ week: r.week, value: r.cycle_time_p90 }))
        .filter((d): d is { week: string; value: number } => d.value !== null);┬╖
      if (p50Data.length < 2 && p90Data.length < 2) {
        trendEl.innerHTML = '<p class=\"no-data\">No cycle time data available</p>';
        return;
      }┬╖
      const allValues = [
        ...p50Data.map((d) => d.value),
        ...p90Data.map((d) => d.value),
      ];
      const maxVal = Math.max(...allValues);
      const minVal = Math.min(...allValues);
      const range = maxVal - minVal || 1;┬╖
      const width = 100;
      const height = 180;
      const padding = { top: 10, right: 10, bottom: 25, left: 40 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;┬╖
      // Generate paths
      const generatePath = (data: { week: string; value: number }[]) => {
        const points = data.map((d) => {
          const dataIndex = rollups.findIndex((r) => r.week === d.week);
          const x = padding.left + (dataIndex / (rollups.length - 1)) * chartWidth;
          const y =
            padding.top + chartHeight - ((d.value - minVal) / range) * chartHeight;
          return { x, y, week: d.week, value: d.value };
        });
        const pathD = points
          .map(
            (p, i) => `${i === 0 ? \"M\" : \"L\"} ${p.x.toFixed(1)} ${p.y.toFixed(1)}`,
          )
          .join(\" \");
        return { pathD, points };
      };┬╖
      const p50Path = p50Data.length >= 2 ? generatePath(p50Data) : null;
      const p90Path = p90Data.length >= 2 ? generatePath(p90Data) : null;┬╖
      // Y-axis labels
      const yLabels = [minVal, (minVal + maxVal) / 2, maxVal];┬╖
      const svgContent = `
            <svg viewBox=\"0 0 ${width} ${height}\" preserveAspectRatio=\"xMidYMid meet\">
                <!-- Grid lines -->
                ${yLabels
                  .map((val, i) => {
                    const y =
                      padding.top +
                      chartHeight -
                      (i / (yLabels.length - 1)) * chartHeight;
                    return `<line class=\"line-chart-grid\" x1=\"${padding.left}\" y1=\"${y}\" x2=\"${width - padding.right}\" y2=\"${y}\"/>`;
                  })
                  .join(\"\")}┬╖
                <!-- Y-axis labels -->
                ${yLabels
                  .map((val, i) => {
                    const y =
                      padding.top +
                      chartHeight -
                      (i / (yLabels.length - 1)) * chartHeight;
                    return `<text class=\"line-chart-axis\" x=\"${padding.left - 4}\" y=\"${y + 3}\" text-anchor=\"end\">${formatDuration(val)}</text>`;
                  })
                  .join(\"\")}┬╖
                <!-- Lines -->
                ${p90Path ? `<path class=\"line-chart-p90\" d=\"${p90Path.pathD}\" vector-effect=\"non-scaling-stroke\"/>` : \"\"}
                ${p50Path ? `<path class=\"line-chart-p50\" d=\"${p50Path.pathD}\" vector-effect=\"non-scaling-stroke\"/>` : \"\"}┬╖
                <!-- Dots -->
                ${p90Path ? p90Path.points.map((p) => `<circle class=\"line-chart-dot\" cx=\"${p.x}\" cy=\"${p.y}\" r=\"3\" fill=\"var(--warning)\" data-week=\"${p.week}\" data-value=\"${p.value}\" data-metric=\"P90\"/>`).join(\"\") : \"\"}
                ${p50Path ? p50Path.points.map((p) => `<circle class=\"line-chart-dot\" cx=\"${p.x}\" cy=\"${p.y}\" r=\"3\" fill=\"var(--primary)\" data-week=\"${p.week}\" data-value=\"${p.value}\" data-metric=\"P50\"/>`).join(\"\") : \"\"}
            </svg>
        `;┬╖
      const legendHtml = `
            <div class=\"chart-legend\">
                <div class=\"legend-item\">
                    <span class=\"chart-tooltip-dot legend-p50\"></span>
                    <span>P50 (Median)</span>
                </div>
                <div class=\"legend-item\">
                    <span class=\"chart-tooltip-dot legend-p90\"></span>
                    <span>P90</span>
                </div>
            </div>
        `;┬╖
      trendEl.innerHTML = `<div class=\"line-chart\">${svgContent}</div>${legendHtml}`;┬╖
      // Add tooltip interactions
      addChartTooltips(trendEl, (dot: HTMLElement) => {
        const week = dot.dataset[\"week\"];
        const value = parseFloat(dot.dataset[\"value\"] || \"0\");
        const metric = dot.dataset[\"metric\"];
        return `
                <div class=\"chart-tooltip-title\">${week}</div>
                <div class=\"chart-tooltip-row\">
                    <span class=\"chart-tooltip-label\">
                        <span class=\"chart-tooltip-dot ${metric === \"P50\" ? \"legend-p50\" : \"legend-p90\"}\"></span>
                        ${metric}
                    </span>
                    <span>${formatDuration(value)}</span>
                </div>
            `;
      });
    }┬╖
    /**
     * Render reviewer activity chart (horizontal bar chart).
     */
    function renderReviewerActivity(rollups: Rollup[]): void {
      const revEl = elements[\"reviewer-activity\"];
      if (!revEl) return;┬╖
      if (!rollups || !rollups.length) {
        revEl.innerHTML = '<p class=\"no-data\">No reviewer data available</p>';
        return;
      }┬╖
      // Take last 8 weeks for display
      const recentRollups = rollups.slice(-8);
      const maxReviewers = Math.max(
        ...recentRollups.map((r) => r.reviewers_count || 0),
      );┬╖
      if (maxReviewers === 0) {
        revEl.innerHTML = '<p class=\"no-data\">No reviewer data available</p>';
        return;
      }┬╖
      const barsHtml = recentRollups
        .map((r) => {
          const count = r.reviewers_count || 0;
          const pct = (count / maxReviewers) * 100;
          const weekLabel = r.week.split(\"-W\")[1];
          return `
                <div class=\"h-bar-row\" title=\"${r.week}: ${count} reviewers\">
                    <span class=\"h-bar-label\">W${weekLabel}</span>
                    <div class=\"h-bar-container\">
                        <div class=\"h-bar\" style=\"width: ${pct}%\"></div>
                    </div>
                    <span class=\"h-bar-value\">${count}</span>
                </div>
            `;
        })
        .join(\"\");┬╖
      revEl.innerHTML = `<div class=\"horizontal-bar-chart\">${barsHtml}</div>`;
    }┬╖
    /**
     * Add tooltip interactions to a chart.
     */
    function addChartTooltips(
      container: HTMLElement,
      contentFn: (dot: HTMLElement) => string,
    ): void {
      const dots = container.querySelectorAll(\".line-chart-dot\");
      let tooltip: HTMLElement | null = null;┬╖
      dots.forEach((dotNode) => {
        const dot = dotNode as HTMLElement;
        dot.addEventListener(\"mouseenter\", () => {
          if (!tooltip) {
            tooltip = document.createElement(\"div\");
            tooltip.className = \"chart-tooltip\";
            container.appendChild(tooltip);
          }
          tooltip.innerHTML = contentFn(dot);
          tooltip.style.display = \"block\";┬╖
          // Position tooltip
          const rect = container.getBoundingClientRect();
          const dotRect = dot.getBoundingClientRect();
          tooltip.style.left = `${dotRect.left - rect.left + 10}px`;
          tooltip.style.top = `${dotRect.top - rect.top - 40}px`;
        });┬╖
        dot.addEventListener(\"mouseleave\", () => {
          if (tooltip) {
            tooltip.style.display = \"none\";
          }
        });
      });
    }┬╖
    /**
     * Update feature tabs based on manifest.
     */
    async function updateFeatureTabs(): Promise<void> {
      if (!loader) return;┬╖
      // Check if loader supports loadPredictions/loadInsights
      if (typeof (loader as any).loadPredictions !== \"function\") return;┬╖
      const predictionsContent = document.getElementById(\"tab-predictions\");
      const predictionsUnavailable = document.getElementById(
        \"predictions-unavailable\",
      );
      if (predictionsContent) {
        const predictionsResult = await (loader as any).loadPredictions();┬╖
        if (
          predictionsResult?.state === \"ok\" &&
          predictionsResult.data?.forecasts?.length > 0
        ) {
          renderPredictions(predictionsContent, predictionsResult.data);
        } else if (predictionsUnavailable) {
          predictionsUnavailable.classList.remove(\"hidden\");
        }
      }┬╖
      const aiContent = document.getElementById(\"tab-ai-insights\");
      const aiUnavailable = document.getElementById(\"ai-unavailable\");
      if (aiContent) {
        const insightsResult = await (loader as any).loadInsights();┬╖
        if (
          insightsResult?.state === \"ok\" &&
          insightsResult.data?.insights?.length > 0
        ) {
          renderAIInsights(aiContent, insightsResult.data);
        } else if (aiUnavailable) {
          aiUnavailable.classList.remove(\"hidden\");
        }
      }
    }┬╖
    /**
     * Render predictions.
     */
    function renderPredictions(container: HTMLElement, predictions: any): void {
      const content = document.createElement(\"div\");
      content.className = \"predictions-content\";┬╖
      if (predictions.is_stub) {
        content.innerHTML += `<div class=\"stub-warning\">ΓÜá∩╕Å Demo data</div>`;
      }┬╖
      predictions.forecasts.forEach((forecast: any) => {
        const label = forecast.metric
          .replace(/_/g, \" \")
          .replace(/\\b\\w/g, (c: string) => c.toUpperCase());
        content.innerHTML += `
                <div class=\"forecast-section\">
                    <h4>${label} (${forecast.unit})</h4>
                    <table class=\"forecast-table\">
                        <thead><tr><th>Week</th><th>Predicted</th><th>Range</th></tr></thead>
                        <tbody>
                            ${forecast.values
                              .map(
                                (v: any) => `
                                <tr>
                                    <td>${v.period_start}</td>
                                    <td>${v.predicted}</td>
                                    <td>${v.lower_bound} - ${v.upper_bound}</td>
                                </tr>
                            `,
                              )
                              .join(\"\")}
                        </tbody>
                    </table>
                </div>
            `;
      });┬╖
      const unavailable = container.querySelector(\".feature-unavailable\");
      if (unavailable) unavailable.classList.add(\"hidden\");
      container.appendChild(content);
    }┬╖
    /**
     * Render AI insights.
     */
    function renderAIInsights(container: HTMLElement, insights: any): void {
      const content = document.createElement(\"div\");
      content.className = \"insights-content\";┬╖
      if (insights.is_stub) {
        content.innerHTML += `<div class=\"stub-warning\">ΓÜá∩╕Å Demo data</div>`;
      }┬╖
      const icons: Record<string, string> = {
        critical: \"≡ƒö┤\",
        warning: \"≡ƒƒí\",
        info: \"≡ƒö╡\",
      };
      [\"critical\", \"warning\", \"info\"].forEach((severity) => {
        const items = insights.insights.filter((i: any) => i.severity === severity);
        if (!items.length) return;┬╖
        content.innerHTML += `
                <div class=\"severity-section\">
                    <h4>${icons[severity]} ${severity.charAt(0).toUpperCase() + severity.slice(1)}</h4>
                    <div class=\"insight-cards\">
                        ${items
                          .map(
                            (i: any) => `
                            <div class=\"insight-card ${i.severity}\">
                                <div class=\"insight-category\">${i.category}</div>
                                <h5>${i.title}</h5>
                                <p>${i.description}</p>
                            </div>
                        `,
                          )
                          .join(\"\")}
                    </div>
                </div>
            `;
      });┬╖
      const unavailable = container.querySelector(\".feature-unavailable\");
      if (unavailable) unavailable.classList.add(\"hidden\");
      container.appendChild(content);
    }┬╖
    // ============================================================================
    // Event Handlers
    // ============================================================================┬╖
    function handleDateRangeChange(e: Event): void {
      const target = e.target as HTMLSelectElement;
      const value = target.value;┬╖
      if (value === \"custom\") {
        elements[\"custom-dates\"]?.classList.remove(\"hidden\");
        return;
      }┬╖
      elements[\"custom-dates\"]?.classList.add(\"hidden\");┬╖
      const days = parseInt(value, 10);
      const coverage = loader?.getCoverage() || null;
      const endDate = coverage?.date_range?.max
        ? new Date(coverage.date_range.max)
        : new Date();
      const startDate = new Date(endDate);
      startDate.setDate(startDate.getDate() - days);┬╖
      currentDateRange = { start: startDate, end: endDate };
      updateUrlState();
      refreshMetrics();
    }┬╖
    function applyCustomDates(): void {
      const start = (elements[\"start-date\"] as HTMLInputElement)?.value;
      const end = (elements[\"end-date\"] as HTMLInputElement)?.value;┬╖
      if (!start || !end) return;┬╖
      currentDateRange = { start: new Date(start), end: new Date(end) };
      updateUrlState();
      refreshMetrics();
    }┬╖
    function switchTab(tabId: string): void {
      elements.tabs?.forEach((tab: HTMLElement) => {
        tab.classList.toggle(\"active\", tab.dataset[\"tab\"] === tabId);
      });┬╖
      document.querySelectorAll(\".tab-content\").forEach((content) => {
        content.classList.toggle(\"active\", content.id === `tab-${tabId}`);
        content.classList.toggle(\"hidden\", content.id !== `tab-${tabId}`);
      });┬╖
      updateUrlState();
    }┬╖
    // ============================================================================
    // Filter Management
    // ============================================================================┬╖
    /**
     * Populate filter dropdowns from loaded dimensions.
     */
    function populateFilterDropdowns(dimensions: any): void {
      if (!dimensions) return;┬╖
      // Populate repository filter
      const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
      if (repoFilter && dimensions.repositories?.length > 0) {
        repoFilter.innerHTML = '<option value=\"\">All</option>';
        dimensions.repositories.forEach((repo: any) => {
          const option = document.createElement(\"option\");
          option.value = repo.id || repo.name;
          option.textContent = repo.name;
          repoFilter.appendChild(option);
        });
        elements[\"repo-filter-group\"]?.classList.remove(\"hidden\");
      } else {
        elements[\"repo-filter-group\"]?.classList.add(\"hidden\");
      }┬╖
      // Populate team filter
      const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
      if (teamFilter && dimensions.teams?.length > 0) {
        teamFilter.innerHTML = '<option value=\"\">All</option>';
        dimensions.teams.forEach((team: any) => {
          const option = document.createElement(\"option\");
          option.value = team.id || team.name;
          option.textContent = team.name;
          teamFilter.appendChild(option);
        });
        elements[\"team-filter-group\"]?.classList.remove(\"hidden\");
      } else {
        elements[\"team-filter-group\"]?.classList.add(\"hidden\");
      }┬╖
      // Restore filter state from URL
      restoreFiltersFromUrl();
    }┬╖
    /**
     * Handle filter dropdown change.
     */
    function handleFilterChange(): void {
      const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
      const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;┬╖
      const repoValues = repoFilter
        ? Array.from(repoFilter.selectedOptions)
            .map((o) => o.value)
            .filter((v) => v)
        : [];
      const teamValues = teamFilter
        ? Array.from(teamFilter.selectedOptions)
            .map((o) => o.value)
            .filter((v) => v)
        : [];┬╖
      currentFilters = { repos: repoValues, teams: teamValues };┬╖
      updateFilterUI();
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Clear all filters.
     */
    function clearAllFilters(): void {
      currentFilters = { repos: [], teams: [] };┬╖
      const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
      const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;┬╖
      if (repoFilter) {
        Array.from(repoFilter.options).forEach(
          (o) => (o.selected = o.value === \"\"),
        );
      }
      if (teamFilter) {
        Array.from(teamFilter.options).forEach(
          (o) => (o.selected = o.value === \"\"),
        );
      }┬╖
      updateFilterUI();
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Remove a specific filter.
     */
    function removeFilter(type: string, value: string): void {
      if (type === \"repo\") {
        currentFilters.repos = currentFilters.repos.filter((v) => v !== value);
        const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
        if (repoFilter) {
          const option = repoFilter.querySelector(
            `option[value=\"${value}\"]`,
          ) as HTMLOptionElement | null;
          if (option) option.selected = false;
        }
      } else if (type === \"team\") {
        currentFilters.teams = currentFilters.teams.filter((v) => v !== value);
        const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
        if (teamFilter) {
          const option = teamFilter.querySelector(
            `option[value=\"${value}\"]`,
          ) as HTMLOptionElement | null;
          if (option) option.selected = false;
        }
      }┬╖
      updateFilterUI();
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Update filter UI.
     */
    function updateFilterUI(): void {
      const hasFilters =
        currentFilters.repos.length > 0 || currentFilters.teams.length > 0;┬╖
      if (elements[\"clear-filters\"]) {
        elements[\"clear-filters\"].classList.toggle(\"hidden\", !hasFilters);
      }┬╖
      if (elements[\"active-filters\"] && elements[\"filter-chips\"]) {
        elements[\"active-filters\"].classList.toggle(\"hidden\", !hasFilters);┬╖
        if (hasFilters) {
          renderFilterChips();
        } else {
          elements[\"filter-chips\"].innerHTML = \"\";
        }
      }
    }┬╖
    /**
     * Render filter chips for active filters.
     */
    function renderFilterChips(): void {
      const chipsEl = elements[\"filter-chips\"] as HTMLElement | null;
      if (!chipsEl) return;┬╖
      const chips: string[] = [];┬╖
      currentFilters.repos.forEach((value) => {
        const label = getFilterLabel(\"repo\", value);
        chips.push(createFilterChip(\"repo\", value, label));
      });┬╖
      currentFilters.teams.forEach((value) => {
        const label = getFilterLabel(\"team\", value);
        chips.push(createFilterChip(\"team\", value, label));
      });┬╖
      chipsEl.innerHTML = chips.join(\"\");┬╖
      chipsEl.querySelectorAll(\".filter-chip-remove\").forEach((btnNode) => {
        const btn = btnNode as HTMLElement;
        btn.addEventListener(\"click\", () => {
          const type = btn.dataset[\"type\"];
          const val = btn.dataset[\"value\"];
          if (type && val) removeFilter(type, val);
        });
      });
    }┬╖
    /**
     * Get display label for a filter value.
     */
    function getFilterLabel(type: string, value: string): string {
      if (type === \"repo\") {
        const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
        const option = repoFilter?.querySelector(`option[value=\"${value}\"]`);
        return option?.textContent || value;
      }
      if (type === \"team\") {
        const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
        const option = teamFilter?.querySelector(`option[value=\"${value}\"]`);
        return option?.textContent || value;
      }
      return value;
    }┬╖
    /**
     * Create HTML for a filter chip.
     */
    function createFilterChip(type: string, value: string, label: string): string {
      const prefix = type === \"repo\" ? \"repo\" : \"team\";
      return `
            <span class=\"filter-chip\">
                <span class=\"filter-chip-label\">${prefix}: ${label}</span>
                <span class=\"filter-chip-remove\" data-type=\"${type}\" data-value=\"${value}\">&times;</span>
            </span>
        `;
    }┬╖
    /**
     * Restore filters from URL parameters.
     */
    function restoreFiltersFromUrl(): void {
      const params = new URLSearchParams(window.location.search);┬╖
      const reposParam = params.get(\"repos\");
      const teamsParam = params.get(\"teams\");┬╖
      if (reposParam) {
        currentFilters.repos = reposParam.split(\",\").filter((v) => v);
        const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
        if (repoFilter) {
          currentFilters.repos.forEach((value) => {
            const option = repoFilter.querySelector(
              `option[value=\"${value}\"]`,
            ) as HTMLOptionElement | null;
            if (option) option.selected = true;
          });
        }
      }┬╖
      if (teamsParam) {
        currentFilters.teams = teamsParam.split(\",\").filter((v) => v);
        const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
        if (teamFilter) {
          currentFilters.teams.forEach((value) => {
            const option = teamFilter.querySelector(
              `option[value=\"${value}\"]`,
            ) as HTMLOptionElement | null;
            if (option) option.selected = true;
          });
        }
      }┬╖
      updateFilterUI();
    }┬╖
    // ============================================================================
    // Comparison Mode
    // ============================================================================┬╖
    /**
     * Toggle comparison mode on/off.
     */
    function toggleComparisonMode(): void {
      comparisonMode = !comparisonMode;┬╖
      elements[\"compare-toggle\"]?.classList.toggle(\"active\", comparisonMode);
      elements[\"comparison-banner\"]?.classList.toggle(\"hidden\", !comparisonMode);┬╖
      if (comparisonMode) {
        updateComparisonBanner();
      }┬╖
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Exit comparison mode.
     */
    function exitComparisonMode(): void {
      comparisonMode = false;
      elements[\"compare-toggle\"]?.classList.remove(\"active\");
      elements[\"comparison-banner\"]?.classList.add(\"hidden\");
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Update the comparison banner with date ranges.
     */
    function updateComparisonBanner(): void {
      if (!currentDateRange.start || !currentDateRange.end) return;┬╖
      const formatDate = (date: Date) =>
        date.toLocaleDateString(\"en-US\", {
          month: \"short\",
          day: \"numeric\",
          year: \"numeric\",
        });┬╖
      // Current period
      const currentStart = formatDate(currentDateRange.start);
      const currentEnd = formatDate(currentDateRange.end);
      if (elements[\"current-period-dates\"]) {
        elements[\"current-period-dates\"].textContent =
          `${currentStart} - ${currentEnd}`;
      }┬╖
      // Previous period
      const prevPeriod = getPreviousPeriod(
        currentDateRange.start,
        currentDateRange.end,
      );
      const prevStart = formatDate(prevPeriod.start);
      const prevEnd = formatDate(prevPeriod.end);
      if (elements[\"previous-period-dates\"]) {
        elements[\"previous-period-dates\"].textContent = `${prevStart} - ${prevEnd}`;
      }
    }┬╖
    // ============================================================================
    // Export Functions
    // ============================================================================┬╖
    /**
     * Toggle export menu visibility.
     */
    function toggleExportMenu(e: Event): void {
      e.stopPropagation();
      elements[\"export-menu\"]?.classList.toggle(\"hidden\");
    }┬╖
    /**
     * Export current data to CSV.
     */
    function exportToCsv(): void {
      elements[\"export-menu\"]?.classList.add(\"hidden\");┬╖
      if (!cachedRollups || cachedRollups.length === 0) {
        showToast(\"No data to export\", \"error\");
        return;
      }┬╖
      // Build CSV content
      const headers = [
        \"Week\",
        \"Start Date\",
        \"End Date\",
        \"PR Count\",
        \"Cycle Time P50 (min)\",
        \"Cycle Time P90 (min)\",
        \"Authors\",
        \"Reviewers\",
      ];
      const rows = cachedRollups.map((r) => [
        r.week,
        r.start_date || \"\",
        r.end_date || \"\",
        r.pr_count || 0,
        r.cycle_time_p50 != null ? r.cycle_time_p50.toFixed(1) : \"\",
        r.cycle_time_p90 != null ? r.cycle_time_p90.toFixed(1) : \"\",
        r.authors_count || 0,
        r.reviewers_count || 0,
      ]);┬╖
      const csvContent = [headers, ...rows]
        .map((row) => row.map((cell) => `\"${cell}\"`).join(\",\"))
        .join(\"\\n\");┬╖
      // Download file
      const blob = new Blob([csvContent], { type: \"text/csv;charset=utf-8;\" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement(\"a\");
      link.href = url;┬╖
      const dateStr = new Date().toISOString().split(\"T\")[0];
      link.download = `pr-insights-${dateStr}.csv`;┬╖
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);┬╖
      showToast(\"CSV exported successfully\", \"success\");
    }┬╖
    /**
     * Copy shareable link to clipboard.
     */
    async function copyShareableLink(): Promise<void> {
      elements[\"export-menu\"]?.classList.add(\"hidden\");┬╖
      try {
        await navigator.clipboard.writeText(window.location.href);
        showToast(\"Link copied to clipboard\", \"success\");
      } catch (_err) {
        // Fallback
        const textArea = document.createElement(\"textarea\");
        textArea.value = window.location.href;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand(\"copy\");
        document.body.removeChild(textArea);
        showToast(\"Link copied to clipboard\", \"success\");
      }
    }┬╖
    /**
     * Download raw CSV data as a ZIP file.
     */
    async function downloadRawDataZip(): Promise<void> {
      elements[\"export-menu\"]?.classList.add(\"hidden\");┬╖
      if (!currentBuildId || !artifactClient) {
        showToast(\"Raw data not available in direct URL mode\", \"error\");
        return;
      }┬╖
      try {
        showToast(\"Preparing download...\", \"success\");┬╖
        const artifact = await artifactClient.getArtifactMetadata(
          currentBuildId,
          \"csv-output\",
        );┬╖
        if (!artifact) {
          showToast(\"Raw CSV artifact not found in this pipeline run\", \"error\");
          return;
        }┬╖
        const downloadUrl = artifact.resource?.downloadUrl;
        if (!downloadUrl) {
          showToast(\"Download URL not available\", \"error\");
          return;
        }┬╖
        let zipUrl = downloadUrl;
        if (!zipUrl.includes(\"format=zip\")) {
          const separator = zipUrl.includes(\"?\") ? \"&\" : \"?\";
          zipUrl = `${zipUrl}${separator}format=zip`;
        }┬╖
        // Use the protected method from ArtifactClient
        const response = await (artifactClient as any)._authenticatedFetch(zipUrl);┬╖
        if (!response.ok) {
          if (response.status === 403 || response.status === 401) {
            showToast(\"Permission denied to download artifacts\", \"error\");
          } else {
            showToast(`Download failed: ${response.statusText}`, \"error\");
          }
          return;
        }┬╖
        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        const link = document.createElement(\"a\");
        link.href = url;┬╖
        const dateStr = new Date().toISOString().split(\"T\")[0];
        link.download = `pr-insights-raw-data-${dateStr}.zip`;┬╖
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);┬╖
        showToast(\"Download started\", \"success\");
      } catch (err) {
        console.error(\"Failed to download raw data:\", err);
        showToast(\"Failed to download raw data\", \"error\");
      }
    }┬╖
    /**
     * Show a toast notification.
     */
    function showToast(
      message: string,
      type: \"success\" | \"error\" = \"success\",
    ): void {
      const toast = document.createElement(\"div\");
      toast.className = `toast ${type}`;
      toast.textContent = message;
      document.body.appendChild(toast);┬╖
      setTimeout(() => {
        toast.remove();
      }, 3000);
    }┬╖
    // ============================================================================
    // Utility Functions
    // ============================================================================┬╖
    function showLoading(): void {
      hideAllPanels();
      elements[\"loading-state\"]?.classList.remove(\"hidden\");
    }┬╖
    function showContent(): void {
      hideAllPanels();
      elements[\"main-content\"]?.classList.remove(\"hidden\");
    }┬╖
    function updateDatasetInfo(manifest: any): void {
      const generatedAt = manifest?.generated_at
        ? new Date(manifest.generated_at).toLocaleString()
        : \"Unknown\";
      const runId = manifest?.run_id || \"\";┬╖
      const runInfo = elements[\"run-info\"];
      if (runInfo) {
        runInfo.textContent = `Generated: ${generatedAt}`;
        if (runId) runInfo.textContent += ` | Run: ${runId.slice(0, 8)}`;
      }
    }┬╖
    function formatDuration(minutes: number): string {
      if (minutes < 60) return `${Math.round(minutes)}m`;
      if (minutes < 1440) return `${(minutes / 60).toFixed(1)}h`;
      return `${(minutes / 1440).toFixed(1)}d`;
    }┬╖
    function median(arr: number[]): number {
      const sorted = [...arr].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      return sorted.length % 2
        ? sorted[mid]!
        : (sorted[mid - 1]! + sorted[mid]!) / 2;
    }┬╖
    function updateUrlState(): void {
      const params = new URLSearchParams(window.location.search);
      const newParams = new URLSearchParams();┬╖
      // Preserve config params
      if (params.get(\"dataset\")) newParams.set(\"dataset\", params.get(\"dataset\")!);
      if (params.get(\"pipelineId\"))
        newParams.set(\"pipelineId\", params.get(\"pipelineId\")!);┬╖
      // Add date range
      if (currentDateRange.start) {
        newParams.set(\"start\", currentDateRange.start.toISOString().split(\"T\")[0]!);
      }
      if (currentDateRange.end) {
        newParams.set(\"end\", currentDateRange.end.toISOString().split(\"T\")[0]!);
      }┬╖
      // Add active tab
      const activeTab = document.querySelector(\".tab.active\") as HTMLElement | null;
      if (activeTab && activeTab.dataset[\"tab\"] !== \"metrics\") {
        newParams.set(\"tab\", activeTab.dataset[\"tab\"]!);
      }┬╖
      // Add filters
      if (currentFilters.repos.length > 0) {
        newParams.set(\"repos\", currentFilters.repos.join(\",\"));
      }
      if (currentFilters.teams.length > 0) {
        newParams.set(\"teams\", currentFilters.teams.join(\",\"));
      }┬╖
      // Add comparison mode
      if (comparisonMode) {
        newParams.set(\"compare\", \"1\");
      }┬╖
      window.history.replaceState(
        {},
        \"\",
        `${window.location.pathname}?${newParams.toString()}`,
      );
    }┬╖
    function restoreStateFromUrl(): void {
      const params = new URLSearchParams(window.location.search);┬╖
      const startParam = params.get(\"start\");
      const endParam = params.get(\"end\");
      if (startParam && endParam) {
        currentDateRange = { start: new Date(startParam), end: new Date(endParam) };
        const dateRangeEl = elements[\"date-range\"] as HTMLSelectElement | null;
        if (dateRangeEl) {
          dateRangeEl.value = \"custom\";
          elements[\"custom-dates\"]?.classList.remove(\"hidden\");
        }
        if (elements[\"start-date\"]) elements[\"start-date\"].value = startParam;
        if (elements[\"end-date\"]) elements[\"end-date\"].value = endParam;
      }┬╖
      const tabParam = params.get(\"tab\");
      if (tabParam) {
        setTimeout(() => switchTab(tabParam), 0);
      }┬╖
      // Restore comparison mode
      const compareParam = params.get(\"compare\");
      if (compareParam === \"1\") {
        comparisonMode = true;
        elements[\"compare-toggle\"]?.classList.add(\"active\");
        elements[\"comparison-banner\"]?.classList.remove(\"hidden\");
      }
    }┬╖
    // ============================================================================
    // Initialize
    // ============================================================================┬╖
    if (document.readyState === \"loading\") {
      document.addEventListener(\"DOMContentLoaded\", init);
    } else {
      init();
    }
    "

      44 |
      45 |     it("should log source project origin", () => {
    > 46 |       expect(dashboardCode).toMatch(/console\.log.*Source project/);
         |                             ^
      47 |     });
      48 |
      49 |     it("should use targetProjectId for ArtifactClient initialization", () => {

      at Object.<anonymous> (tests/cross-project-settings.test.ts:46:29)

  ΓùÅ Cross-Project Settings ΓÇ║ dashboard.ts configuration ΓÇ║ should pass targetProjectId to resolveFromPipelineId

    expect(received).toContain(expected) // indexOf

    Expected substring: "resolveFromPipelineId(sourceConfig.pipelineId, targetProjectId)"
    Received string:    "/**
     * PR Insights Dashboard
     *
     * Project-level hub that loads data from pipeline artifacts.
     * Uses Azure DevOps Extension SDK for authentication.
     *
     * Configuration precedence:
     * 1. ?dataset=<url> - Direct URL (DEV ONLY)
     * 2. ?pipelineId=<id> - Query parameter override
     * 3. Extension settings - User-scoped saved preference
     * 4. Auto-discovery - Find pipelines with 'aggregates' artifact
     */┬╖
    import { DatasetLoader, IDatasetLoader, Rollup } from \"./dataset-loader\";
    import { ArtifactClient } from \"./artifact-client\";
    import {
      PrInsightsError,
      ErrorTypes,
      createSetupRequiredError,
      createNoSuccessfulBuildsError,
      createArtifactsMissingError,
      createInvalidConfigError,
      SetupRequiredDetails,
      MultiplePipelinesDetails,
      ArtifactsMissingDetails,
    } from \"./error-types\";┬╖
    // Dashboard state
    let loader: IDatasetLoader | null = null;
    let artifactClient: ArtifactClient | null = null;
    let currentDateRange: { start: Date | null; end: Date | null } = {
      start: null,
      end: null,
    };
    let currentFilters: { repos: string[]; teams: string[] } = {
      repos: [],
      teams: [],
    };
    let comparisonMode = false;
    let cachedRollups: Rollup[] = []; // Cache for export
    let currentBuildId: number | null = null; // Store build ID for raw data download
    let sdkInitialized = false;┬╖
    // Settings keys for extension data storage (must match settings.js)
    const SETTINGS_KEY_PROJECT = \"pr-insights-source-project\";
    const SETTINGS_KEY_PIPELINE = \"pr-insights-pipeline-id\";┬╖
    // Feature flags
    const ENABLE_PHASE5_FEATURES = true;┬╖
    // DOM element cache
    const elements: Record<string, any> = {};┬╖
    /**
     * Phase 4: Production-safe metrics collector
     */
    const IS_PRODUCTION =
      typeof window !== \"undefined\" &&
      (window as any).process?.env?.NODE_ENV === \"production\";
    const DEBUG_ENABLED =
      !IS_PRODUCTION &&
      ((typeof window !== \"undefined\" && (window as any).__DASHBOARD_DEBUG__) ||
        (typeof window !== \"undefined\" &&
          new URLSearchParams(window.location.search).has(\"debug\")));┬╖
    interface PerformanceMetric {
      name: string;
      duration: number;
      timestamp: number;
    }┬╖
    const metricsCollector = DEBUG_ENABLED
      ? {
          marks: new Map<string, number>(),
          measures: [] as PerformanceMetric[],
          mark(name: string) {
            if (!performance || !performance.mark) return;
            try {
              performance.mark(name);
              this.marks.set(name, performance.now());
            } catch (_e) {
              /* ignore */
            }
          },
          measure(name: string, startMark: string, endMark: string) {
            if (!performance || !performance.measure) return;
            try {
              performance.measure(name, startMark, endMark);
              const entries = performance.getEntriesByName(name, \"measure\");
              if (entries.length > 0) {
                const lastEntry = entries[entries.length - 1];
                if (lastEntry) {
                  this.measures.push({
                    name,
                    duration: lastEntry.duration,
                    timestamp: Date.now(),
                  });
                }
              }
            } catch (_e) {
              /* ignore */
            }
          },
          getMetrics() {
            return {
              marks: Array.from(this.marks.entries()).map(([name, time]) => ({
                name,
                time,
              })),
              measures: [...this.measures],
            };
          },
          reset() {
            this.marks.clear();
            this.measures = [];
            if (performance && performance.clearMarks) performance.clearMarks();
            if (performance && performance.clearMeasures)
              performance.clearMeasures();
          },
        }
      : null;┬╖
    if (DEBUG_ENABLED && typeof window !== \"undefined\") {
      (window as any).__dashboardMetrics = metricsCollector;
    }┬╖
    // ============================================================================
    // SDK Initialization
    // ============================================================================┬╖
    /**
     * Initialize Azure DevOps Extension SDK.
     */
    async function initializeAdoSdk(): Promise<void> {
      if (sdkInitialized) return;┬╖
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error(\"Azure DevOps SDK initialization timed out\"));
        }, 10000);┬╖
        VSS.init({
          explicitNotifyLoaded: true,
          usePlatformScripts: true,
          usePlatformStyles: true,
        });┬╖
        VSS.ready(() => {
          clearTimeout(timeout);
          sdkInitialized = true;┬╖
          // Update project name in UI
          const webContext = VSS.getWebContext();
          const projectNameEl = document.getElementById(\"current-project-name\");
          if (projectNameEl && webContext?.project?.name) {
            projectNameEl.textContent = webContext.project.name;
          }┬╖
          VSS.notifyLoadSucceeded();
          resolve();
        });
      });
    }┬╖
    // ============================================================================
    // Configuration Resolution
    // ============================================================================┬╖
    /**
     * Parse and validate query parameters.
     */
    function parseQueryParams():
      | { mode: string; value: any; warning?: string | null }
      | PrInsightsError {
      const params = new URLSearchParams(window.location.search);┬╖
      const datasetUrl = params.get(\"dataset\");
      const pipelineIdStr = params.get(\"pipelineId\");┬╖
      // Check for dataset URL (highest priority)
      if (datasetUrl) {
        // Validate URL
        if (!datasetUrl.startsWith(\"https://\")) {
          return createInvalidConfigError(
            \"dataset\",
            datasetUrl,
            \"Must be a valid HTTPS URL\",
          );
        }┬╖
        // Security warning for non-ADO domains
        const IS_DEV =
          window.location.hostname === \"localhost\" || params.has(\"devMode\");┬╖
        if (!IS_DEV) {
          try {
            const urlHost = new URL(datasetUrl).hostname;
            const isAdoDomain =
              urlHost.endsWith(\"dev.azure.com\") ||
              urlHost.endsWith(\".visualstudio.com\") ||
              urlHost.endsWith(\".azure.com\");
            if (!isAdoDomain) {
              console.warn(
                `SECURITY: ?dataset= URL \"${urlHost}\" is not an Azure DevOps domain. ` +
                  `This parameter is intended for development only.`,
              );
            }
          } catch (_e) {
            return createInvalidConfigError(
              \"dataset\",
              datasetUrl,
              \"Invalid URL format\",
            );
          }
        }┬╖
        let warning: string | null = null;
        if (pipelineIdStr) {
          warning = \"Both dataset and pipelineId specified; using dataset\";
          console.warn(warning);
        }┬╖
        return { mode: \"direct\", value: datasetUrl, warning };
      }┬╖
      // Check for pipelineId
      if (pipelineIdStr) {
        const pipelineId = parseInt(pipelineIdStr, 10);
        if (isNaN(pipelineId) || pipelineId <= 0) {
          return createInvalidConfigError(
            \"pipelineId\",
            pipelineIdStr,
            \"Must be a positive integer\",
          );
        }
        return { mode: \"explicit\", value: pipelineId };
      }┬╖
      return { mode: \"discover\", value: null };
    }┬╖
    /**
     * Get source configuration from extension settings.
     */
    async function getSourceConfig(): Promise<{
      projectId: string | null;
      pipelineId: number | null;
    }> {
      const result: { projectId: string | null; pipelineId: number | null } = {
        projectId: null,
        pipelineId: null,
      };
      try {
        const dataService = await VSS.getService<IExtensionDataService>(
          VSS.ServiceIds.ExtensionData,
        );┬╖
        // Get source project ID
        const savedProjectId = await dataService.getValue<string>(
          SETTINGS_KEY_PROJECT,
          { scopeType: \"User\" },
        );
        if (
          savedProjectId &&
          typeof savedProjectId === \"string\" &&
          savedProjectId.trim()
        ) {
          result.projectId = savedProjectId.trim();
        }┬╖
        // Get pipeline definition ID
        const savedPipelineId = await dataService.getValue<number>(
          SETTINGS_KEY_PIPELINE,
          { scopeType: \"User\" },
        );
        if (
          savedPipelineId &&
          typeof savedPipelineId === \"number\" &&
          savedPipelineId > 0
        ) {
          result.pipelineId = savedPipelineId;
        }
      } catch (e) {
        console.log(\"Could not read extension settings:\", e);
      }
      return result;
    }┬╖
    /**
     * Clear stale pipeline ID setting.
     */
    async function clearStalePipelineSetting(): Promise<void> {
      try {
        const dataService = await VSS.getService<IExtensionDataService>(
          VSS.ServiceIds.ExtensionData,
        );
        await dataService.setValue(SETTINGS_KEY_PIPELINE, null, {
          scopeType: \"User\",
        });
        console.log(\"Cleared stale pipeline setting to re-enable auto-discovery\");
      } catch (e) {
        console.warn(\"Could not clear stale pipeline setting:\", e);
      }
    }┬╖
    /**
     * Resolve configuration using precedence rules.
     */
    async function resolveConfiguration(): Promise<{
      buildId?: number;
      artifactName?: string;
      directUrl?: string;
    }> {
      const queryResult = parseQueryParams();┬╖
      // Check for parsing error
      if (queryResult instanceof PrInsightsError) {
        throw queryResult;
      }┬╖
      // Mode: direct URL
      if (queryResult.mode === \"direct\") {
        return { directUrl: queryResult.value };
      }┬╖
      // Get current project context
      const webContext = VSS.getWebContext();
      const currentProjectId = webContext.project?.id;
      if (!currentProjectId) {
        throw new Error(\"No project context available\");
      }┬╖
      // Get configured source from settings
      const sourceConfig = await getSourceConfig();┬╖
      // Determine which project to use for artifact access
      const targetProjectId = sourceConfig.projectId || currentProjectId;┬╖
      console.log(
        `Source project: ${targetProjectId}${sourceConfig.projectId ? \" (from settings)\" : \" (current context)\"}`,
      );┬╖
      // Initialize artifact client with target project
      artifactClient = new ArtifactClient(targetProjectId);
      await artifactClient.initialize();┬╖
      // Mode: explicit pipelineId from query
      if (queryResult.mode === \"explicit\") {
        return await resolveFromPipelineId(queryResult.value, targetProjectId);
      }┬╖
      // Check settings for pipeline ID
      if (sourceConfig.pipelineId) {
        console.log(
          `Using pipeline definition ID from settings: ${sourceConfig.pipelineId}`,
        );
        try {
          return await resolveFromPipelineId(
            sourceConfig.pipelineId,
            targetProjectId,
          );
        } catch (error: any) {
          console.warn(
            `Saved pipeline ${sourceConfig.pipelineId} is invalid, falling back to auto-discovery:`,
            error.message,
          );
          await clearStalePipelineSetting();
        }
      }┬╖
      // Mode: discovery in target project
      return await discoverAndResolve(targetProjectId);
    }┬╖
    /**
     * Resolve artifact info from a specific pipeline ID.
     */
    async function resolveFromPipelineId(
      pipelineId: number,
      projectId: string,
    ): Promise<{ buildId: number; artifactName: string }> {
      // Get Build REST client
      const buildClient = await getBuildClient();┬╖
      // Get latest successful build
      const builds = await buildClient.getBuilds(
        projectId,
        [pipelineId],
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined, // reasonFilter
        2, // statusFilter: Completed
        6, // resultFilter: Succeeded (2) | PartiallySucceeded (4)
        undefined,
        undefined,
        1, // top
      );┬╖
      if (!builds || builds.length === 0) {
        const definitions = await buildClient.getDefinitions(
          projectId,
          undefined,
          undefined,
          undefined,
          2,
          undefined,
          undefined,
          undefined,
          [pipelineId],
        );
        const name = definitions?.[0]?.name || `ID ${pipelineId}`;
        throw createNoSuccessfulBuildsError(name);
      }┬╖
      const latestBuild = builds[0];
      if (!latestBuild) throw new Error(\"Failed to retrieve latest build\");┬╖
      // Check for aggregates artifact
      if (!artifactClient) throw new Error(\"ArtifactClient not initialized\");
      const artifacts = await artifactClient.getArtifacts(latestBuild.id);
      const hasAggregates = artifacts.some((a) => a.name === \"aggregates\");┬╖
      if (!hasAggregates) {
        const definitions = await buildClient.getDefinitions(
          projectId,
          undefined,
          undefined,
          undefined,
          2,
          undefined,
          undefined,
          undefined,
          [pipelineId],
        );
        const name = definitions?.[0]?.name || `ID ${pipelineId}`;
        throw createArtifactsMissingError(name, latestBuild.id);
      }┬╖
      return { buildId: latestBuild.id, artifactName: \"aggregates\" };
    }┬╖
    /**
     * Discover pipelines with aggregates and resolve.
     */
    async function discoverAndResolve(
      projectId: string,
    ): Promise<{ buildId: number; artifactName: string }> {
      const matches = await discoverInsightsPipelines(projectId);┬╖
      if (matches.length === 0) {
        throw createSetupRequiredError();
      }┬╖
      const firstMatch = matches[0];
      if (!firstMatch) throw createSetupRequiredError();┬╖
      return { buildId: firstMatch.buildId, artifactName: \"aggregates\" };
    }┬╖
    /**
     * Discover pipelines with aggregates artifact.
     */
    async function discoverInsightsPipelines(
      projectId: string,
    ): Promise<Array<{ id: number; name: string; buildId: number }>> {
      const buildClient = await getBuildClient();
      const matches: Array<{ id: number; name: string; buildId: number }> = [];┬╖
      const definitions = await buildClient.getDefinitions(
        projectId,
        undefined,
        undefined,
        undefined,
        2,
        50,
      );┬╖
      for (const def of definitions) {
        const builds = await buildClient.getBuilds(
          projectId,
          [def.id],
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          2,
          6,
          undefined,
          undefined,
          1,
        );┬╖
        if (!builds || builds.length === 0) continue;┬╖
        const latestBuild = builds[0];
        if (!latestBuild) continue;┬╖
        try {
          if (!artifactClient) throw new Error(\"ArtifactClient not initialized\");
          const artifacts = await artifactClient.getArtifacts(latestBuild.id);
          if (!artifacts.some((a) => a.name === \"aggregates\")) continue;┬╖
          matches.push({
            id: def.id,
            name: def.name,
            buildId: latestBuild.id,
          });
        } catch (e) {
          console.debug(`Skipping pipeline ${def.name}:`, e);
        }
      }┬╖
      return matches;
    }┬╖
    /**
     * Get Build REST client from SDK.
     */
    async function getBuildClient(): Promise<IBuildRestClient> {
      return new Promise((resolve) => {
        VSS.require([\"TFS/Build/RestClient\"], (BuildRestClient: any) => {
          resolve(BuildRestClient.getClient());
        });
      });
    }┬╖
    // ============================================================================
    // Main Initialization
    // ============================================================================┬╖
    /**
     * Check if running in local dashboard mode.
     */
    function isLocalMode(): boolean {
      return (
        typeof window !== \"undefined\" &&
        (window as any).LOCAL_DASHBOARD_MODE === true
      );
    }┬╖
    /**
     * Get local dataset path from window config.
     */
    function getLocalDatasetPath(): string {
      return (
        (typeof window !== \"undefined\" && (window as any).DATASET_PATH) ||
        \"./dataset\"
      );
    }┬╖
    /**
     * Initialize the dashboard.
     */
    async function init(): Promise<void> {
      if (metricsCollector) metricsCollector.mark(\"dashboard-init\");┬╖
      cacheElements();
      setupEventListeners();
      initializePhase5Features();┬╖
      try {
        if (isLocalMode()) {
          console.log(\"[Dashboard] Running in local mode\");
          const datasetPath = getLocalDatasetPath();
          loader = new DatasetLoader(datasetPath);
          currentBuildId = null;┬╖
          const projectNameEl = document.getElementById(\"current-project-name\");
          if (projectNameEl) {
            projectNameEl.textContent = \"Local Dashboard\";
          }┬╖
          const exportRawZip = document.getElementById(\"export-raw-zip\");
          if (exportRawZip) {
            exportRawZip.style.display = \"none\";
          }┬╖
          await loadDataset();
          return;
        }┬╖
        await initializeAdoSdk();
        const config = await resolveConfiguration();┬╖
        if (config.directUrl) {
          loader = new DatasetLoader(config.directUrl);
          currentBuildId = null;
        } else if (config.buildId && config.artifactName && artifactClient) {
          loader = artifactClient.createDatasetLoader(
            config.buildId,
            config.artifactName,
          );
          currentBuildId = config.buildId;
        } else {
          throw new Error(\"Failed to resolve configuration\");
        }┬╖
        await loadDataset();
      } catch (error: any) {
        console.error(\"Dashboard initialization failed:\", error);
        handleError(error);
      }
    }┬╖
    /**
     * Handle errors with appropriate UI panels.
     */
    function handleError(error: any): void {
      hideAllPanels();┬╖
      if (error instanceof PrInsightsError) {
        switch (error.type) {
          case ErrorTypes.SETUP_REQUIRED:
            showSetupRequired(error);
            break;
          case ErrorTypes.MULTIPLE_PIPELINES:
            showMultiplePipelines(error);
            break;
          case ErrorTypes.ARTIFACTS_MISSING:
            showArtifactsMissing(error);
            break;
          case ErrorTypes.PERMISSION_DENIED:
            showPermissionDenied(error);
            break;
          default:
            showGenericError(error.title, error.message);
            break;
        }
      } else {
        showGenericError(\"Error\", error.message || \"An unexpected error occurred\");
      }
    }┬╖
    /**
     * Hide all error/setup panels.
     */
    function hideAllPanels(): void {
      [
        \"setup-required\",
        \"multiple-pipelines\",
        \"artifacts-missing\",
        \"permission-denied\",
        \"error-state\",
        \"loading-state\",
        \"main-content\",
      ].forEach((id) => {
        document.getElementById(id)?.classList.add(\"hidden\");
      });
    }┬╖
    /**
     * Show setup required panel.
     */
    function showSetupRequired(error: PrInsightsError): void {
      const panel = document.getElementById(\"setup-required\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"setup-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      const details = error.details as SetupRequiredDetails;
      if (details?.instructions && Array.isArray(details.instructions)) {
        const stepsList = document.getElementById(\"setup-steps\");
        if (stepsList) {
          stepsList.innerHTML = details.instructions
            .map((s: string) => `<li>${s}</li>`)
            .join(\"\");
        }
      }┬╖
      if (details?.docsUrl) {
        const docsLink = document.getElementById(
          \"docs-link\",
        ) as HTMLAnchorElement | null;
        if (docsLink) docsLink.href = String(details.docsUrl);
      }┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show multiple pipelines panel.
     */
    function showMultiplePipelines(error: PrInsightsError): void {
      const panel = document.getElementById(\"multiple-pipelines\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"multiple-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      const listEl = document.getElementById(\"pipeline-list\");
      const details = error.details as MultiplePipelinesDetails;
      if (listEl && details?.matches && Array.isArray(details.matches)) {
        listEl.innerHTML = details.matches
          .map(
            (m: any) => `
                    <a href=\"?pipelineId=${m.id}\" class=\"pipeline-option\">
                        <strong>${m.name}</strong>
                        <span class=\"pipeline-id\">ID: ${m.id}</span>
                    </a>
                `,
          )
          .join(\"\");
      }┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show permission denied panel.
     */
    function showPermissionDenied(error: PrInsightsError): void {
      const panel = document.getElementById(\"permission-denied\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"permission-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show generic error state.
     */
    function showGenericError(title: string, message: string): void {
      const panel = document.getElementById(\"error-state\");
      if (!panel) return;┬╖
      const titleEl = document.getElementById(\"error-title\");
      const messageEl = document.getElementById(\"error-message\");┬╖
      if (titleEl) titleEl.textContent = title;
      if (messageEl) messageEl.textContent = message;┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    /**
     * Show artifacts missing panel.
     */
    function showArtifactsMissing(error: PrInsightsError): void {
      const panel = document.getElementById(\"artifacts-missing\");
      if (!panel) return showGenericError(error.title, error.message);┬╖
      const messageEl = document.getElementById(\"missing-message\");
      if (messageEl) messageEl.textContent = error.message;┬╖
      const details = error.details as ArtifactsMissingDetails;
      if (details?.instructions && Array.isArray(details.instructions)) {
        const stepsList = document.getElementById(\"missing-steps\");
        if (stepsList) {
          stepsList.innerHTML = details.instructions
            .map((s: string) => `<li>${s}</li>`)
            .join(\"\");
        }
      }┬╖
      panel.classList.remove(\"hidden\");
    }┬╖
    // ============================================================================
    // DOM and Event Handling
    // ============================================================================┬╖
    /**
     * Cache DOM elements for performance.
     */
    function cacheElements(): void {
      const ids = [
        \"app\",
        \"loading-state\",
        \"error-state\",
        \"main-content\",
        \"error-title\",
        \"error-message\",
        \"run-info\",
        \"date-range\",
        \"custom-dates\",
        \"start-date\",
        \"end-date\",
        \"retry-btn\",
        \"total-prs\",
        \"cycle-p50\",
        \"cycle-p90\",
        \"authors-count\",
        \"reviewers-count\",
        \"throughput-chart\",
        \"cycle-distribution\",
        \"total-prs-delta\",
        \"cycle-p50-delta\",
        \"cycle-p90-delta\",
        \"authors-delta\",
        \"reviewers-delta\",
        \"repo-filter\",
        \"team-filter\",
        \"repo-filter-group\",
        \"team-filter-group\",
        \"clear-filters\",
        \"active-filters\",
        \"filter-chips\",
        \"total-prs-sparkline\",
        \"cycle-p50-sparkline\",
        \"cycle-p90-sparkline\",
        \"authors-sparkline\",
        \"reviewers-sparkline\",
        \"cycle-time-trend\",
        \"reviewer-activity\",
        \"compare-toggle\",
        \"comparison-banner\",
        \"current-period-dates\",
        \"previous-period-dates\",
        \"exit-compare\",
        \"export-btn\",
        \"export-menu\",
        \"export-csv\",
        \"export-link\",
        \"export-raw-zip\",
      ];┬╖
      ids.forEach((id) => {
        elements[id] = document.getElementById(id);
      });┬╖
      elements.tabs = document.querySelectorAll(\".tab\");
    }┬╖
    /**
     * Initialize Phase 5 features.
     */
    function initializePhase5Features(): void {
      const phase5Tabs = document.querySelectorAll(\".phase5-tab\");┬╖
      if (ENABLE_PHASE5_FEATURES) {
        phase5Tabs.forEach((tab) => tab.classList.remove(\"hidden\"));
        console.log(\"Phase 5 features enabled\");
      } else {
        console.log(\"Phase 5 features disabled\");
      }
    }┬╖
    /**
     * Set up event listeners.
     */
    function setupEventListeners(): void {
      elements[\"date-range\"]?.addEventListener(\"change\", handleDateRangeChange);
      document
        .getElementById(\"apply-dates\")
        ?.addEventListener(\"click\", applyCustomDates);┬╖
      elements.tabs?.forEach((tab: HTMLElement) => {
        tab.addEventListener(\"click\", () => {
          const tabId = tab.dataset[\"tab\"];
          if (tabId) switchTab(tabId);
        });
      });┬╖
      elements[\"retry-btn\"]?.addEventListener(\"click\", () => init());
      document
        .getElementById(\"setup-retry-btn\")
        ?.addEventListener(\"click\", () => init());
      document
        .getElementById(\"permission-retry-btn\")
        ?.addEventListener(\"click\", () => init());┬╖
      elements[\"repo-filter\"]?.addEventListener(\"change\", handleFilterChange);
      elements[\"team-filter\"]?.addEventListener(\"change\", handleFilterChange);
      elements[\"clear-filters\"]?.addEventListener(\"click\", clearAllFilters);┬╖
      elements[\"compare-toggle\"]?.addEventListener(\"click\", toggleComparisonMode);
      elements[\"exit-compare\"]?.addEventListener(\"click\", exitComparisonMode);┬╖
      elements[\"export-btn\"]?.addEventListener(\"click\", toggleExportMenu);
      elements[\"export-csv\"]?.addEventListener(\"click\", exportToCsv);
      elements[\"export-link\"]?.addEventListener(\"click\", copyShareableLink);
      elements[\"export-raw-zip\"]?.addEventListener(\"click\", downloadRawDataZip);┬╖
      document.addEventListener(\"click\", (e: MouseEvent) => {
        const target = e.target as HTMLElement;
        if (!target.closest(\".export-dropdown\")) {
          elements[\"export-menu\"]?.classList.add(\"hidden\");
        }
      });
    }┬╖
    // ============================================================================
    // Data Loading and Rendering
    // ============================================================================┬╖
    /**
     * Load the dataset.
     */
    async function loadDataset(): Promise<void> {
      showLoading();┬╖
      try {
        if (!loader) throw new Error(\"Loader not initialized\");┬╖
        // Load manifest first
        const manifest = await loader.loadManifest();┬╖
        // Load dimensions
        const dimensions = await loader.loadDimensions();┬╖
        // Populate filter dropdowns from dimensions
        populateFilterDropdowns(dimensions);┬╖
        // Show dataset info
        updateDatasetInfo(manifest);┬╖
        // Restore state from URL if present
        restoreStateFromUrl();┬╖
        // Set initial date range from manifest defaults
        setInitialDateRange();┬╖
        // Load and render metrics
        await refreshMetrics();┬╖
        // Update feature tabs based on manifest
        await updateFeatureTabs();┬╖
        showContent();
      } catch (error) {
        console.error(\"Failed to load dataset:\", error);
        handleError(error);
      }
    }┬╖
    /**
     * Set initial date range from manifest defaults.
     */
    function setInitialDateRange(): void {
      // Skip if already restored from URL
      if (currentDateRange.start && currentDateRange.end) return;
      if (!loader) return;┬╖
      const coverage = loader.getCoverage() || null;
      const defaultDays = loader.getDefaultRangeDays() || 90;┬╖
      if (coverage?.date_range?.max) {
        const endDate = new Date(coverage.date_range.max);
        const startDate = new Date(endDate);
        startDate.setDate(startDate.getDate() - defaultDays);┬╖
        currentDateRange = { start: startDate, end: endDate };┬╖
        if (elements[\"start-date\"]) {
          elements[\"start-date\"].value = startDate.toISOString().split(\"T\")[0];
        }
        if (elements[\"end-date\"]) {
          elements[\"end-date\"].value = endDate.toISOString().split(\"T\")[0];
        }
      }
    }┬╖
    /**
     * Calculate the previous period date range for comparison.
     */
    function getPreviousPeriod(start: Date, end: Date): { start: Date; end: Date } {
      const durationMs = end.getTime() - start.getTime();
      const prevEnd = new Date(start.getTime() - 1); // Day before current start
      const prevStart = new Date(prevEnd.getTime() - durationMs);
      return { start: prevStart, end: prevEnd };
    }┬╖
    /**
     * Apply dimension filters to rollups data.
     * Uses by_repository slices when available for accurate filtering.
     */
    function applyFiltersToRollups(
      rollups: Rollup[],
      filters: { repos: string[]; teams: string[] },
    ): Rollup[] {
      // No filters active - return original data
      if (!filters.repos.length && !filters.teams.length) {
        return rollups;
      }┬╖
      return rollups.map((rollup) => {
        // If we have by_repository slices and repo filter is active, use them
        if (filters.repos.length && rollup.by_repository) {
          const selectedRepos = filters.repos
            .map((repoId) => {
              const repoData = rollup.by_repository![repoId];
              if (repoData) return repoData;┬╖
              return Object.entries(rollup.by_repository!).find(
                ([name]) => name === repoId,
              )?.[1];
            })
            .filter(Boolean) as any[];┬╖
          if (selectedRepos.length === 0) {
            return {
              ...rollup,
              pr_count: 0,
              cycle_time_p50: null,
              cycle_time_p90: null,
              authors_count: 0,
              reviewers_count: 0,
            };
          }┬╖
          // Aggregate metrics
          const totalPrCount = selectedRepos.reduce(
            (sum, r) => sum + (r.pr_count || 0),
            0,
          );
          const p50Values = selectedRepos
            .map((r) => r.cycle_time_p50)
            .filter((v) => v != null);
          const p90Values = selectedRepos
            .map((r) => r.cycle_time_p90)
            .filter((v) => v != null);┬╖
          const avgP50 =
            p50Values.length > 0
              ? p50Values.reduce((a, b) => a + b, 0) / p50Values.length
              : null;
          const avgP90 =
            p90Values.length > 0
              ? p90Values.reduce((a, b) => a + b, 0) / p90Values.length
              : null;┬╖
          const totalAuthors = selectedRepos.reduce(
            (sum, r) => sum + (r.authors_count || 0),
            0,
          );
          const totalReviewers = selectedRepos.reduce(
            (sum, r) => sum + (r.reviewers_count || 0),
            0,
          );┬╖
          return {
            ...rollup,
            pr_count: totalPrCount,
            cycle_time_p50: avgP50,
            cycle_time_p90: avgP90,
            authors_count: totalAuthors,
            reviewers_count: totalReviewers,
          } as Rollup;
        }┬╖
        // If we have by_team slices and team filter is active, use them
        if (filters.teams.length && rollup.by_team) {
          const selectedTeams = filters.teams
            .map((teamId) => rollup.by_team![teamId])
            .filter(Boolean) as any[];┬╖
          if (selectedTeams.length === 0) {
            return {
              ...rollup,
              pr_count: 0,
              cycle_time_p50: null,
              cycle_time_p90: null,
              authors_count: 0,
              reviewers_count: 0,
            };
          }┬╖
          const totalPrCount = selectedTeams.reduce(
            (sum, t) => sum + (t.pr_count || 0),
            0,
          );
          const p50Values = selectedTeams
            .map((t) => t.cycle_time_p50)
            .filter((v) => v != null);
          const avgP50 =
            p50Values.length > 0
              ? p50Values.reduce((a, b) => a + b, 0) / p50Values.length
              : null;┬╖
          return {
            ...rollup,
            pr_count: totalPrCount,
            cycle_time_p50: avgP50,
          } as Rollup;
        }┬╖
        return rollup;
      });
    }┬╖
    /**
     * Refresh metrics for current date range.
     */
    async function refreshMetrics(): Promise<void> {
      if (!currentDateRange.start || !currentDateRange.end || !loader) return;┬╖
      // Load current period data
      const rawRollups = await loader.getWeeklyRollups(
        currentDateRange.start,
        currentDateRange.end,
      );┬╖
      const distributions = await loader.getDistributions(
        currentDateRange.start,
        currentDateRange.end,
      );┬╖
      // Apply dimension filters to rollups
      const rollups = applyFiltersToRollups(rawRollups, currentFilters);┬╖
      // Load previous period data for comparison
      const prevPeriod = getPreviousPeriod(
        currentDateRange.start,
        currentDateRange.end,
      );
      let prevRollups: Rollup[] = [];
      try {
        const rawPrevRollups = await loader.getWeeklyRollups(
          prevPeriod.start,
          prevPeriod.end,
        );
        prevRollups = applyFiltersToRollups(rawPrevRollups, currentFilters);
      } catch (e) {
        console.debug(\"Previous period data not available:\", e);
      }┬╖
      // Cache filtered rollups for export
      cachedRollups = rollups;┬╖
      renderSummaryCards(rollups, prevRollups);
      renderThroughputChart(rollups);
      renderCycleTimeTrend(rollups);
      renderReviewerActivity(rollups);
      renderCycleDistribution(distributions);┬╖
      // Update comparison banner if in comparison mode
      if (comparisonMode) {
        updateComparisonBanner();
      }
    }┬╖
    interface CalculatedMetrics {
      totalPrs: number;
      cycleP50: number | null;
      cycleP90: number | null;
      avgAuthors: number;
      avgReviewers: number;
    }┬╖
    /**
     * Calculate metrics from rollups data.
     */
    function calculateMetrics(rollups: Rollup[]): CalculatedMetrics {
      if (!rollups || !rollups.length) {
        return {
          totalPrs: 0,
          cycleP50: null,
          cycleP90: null,
          avgAuthors: 0,
          avgReviewers: 0,
        };
      }┬╖
      const totalPrs = rollups.reduce((sum, r) => sum + (r.pr_count || 0), 0);┬╖
      const p50Values = rollups
        .map((r) => r.cycle_time_p50)
        .filter((v): v is number => v !== null && v !== undefined);
      const p90Values = rollups
        .map((r) => r.cycle_time_p90)
        .filter((v): v is number => v !== null && v !== undefined);┬╖
      const authorsSum = rollups.reduce(
        (sum, r) => sum + (r.authors_count || 0),
        0,
      );
      const reviewersSum = rollups.reduce(
        (sum, r) => sum + (r.reviewers_count || 0),
        0,
      );┬╖
      return {
        totalPrs,
        cycleP50: p50Values.length ? median(p50Values) : null,
        cycleP90: p90Values.length ? median(p90Values) : null,
        avgAuthors:
          rollups.length > 0 ? Math.round(authorsSum / rollups.length) : 0,
        avgReviewers:
          rollups.length > 0 ? Math.round(reviewersSum / rollups.length) : 0,
      };
    }┬╖
    /**
     * Calculate percentage change between two values.
     */
    function calculatePercentChange(
      current: number | null | undefined,
      previous: number | null | undefined,
    ): number | null {
      if (previous === null || previous === undefined || previous === 0) {
        return null;
      }
      if (current === null || current === undefined) {
        return null;
      }
      return ((current - previous) / previous) * 100;
    }┬╖
    /**
     * Render a delta indicator element.
     */
    function renderDelta(
      element: HTMLElement | null,
      percentChange: number | null,
      inverse = false,
    ): void {
      if (!element) return;┬╖
      if (percentChange === null) {
        element.innerHTML = \"\";
        element.className = \"metric-delta\";
        return;
      }┬╖
      const isNeutral = Math.abs(percentChange) < 2; // Within 2% is neutral
      const isPositive = percentChange > 0;
      const absChange = Math.abs(percentChange);┬╖
      let cssClass = \"metric-delta \";
      let arrow = \"\";┬╖
      if (isNeutral) {
        cssClass += \"delta-neutral\";
        arrow = \"~\";
      } else if (isPositive) {
        cssClass += inverse ? \"delta-negative-inverse\" : \"delta-positive\";
        arrow = \"&#9650;\"; // Up arrow
      } else {
        cssClass += inverse ? \"delta-positive-inverse\" : \"delta-negative\";
        arrow = \"&#9660;\"; // Down arrow
      }┬╖
      const sign = isPositive ? \"+\" : \"\";
      element.className = cssClass;
      element.innerHTML = `<span class=\"delta-arrow\">${arrow}</span> ${sign}${absChange.toFixed(0)}% <span class=\"delta-label\">vs prev</span>`;
    }┬╖
    /**
     * Render a sparkline SVG from data points.
     */
    function renderSparkline(element: HTMLElement | null, values: number[]): void {
      if (!element || !values || values.length < 2) {
        if (element) element.innerHTML = \"\";
        return;
      }┬╖
      // Take last 8 values for sparkline
      const data = values.slice(-8);
      const width = 60;
      const height = 24;
      const padding = 2;┬╖
      const minVal = Math.min(...data);
      const maxVal = Math.max(...data);
      const range = maxVal - minVal || 1;┬╖
      // Calculate points
      const points = data.map((val, i) => {
        const x = padding + (i / (data.length - 1)) * (width - padding * 2);
        const y =
          height - padding - ((val - minVal) / range) * (height - padding * 2);
        return { x, y };
      });┬╖
      // Create path
      const pathD = points
        .map((p, i) => `${i === 0 ? \"M\" : \"L\"} ${p.x.toFixed(1)} ${p.y.toFixed(1)}`)
        .join(\" \");┬╖
      // Create area path (closed)
      const areaD =
        pathD +
        ` L ${points[points.length - 1]!.x.toFixed(1)} ${height - padding} L ${points[0]!.x.toFixed(1)} ${height - padding} Z`;┬╖
      // Last point for dot
      const lastPoint = points[points.length - 1]!;┬╖
      element.innerHTML = `
            <svg viewBox=\"0 0 ${width} ${height}\" preserveAspectRatio=\"none\">
                <path class=\"sparkline-area\" d=\"${areaD}\"/>
                <path class=\"sparkline-line\" d=\"${pathD}\"/>
                <circle class=\"sparkline-dot\" cx=\"${lastPoint.x.toFixed(1)}\" cy=\"${lastPoint.y.toFixed(1)}\" r=\"2\"/>
            </svg>
        `;
    }┬╖
    /**
     * Extract sparkline data from rollups.
     */
    function extractSparklineData(rollups: Rollup[]): {
      prCounts: number[];
      p50s: number[];
      p90s: number[];
      authors: number[];
      reviewers: number[];
    } {
      if (!rollups || !rollups.length) {
        return { prCounts: [], p50s: [], p90s: [], authors: [], reviewers: [] };
      }┬╖
      return {
        prCounts: rollups.map((r) => r.pr_count || 0),
        p50s: rollups
          .map((r) => r.cycle_time_p50)
          .filter((v): v is number => v !== null && v !== undefined),
        p90s: rollups
          .map((r) => r.cycle_time_p90)
          .filter((v): v is number => v !== null && v !== undefined),
        authors: rollups.map((r) => r.authors_count || 0),
        reviewers: rollups.map((r) => r.reviewers_count || 0),
      };
    }┬╖
    /**
     * Render summary metric cards.
     */
    function renderSummaryCards(
      rollups: Rollup[],
      prevRollups: Rollup[] = [],
    ): void {
      if (metricsCollector) metricsCollector.mark(\"render-summary-cards-start\");┬╖
      const current = calculateMetrics(rollups);
      const previous = calculateMetrics(prevRollups);┬╖
      // Render metric values
      if (elements[\"total-prs\"])
        elements[\"total-prs\"].textContent = current.totalPrs.toLocaleString();
      if (elements[\"cycle-p50\"])
        elements[\"cycle-p50\"].textContent =
          current.cycleP50 !== null ? formatDuration(current.cycleP50) : \"-\";
      if (elements[\"cycle-p90\"])
        elements[\"cycle-p90\"].textContent =
          current.cycleP90 !== null ? formatDuration(current.cycleP90) : \"-\";
      if (elements[\"authors-count\"])
        elements[\"authors-count\"].textContent = current.avgAuthors.toLocaleString();
      if (elements[\"reviewers-count\"]) {
        elements[\"reviewers-count\"].textContent =
          current.avgReviewers.toLocaleString();
      }┬╖
      // Render sparklines
      const sparklineData = extractSparklineData(rollups);
      renderSparkline(elements[\"total-prs-sparkline\"], sparklineData.prCounts);
      renderSparkline(elements[\"cycle-p50-sparkline\"], sparklineData.p50s);
      renderSparkline(elements[\"cycle-p90-sparkline\"], sparklineData.p90s);
      renderSparkline(elements[\"authors-sparkline\"], sparklineData.authors);
      renderSparkline(elements[\"reviewers-sparkline\"], sparklineData.reviewers);┬╖
      // Render deltas (only if we have previous period data)
      if (prevRollups && prevRollups.length > 0) {
        renderDelta(
          elements[\"total-prs-delta\"],
          calculatePercentChange(current.totalPrs, previous.totalPrs),
          false,
        );
        renderDelta(
          elements[\"cycle-p50-delta\"],
          calculatePercentChange(current.cycleP50, previous.cycleP50),
          true,
        ); // Inverse: lower is better
        renderDelta(
          elements[\"cycle-p90-delta\"],
          calculatePercentChange(current.cycleP90, previous.cycleP90),
          true,
        ); // Inverse: lower is better
        renderDelta(
          elements[\"authors-delta\"],
          calculatePercentChange(current.avgAuthors, previous.avgAuthors),
          false,
        );
        renderDelta(
          elements[\"reviewers-delta\"],
          calculatePercentChange(current.avgReviewers, previous.avgReviewers),
          false,
        );
      } else {
        // Clear deltas if no previous data
        [
          \"total-prs-delta\",
          \"cycle-p50-delta\",
          \"cycle-p90-delta\",
          \"authors-delta\",
          \"reviewers-delta\",
        ].forEach((id) => {
          const el = elements[id];
          if (el) {
            el.innerHTML = \"\";
            el.className = \"metric-delta\";
          }
        });
      }┬╖
      if (metricsCollector) {
        metricsCollector.mark(\"render-summary-cards-end\");
        metricsCollector.mark(\"first-meaningful-paint\");
        metricsCollector.measure(
          \"init-to-fmp\",
          \"dashboard-init\",
          \"first-meaningful-paint\",
        );
      }
    }┬╖
    /**
     * Calculate moving average for trend line.
     */
    function calculateMovingAverage(
      values: number[],
      window = 4,
    ): (number | null)[] {
      const result: (number | null)[] = [];
      for (let i = 0; i < values.length; i++) {
        if (i < window - 1) {
          result.push(null);
        } else {
          const sum = values
            .slice(i - window + 1, i + 1)
            .reduce((a, b) => a + b, 0);
          result.push(sum / window);
        }
      }
      return result;
    }┬╖
    /**
     * Render throughput chart with trend line overlay.
     */
    function renderThroughputChart(rollups: Rollup[]): void {
      const chartEl = elements[\"throughput-chart\"];
      if (!chartEl) return;┬╖
      if (!rollups || !rollups.length) {
        chartEl.innerHTML = '<p class=\"no-data\">No data for selected range</p>';
        return;
      }┬╖
      const prCounts = rollups.map((r) => r.pr_count || 0);
      const maxCount = Math.max(...prCounts);
      const movingAvg = calculateMovingAverage(prCounts, 4);┬╖
      // Render bar chart
      const barsHtml = rollups
        .map((r) => {
          const height = maxCount > 0 ? ((r.pr_count || 0) / maxCount) * 100 : 0;
          return `
                <div class=\"bar-container\" title=\"${r.week}: ${r.pr_count || 0} PRs\">
                    <div class=\"bar\" style=\"height: ${height}%\"></div>
                    <div class=\"bar-label\">${r.week.split(\"-W\")[1]}</div>
                </div>
            `;
        })
        .join(\"\");┬╖
      // Render trend line SVG overlay
      let trendLineHtml = \"\";
      if (rollups.length >= 4) {
        const validPoints = movingAvg
          .map((val, i) => ({ val, i }))
          .filter((p): p is { val: number; i: number } => p.val !== null);┬╖
        if (validPoints.length >= 2) {
          const chartHeight = 200;
          const chartPadding = 8;┬╖
          // Calculate SVG path points
          const points = validPoints.map((p) => {
            const x = (p.i / (rollups.length - 1)) * 100;
            const y =
              maxCount > 0
                ? chartHeight -
                  chartPadding -
                  (p.val / maxCount) * (chartHeight - chartPadding * 2)
                : chartHeight / 2;
            return { x, y };
          });┬╖
          const pathD = points
            .map(
              (pt, i) =>
                `${i === 0 ? \"M\" : \"L\"} ${pt.x.toFixed(1)}% ${pt.y.toFixed(1)}`,
            )
            .join(\" \");┬╖
          trendLineHtml = `
                    <div class=\"trend-line-overlay\">
                        <svg viewBox=\"0 0 100 ${chartHeight}\" preserveAspectRatio=\"none\">
                            <path class=\"trend-line\" d=\"${pathD}\" vector-effect=\"non-scaling-stroke\"/>
                        </svg>
                    </div>
                `;
        }
      }┬╖
      // Legend
      const legendHtml = `
            <div class=\"chart-legend\">
                <div class=\"legend-item\">
                    <span class=\"legend-bar\"></span>
                    <span>Weekly PRs</span>
                </div>
                <div class=\"legend-item\">
                    <span class=\"legend-line\"></span>
                    <span>4-week avg</span>
                </div>
            </div>
        `;┬╖
      chartEl.innerHTML = `
            <div class=\"chart-with-trend\">
                <div class=\"bar-chart\">${barsHtml}</div>
                ${trendLineHtml}
            </div>
            ${legendHtml}
        `;
    }┬╖
    /**
     * Render cycle time distribution.
     */
    function renderCycleDistribution(distributions: any[]): void {
      const distEl = elements[\"cycle-distribution\"];
      if (!distEl) return;┬╖
      if (!distributions || !distributions.length) {
        distEl.innerHTML = '<p class=\"no-data\">No data for selected range</p>';
        return;
      }┬╖
      const buckets: Record<string, number> = {
        \"0-1h\": 0,
        \"1-4h\": 0,
        \"4-24h\": 0,
        \"1-3d\": 0,
        \"3-7d\": 0,
        \"7d+\": 0,
      };
      distributions.forEach((d) => {
        Object.entries(d.cycle_time_buckets || {}).forEach(([key, val]) => {
          buckets[key] = (buckets[key] || 0) + (val as number);
        });
      });┬╖
      const total = Object.values(buckets).reduce((a, b) => a + b, 0);
      if (total === 0) {
        distEl.innerHTML = '<p class=\"no-data\">No cycle time data</p>';
        return;
      }┬╖
      const html = Object.entries(buckets)
        .map(([label, count]) => {
          const pct = ((count / total) * 100).toFixed(1);
          return `
                <div class=\"dist-row\">
                    <span class=\"dist-label\">${label}</span>
                    <div class=\"dist-bar-bg\">
                        <div class=\"dist-bar\" style=\"width: ${pct}%\"></div>
                    </div>
                    <span class=\"dist-value\">${count} (${pct}%)</span>
                </div>
            `;
        })
        .join(\"\");┬╖
      distEl.innerHTML = html;
    }┬╖
    /**
     * Render cycle time trend chart (line chart with P50 and P90).
     */
    function renderCycleTimeTrend(rollups: Rollup[]): void {
      const trendEl = elements[\"cycle-time-trend\"];
      if (!trendEl) return;┬╖
      if (!rollups || rollups.length < 2) {
        trendEl.innerHTML = '<p class=\"no-data\">Not enough data for trend</p>';
        return;
      }┬╖
      const p50Data = rollups
        .map((r) => ({ week: r.week, value: r.cycle_time_p50 }))
        .filter((d): d is { week: string; value: number } => d.value !== null);
      const p90Data = rollups
        .map((r) => ({ week: r.week, value: r.cycle_time_p90 }))
        .filter((d): d is { week: string; value: number } => d.value !== null);┬╖
      if (p50Data.length < 2 && p90Data.length < 2) {
        trendEl.innerHTML = '<p class=\"no-data\">No cycle time data available</p>';
        return;
      }┬╖
      const allValues = [
        ...p50Data.map((d) => d.value),
        ...p90Data.map((d) => d.value),
      ];
      const maxVal = Math.max(...allValues);
      const minVal = Math.min(...allValues);
      const range = maxVal - minVal || 1;┬╖
      const width = 100;
      const height = 180;
      const padding = { top: 10, right: 10, bottom: 25, left: 40 };
      const chartWidth = width - padding.left - padding.right;
      const chartHeight = height - padding.top - padding.bottom;┬╖
      // Generate paths
      const generatePath = (data: { week: string; value: number }[]) => {
        const points = data.map((d) => {
          const dataIndex = rollups.findIndex((r) => r.week === d.week);
          const x = padding.left + (dataIndex / (rollups.length - 1)) * chartWidth;
          const y =
            padding.top + chartHeight - ((d.value - minVal) / range) * chartHeight;
          return { x, y, week: d.week, value: d.value };
        });
        const pathD = points
          .map(
            (p, i) => `${i === 0 ? \"M\" : \"L\"} ${p.x.toFixed(1)} ${p.y.toFixed(1)}`,
          )
          .join(\" \");
        return { pathD, points };
      };┬╖
      const p50Path = p50Data.length >= 2 ? generatePath(p50Data) : null;
      const p90Path = p90Data.length >= 2 ? generatePath(p90Data) : null;┬╖
      // Y-axis labels
      const yLabels = [minVal, (minVal + maxVal) / 2, maxVal];┬╖
      const svgContent = `
            <svg viewBox=\"0 0 ${width} ${height}\" preserveAspectRatio=\"xMidYMid meet\">
                <!-- Grid lines -->
                ${yLabels
                  .map((val, i) => {
                    const y =
                      padding.top +
                      chartHeight -
                      (i / (yLabels.length - 1)) * chartHeight;
                    return `<line class=\"line-chart-grid\" x1=\"${padding.left}\" y1=\"${y}\" x2=\"${width - padding.right}\" y2=\"${y}\"/>`;
                  })
                  .join(\"\")}┬╖
                <!-- Y-axis labels -->
                ${yLabels
                  .map((val, i) => {
                    const y =
                      padding.top +
                      chartHeight -
                      (i / (yLabels.length - 1)) * chartHeight;
                    return `<text class=\"line-chart-axis\" x=\"${padding.left - 4}\" y=\"${y + 3}\" text-anchor=\"end\">${formatDuration(val)}</text>`;
                  })
                  .join(\"\")}┬╖
                <!-- Lines -->
                ${p90Path ? `<path class=\"line-chart-p90\" d=\"${p90Path.pathD}\" vector-effect=\"non-scaling-stroke\"/>` : \"\"}
                ${p50Path ? `<path class=\"line-chart-p50\" d=\"${p50Path.pathD}\" vector-effect=\"non-scaling-stroke\"/>` : \"\"}┬╖
                <!-- Dots -->
                ${p90Path ? p90Path.points.map((p) => `<circle class=\"line-chart-dot\" cx=\"${p.x}\" cy=\"${p.y}\" r=\"3\" fill=\"var(--warning)\" data-week=\"${p.week}\" data-value=\"${p.value}\" data-metric=\"P90\"/>`).join(\"\") : \"\"}
                ${p50Path ? p50Path.points.map((p) => `<circle class=\"line-chart-dot\" cx=\"${p.x}\" cy=\"${p.y}\" r=\"3\" fill=\"var(--primary)\" data-week=\"${p.week}\" data-value=\"${p.value}\" data-metric=\"P50\"/>`).join(\"\") : \"\"}
            </svg>
        `;┬╖
      const legendHtml = `
            <div class=\"chart-legend\">
                <div class=\"legend-item\">
                    <span class=\"chart-tooltip-dot legend-p50\"></span>
                    <span>P50 (Median)</span>
                </div>
                <div class=\"legend-item\">
                    <span class=\"chart-tooltip-dot legend-p90\"></span>
                    <span>P90</span>
                </div>
            </div>
        `;┬╖
      trendEl.innerHTML = `<div class=\"line-chart\">${svgContent}</div>${legendHtml}`;┬╖
      // Add tooltip interactions
      addChartTooltips(trendEl, (dot: HTMLElement) => {
        const week = dot.dataset[\"week\"];
        const value = parseFloat(dot.dataset[\"value\"] || \"0\");
        const metric = dot.dataset[\"metric\"];
        return `
                <div class=\"chart-tooltip-title\">${week}</div>
                <div class=\"chart-tooltip-row\">
                    <span class=\"chart-tooltip-label\">
                        <span class=\"chart-tooltip-dot ${metric === \"P50\" ? \"legend-p50\" : \"legend-p90\"}\"></span>
                        ${metric}
                    </span>
                    <span>${formatDuration(value)}</span>
                </div>
            `;
      });
    }┬╖
    /**
     * Render reviewer activity chart (horizontal bar chart).
     */
    function renderReviewerActivity(rollups: Rollup[]): void {
      const revEl = elements[\"reviewer-activity\"];
      if (!revEl) return;┬╖
      if (!rollups || !rollups.length) {
        revEl.innerHTML = '<p class=\"no-data\">No reviewer data available</p>';
        return;
      }┬╖
      // Take last 8 weeks for display
      const recentRollups = rollups.slice(-8);
      const maxReviewers = Math.max(
        ...recentRollups.map((r) => r.reviewers_count || 0),
      );┬╖
      if (maxReviewers === 0) {
        revEl.innerHTML = '<p class=\"no-data\">No reviewer data available</p>';
        return;
      }┬╖
      const barsHtml = recentRollups
        .map((r) => {
          const count = r.reviewers_count || 0;
          const pct = (count / maxReviewers) * 100;
          const weekLabel = r.week.split(\"-W\")[1];
          return `
                <div class=\"h-bar-row\" title=\"${r.week}: ${count} reviewers\">
                    <span class=\"h-bar-label\">W${weekLabel}</span>
                    <div class=\"h-bar-container\">
                        <div class=\"h-bar\" style=\"width: ${pct}%\"></div>
                    </div>
                    <span class=\"h-bar-value\">${count}</span>
                </div>
            `;
        })
        .join(\"\");┬╖
      revEl.innerHTML = `<div class=\"horizontal-bar-chart\">${barsHtml}</div>`;
    }┬╖
    /**
     * Add tooltip interactions to a chart.
     */
    function addChartTooltips(
      container: HTMLElement,
      contentFn: (dot: HTMLElement) => string,
    ): void {
      const dots = container.querySelectorAll(\".line-chart-dot\");
      let tooltip: HTMLElement | null = null;┬╖
      dots.forEach((dotNode) => {
        const dot = dotNode as HTMLElement;
        dot.addEventListener(\"mouseenter\", () => {
          if (!tooltip) {
            tooltip = document.createElement(\"div\");
            tooltip.className = \"chart-tooltip\";
            container.appendChild(tooltip);
          }
          tooltip.innerHTML = contentFn(dot);
          tooltip.style.display = \"block\";┬╖
          // Position tooltip
          const rect = container.getBoundingClientRect();
          const dotRect = dot.getBoundingClientRect();
          tooltip.style.left = `${dotRect.left - rect.left + 10}px`;
          tooltip.style.top = `${dotRect.top - rect.top - 40}px`;
        });┬╖
        dot.addEventListener(\"mouseleave\", () => {
          if (tooltip) {
            tooltip.style.display = \"none\";
          }
        });
      });
    }┬╖
    /**
     * Update feature tabs based on manifest.
     */
    async function updateFeatureTabs(): Promise<void> {
      if (!loader) return;┬╖
      // Check if loader supports loadPredictions/loadInsights
      if (typeof (loader as any).loadPredictions !== \"function\") return;┬╖
      const predictionsContent = document.getElementById(\"tab-predictions\");
      const predictionsUnavailable = document.getElementById(
        \"predictions-unavailable\",
      );
      if (predictionsContent) {
        const predictionsResult = await (loader as any).loadPredictions();┬╖
        if (
          predictionsResult?.state === \"ok\" &&
          predictionsResult.data?.forecasts?.length > 0
        ) {
          renderPredictions(predictionsContent, predictionsResult.data);
        } else if (predictionsUnavailable) {
          predictionsUnavailable.classList.remove(\"hidden\");
        }
      }┬╖
      const aiContent = document.getElementById(\"tab-ai-insights\");
      const aiUnavailable = document.getElementById(\"ai-unavailable\");
      if (aiContent) {
        const insightsResult = await (loader as any).loadInsights();┬╖
        if (
          insightsResult?.state === \"ok\" &&
          insightsResult.data?.insights?.length > 0
        ) {
          renderAIInsights(aiContent, insightsResult.data);
        } else if (aiUnavailable) {
          aiUnavailable.classList.remove(\"hidden\");
        }
      }
    }┬╖
    /**
     * Render predictions.
     */
    function renderPredictions(container: HTMLElement, predictions: any): void {
      const content = document.createElement(\"div\");
      content.className = \"predictions-content\";┬╖
      if (predictions.is_stub) {
        content.innerHTML += `<div class=\"stub-warning\">ΓÜá∩╕Å Demo data</div>`;
      }┬╖
      predictions.forecasts.forEach((forecast: any) => {
        const label = forecast.metric
          .replace(/_/g, \" \")
          .replace(/\\b\\w/g, (c: string) => c.toUpperCase());
        content.innerHTML += `
                <div class=\"forecast-section\">
                    <h4>${label} (${forecast.unit})</h4>
                    <table class=\"forecast-table\">
                        <thead><tr><th>Week</th><th>Predicted</th><th>Range</th></tr></thead>
                        <tbody>
                            ${forecast.values
                              .map(
                                (v: any) => `
                                <tr>
                                    <td>${v.period_start}</td>
                                    <td>${v.predicted}</td>
                                    <td>${v.lower_bound} - ${v.upper_bound}</td>
                                </tr>
                            `,
                              )
                              .join(\"\")}
                        </tbody>
                    </table>
                </div>
            `;
      });┬╖
      const unavailable = container.querySelector(\".feature-unavailable\");
      if (unavailable) unavailable.classList.add(\"hidden\");
      container.appendChild(content);
    }┬╖
    /**
     * Render AI insights.
     */
    function renderAIInsights(container: HTMLElement, insights: any): void {
      const content = document.createElement(\"div\");
      content.className = \"insights-content\";┬╖
      if (insights.is_stub) {
        content.innerHTML += `<div class=\"stub-warning\">ΓÜá∩╕Å Demo data</div>`;
      }┬╖
      const icons: Record<string, string> = {
        critical: \"≡ƒö┤\",
        warning: \"≡ƒƒí\",
        info: \"≡ƒö╡\",
      };
      [\"critical\", \"warning\", \"info\"].forEach((severity) => {
        const items = insights.insights.filter((i: any) => i.severity === severity);
        if (!items.length) return;┬╖
        content.innerHTML += `
                <div class=\"severity-section\">
                    <h4>${icons[severity]} ${severity.charAt(0).toUpperCase() + severity.slice(1)}</h4>
                    <div class=\"insight-cards\">
                        ${items
                          .map(
                            (i: any) => `
                            <div class=\"insight-card ${i.severity}\">
                                <div class=\"insight-category\">${i.category}</div>
                                <h5>${i.title}</h5>
                                <p>${i.description}</p>
                            </div>
                        `,
                          )
                          .join(\"\")}
                    </div>
                </div>
            `;
      });┬╖
      const unavailable = container.querySelector(\".feature-unavailable\");
      if (unavailable) unavailable.classList.add(\"hidden\");
      container.appendChild(content);
    }┬╖
    // ============================================================================
    // Event Handlers
    // ============================================================================┬╖
    function handleDateRangeChange(e: Event): void {
      const target = e.target as HTMLSelectElement;
      const value = target.value;┬╖
      if (value === \"custom\") {
        elements[\"custom-dates\"]?.classList.remove(\"hidden\");
        return;
      }┬╖
      elements[\"custom-dates\"]?.classList.add(\"hidden\");┬╖
      const days = parseInt(value, 10);
      const coverage = loader?.getCoverage() || null;
      const endDate = coverage?.date_range?.max
        ? new Date(coverage.date_range.max)
        : new Date();
      const startDate = new Date(endDate);
      startDate.setDate(startDate.getDate() - days);┬╖
      currentDateRange = { start: startDate, end: endDate };
      updateUrlState();
      refreshMetrics();
    }┬╖
    function applyCustomDates(): void {
      const start = (elements[\"start-date\"] as HTMLInputElement)?.value;
      const end = (elements[\"end-date\"] as HTMLInputElement)?.value;┬╖
      if (!start || !end) return;┬╖
      currentDateRange = { start: new Date(start), end: new Date(end) };
      updateUrlState();
      refreshMetrics();
    }┬╖
    function switchTab(tabId: string): void {
      elements.tabs?.forEach((tab: HTMLElement) => {
        tab.classList.toggle(\"active\", tab.dataset[\"tab\"] === tabId);
      });┬╖
      document.querySelectorAll(\".tab-content\").forEach((content) => {
        content.classList.toggle(\"active\", content.id === `tab-${tabId}`);
        content.classList.toggle(\"hidden\", content.id !== `tab-${tabId}`);
      });┬╖
      updateUrlState();
    }┬╖
    // ============================================================================
    // Filter Management
    // ============================================================================┬╖
    /**
     * Populate filter dropdowns from loaded dimensions.
     */
    function populateFilterDropdowns(dimensions: any): void {
      if (!dimensions) return;┬╖
      // Populate repository filter
      const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
      if (repoFilter && dimensions.repositories?.length > 0) {
        repoFilter.innerHTML = '<option value=\"\">All</option>';
        dimensions.repositories.forEach((repo: any) => {
          const option = document.createElement(\"option\");
          option.value = repo.id || repo.name;
          option.textContent = repo.name;
          repoFilter.appendChild(option);
        });
        elements[\"repo-filter-group\"]?.classList.remove(\"hidden\");
      } else {
        elements[\"repo-filter-group\"]?.classList.add(\"hidden\");
      }┬╖
      // Populate team filter
      const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
      if (teamFilter && dimensions.teams?.length > 0) {
        teamFilter.innerHTML = '<option value=\"\">All</option>';
        dimensions.teams.forEach((team: any) => {
          const option = document.createElement(\"option\");
          option.value = team.id || team.name;
          option.textContent = team.name;
          teamFilter.appendChild(option);
        });
        elements[\"team-filter-group\"]?.classList.remove(\"hidden\");
      } else {
        elements[\"team-filter-group\"]?.classList.add(\"hidden\");
      }┬╖
      // Restore filter state from URL
      restoreFiltersFromUrl();
    }┬╖
    /**
     * Handle filter dropdown change.
     */
    function handleFilterChange(): void {
      const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
      const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;┬╖
      const repoValues = repoFilter
        ? Array.from(repoFilter.selectedOptions)
            .map((o) => o.value)
            .filter((v) => v)
        : [];
      const teamValues = teamFilter
        ? Array.from(teamFilter.selectedOptions)
            .map((o) => o.value)
            .filter((v) => v)
        : [];┬╖
      currentFilters = { repos: repoValues, teams: teamValues };┬╖
      updateFilterUI();
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Clear all filters.
     */
    function clearAllFilters(): void {
      currentFilters = { repos: [], teams: [] };┬╖
      const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
      const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;┬╖
      if (repoFilter) {
        Array.from(repoFilter.options).forEach(
          (o) => (o.selected = o.value === \"\"),
        );
      }
      if (teamFilter) {
        Array.from(teamFilter.options).forEach(
          (o) => (o.selected = o.value === \"\"),
        );
      }┬╖
      updateFilterUI();
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Remove a specific filter.
     */
    function removeFilter(type: string, value: string): void {
      if (type === \"repo\") {
        currentFilters.repos = currentFilters.repos.filter((v) => v !== value);
        const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
        if (repoFilter) {
          const option = repoFilter.querySelector(
            `option[value=\"${value}\"]`,
          ) as HTMLOptionElement | null;
          if (option) option.selected = false;
        }
      } else if (type === \"team\") {
        currentFilters.teams = currentFilters.teams.filter((v) => v !== value);
        const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
        if (teamFilter) {
          const option = teamFilter.querySelector(
            `option[value=\"${value}\"]`,
          ) as HTMLOptionElement | null;
          if (option) option.selected = false;
        }
      }┬╖
      updateFilterUI();
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Update filter UI.
     */
    function updateFilterUI(): void {
      const hasFilters =
        currentFilters.repos.length > 0 || currentFilters.teams.length > 0;┬╖
      if (elements[\"clear-filters\"]) {
        elements[\"clear-filters\"].classList.toggle(\"hidden\", !hasFilters);
      }┬╖
      if (elements[\"active-filters\"] && elements[\"filter-chips\"]) {
        elements[\"active-filters\"].classList.toggle(\"hidden\", !hasFilters);┬╖
        if (hasFilters) {
          renderFilterChips();
        } else {
          elements[\"filter-chips\"].innerHTML = \"\";
        }
      }
    }┬╖
    /**
     * Render filter chips for active filters.
     */
    function renderFilterChips(): void {
      const chipsEl = elements[\"filter-chips\"] as HTMLElement | null;
      if (!chipsEl) return;┬╖
      const chips: string[] = [];┬╖
      currentFilters.repos.forEach((value) => {
        const label = getFilterLabel(\"repo\", value);
        chips.push(createFilterChip(\"repo\", value, label));
      });┬╖
      currentFilters.teams.forEach((value) => {
        const label = getFilterLabel(\"team\", value);
        chips.push(createFilterChip(\"team\", value, label));
      });┬╖
      chipsEl.innerHTML = chips.join(\"\");┬╖
      chipsEl.querySelectorAll(\".filter-chip-remove\").forEach((btnNode) => {
        const btn = btnNode as HTMLElement;
        btn.addEventListener(\"click\", () => {
          const type = btn.dataset[\"type\"];
          const val = btn.dataset[\"value\"];
          if (type && val) removeFilter(type, val);
        });
      });
    }┬╖
    /**
     * Get display label for a filter value.
     */
    function getFilterLabel(type: string, value: string): string {
      if (type === \"repo\") {
        const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
        const option = repoFilter?.querySelector(`option[value=\"${value}\"]`);
        return option?.textContent || value;
      }
      if (type === \"team\") {
        const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
        const option = teamFilter?.querySelector(`option[value=\"${value}\"]`);
        return option?.textContent || value;
      }
      return value;
    }┬╖
    /**
     * Create HTML for a filter chip.
     */
    function createFilterChip(type: string, value: string, label: string): string {
      const prefix = type === \"repo\" ? \"repo\" : \"team\";
      return `
            <span class=\"filter-chip\">
                <span class=\"filter-chip-label\">${prefix}: ${label}</span>
                <span class=\"filter-chip-remove\" data-type=\"${type}\" data-value=\"${value}\">&times;</span>
            </span>
        `;
    }┬╖
    /**
     * Restore filters from URL parameters.
     */
    function restoreFiltersFromUrl(): void {
      const params = new URLSearchParams(window.location.search);┬╖
      const reposParam = params.get(\"repos\");
      const teamsParam = params.get(\"teams\");┬╖
      if (reposParam) {
        currentFilters.repos = reposParam.split(\",\").filter((v) => v);
        const repoFilter = elements[\"repo-filter\"] as HTMLSelectElement | null;
        if (repoFilter) {
          currentFilters.repos.forEach((value) => {
            const option = repoFilter.querySelector(
              `option[value=\"${value}\"]`,
            ) as HTMLOptionElement | null;
            if (option) option.selected = true;
          });
        }
      }┬╖
      if (teamsParam) {
        currentFilters.teams = teamsParam.split(\",\").filter((v) => v);
        const teamFilter = elements[\"team-filter\"] as HTMLSelectElement | null;
        if (teamFilter) {
          currentFilters.teams.forEach((value) => {
            const option = teamFilter.querySelector(
              `option[value=\"${value}\"]`,
            ) as HTMLOptionElement | null;
            if (option) option.selected = true;
          });
        }
      }┬╖
      updateFilterUI();
    }┬╖
    // ============================================================================
    // Comparison Mode
    // ============================================================================┬╖
    /**
     * Toggle comparison mode on/off.
     */
    function toggleComparisonMode(): void {
      comparisonMode = !comparisonMode;┬╖
      elements[\"compare-toggle\"]?.classList.toggle(\"active\", comparisonMode);
      elements[\"comparison-banner\"]?.classList.toggle(\"hidden\", !comparisonMode);┬╖
      if (comparisonMode) {
        updateComparisonBanner();
      }┬╖
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Exit comparison mode.
     */
    function exitComparisonMode(): void {
      comparisonMode = false;
      elements[\"compare-toggle\"]?.classList.remove(\"active\");
      elements[\"comparison-banner\"]?.classList.add(\"hidden\");
      updateUrlState();
      refreshMetrics();
    }┬╖
    /**
     * Update the comparison banner with date ranges.
     */
    function updateComparisonBanner(): void {
      if (!currentDateRange.start || !currentDateRange.end) return;┬╖
      const formatDate = (date: Date) =>
        date.toLocaleDateString(\"en-US\", {
          month: \"short\",
          day: \"numeric\",
          year: \"numeric\",
        });┬╖
      // Current period
      const currentStart = formatDate(currentDateRange.start);
      const currentEnd = formatDate(currentDateRange.end);
      if (elements[\"current-period-dates\"]) {
        elements[\"current-period-dates\"].textContent =
          `${currentStart} - ${currentEnd}`;
      }┬╖
      // Previous period
      const prevPeriod = getPreviousPeriod(
        currentDateRange.start,
        currentDateRange.end,
      );
      const prevStart = formatDate(prevPeriod.start);
      const prevEnd = formatDate(prevPeriod.end);
      if (elements[\"previous-period-dates\"]) {
        elements[\"previous-period-dates\"].textContent = `${prevStart} - ${prevEnd}`;
      }
    }┬╖
    // ============================================================================
    // Export Functions
    // ============================================================================┬╖
    /**
     * Toggle export menu visibility.
     */
    function toggleExportMenu(e: Event): void {
      e.stopPropagation();
      elements[\"export-menu\"]?.classList.toggle(\"hidden\");
    }┬╖
    /**
     * Export current data to CSV.
     */
    function exportToCsv(): void {
      elements[\"export-menu\"]?.classList.add(\"hidden\");┬╖
      if (!cachedRollups || cachedRollups.length === 0) {
        showToast(\"No data to export\", \"error\");
        return;
      }┬╖
      // Build CSV content
      const headers = [
        \"Week\",
        \"Start Date\",
        \"End Date\",
        \"PR Count\",
        \"Cycle Time P50 (min)\",
        \"Cycle Time P90 (min)\",
        \"Authors\",
        \"Reviewers\",
      ];
      const rows = cachedRollups.map((r) => [
        r.week,
        r.start_date || \"\",
        r.end_date || \"\",
        r.pr_count || 0,
        r.cycle_time_p50 != null ? r.cycle_time_p50.toFixed(1) : \"\",
        r.cycle_time_p90 != null ? r.cycle_time_p90.toFixed(1) : \"\",
        r.authors_count || 0,
        r.reviewers_count || 0,
      ]);┬╖
      const csvContent = [headers, ...rows]
        .map((row) => row.map((cell) => `\"${cell}\"`).join(\",\"))
        .join(\"\\n\");┬╖
      // Download file
      const blob = new Blob([csvContent], { type: \"text/csv;charset=utf-8;\" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement(\"a\");
      link.href = url;┬╖
      const dateStr = new Date().toISOString().split(\"T\")[0];
      link.download = `pr-insights-${dateStr}.csv`;┬╖
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);┬╖
      showToast(\"CSV exported successfully\", \"success\");
    }┬╖
    /**
     * Copy shareable link to clipboard.
     */
    async function copyShareableLink(): Promise<void> {
      elements[\"export-menu\"]?.classList.add(\"hidden\");┬╖
      try {
        await navigator.clipboard.writeText(window.location.href);
        showToast(\"Link copied to clipboard\", \"success\");
      } catch (_err) {
        // Fallback
        const textArea = document.createElement(\"textarea\");
        textArea.value = window.location.href;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand(\"copy\");
        document.body.removeChild(textArea);
        showToast(\"Link copied to clipboard\", \"success\");
      }
    }┬╖
    /**
     * Download raw CSV data as a ZIP file.
     */
    async function downloadRawDataZip(): Promise<void> {
      elements[\"export-menu\"]?.classList.add(\"hidden\");┬╖
      if (!currentBuildId || !artifactClient) {
        showToast(\"Raw data not available in direct URL mode\", \"error\");
        return;
      }┬╖
      try {
        showToast(\"Preparing download...\", \"success\");┬╖
        const artifact = await artifactClient.getArtifactMetadata(
          currentBuildId,
          \"csv-output\",
        );┬╖
        if (!artifact) {
          showToast(\"Raw CSV artifact not found in this pipeline run\", \"error\");
          return;
        }┬╖
        const downloadUrl = artifact.resource?.downloadUrl;
        if (!downloadUrl) {
          showToast(\"Download URL not available\", \"error\");
          return;
        }┬╖
        let zipUrl = downloadUrl;
        if (!zipUrl.includes(\"format=zip\")) {
          const separator = zipUrl.includes(\"?\") ? \"&\" : \"?\";
          zipUrl = `${zipUrl}${separator}format=zip`;
        }┬╖
        // Use the protected method from ArtifactClient
        const response = await (artifactClient as any)._authenticatedFetch(zipUrl);┬╖
        if (!response.ok) {
          if (response.status === 403 || response.status === 401) {
            showToast(\"Permission denied to download artifacts\", \"error\");
          } else {
            showToast(`Download failed: ${response.statusText}`, \"error\");
          }
          return;
        }┬╖
        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        const link = document.createElement(\"a\");
        link.href = url;┬╖
        const dateStr = new Date().toISOString().split(\"T\")[0];
        link.download = `pr-insights-raw-data-${dateStr}.zip`;┬╖
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);┬╖
        showToast(\"Download started\", \"success\");
      } catch (err) {
        console.error(\"Failed to download raw data:\", err);
        showToast(\"Failed to download raw data\", \"error\");
      }
    }┬╖
    /**
     * Show a toast notification.
     */
    function showToast(
      message: string,
      type: \"success\" | \"error\" = \"success\",
    ): void {
      const toast = document.createElement(\"div\");
      toast.className = `toast ${type}`;
      toast.textContent = message;
      document.body.appendChild(toast);┬╖
      setTimeout(() => {
        toast.remove();
      }, 3000);
    }┬╖
    // ============================================================================
    // Utility Functions
    // ============================================================================┬╖
    function showLoading(): void {
      hideAllPanels();
      elements[\"loading-state\"]?.classList.remove(\"hidden\");
    }┬╖
    function showContent(): void {
      hideAllPanels();
      elements[\"main-content\"]?.classList.remove(\"hidden\");
    }┬╖
    function updateDatasetInfo(manifest: any): void {
      const generatedAt = manifest?.generated_at
        ? new Date(manifest.generated_at).toLocaleString()
        : \"Unknown\";
      const runId = manifest?.run_id || \"\";┬╖
      const runInfo = elements[\"run-info\"];
      if (runInfo) {
        runInfo.textContent = `Generated: ${generatedAt}`;
        if (runId) runInfo.textContent += ` | Run: ${runId.slice(0, 8)}`;
      }
    }┬╖
    function formatDuration(minutes: number): string {
      if (minutes < 60) return `${Math.round(minutes)}m`;
      if (minutes < 1440) return `${(minutes / 60).toFixed(1)}h`;
      return `${(minutes / 1440).toFixed(1)}d`;
    }┬╖
    function median(arr: number[]): number {
      const sorted = [...arr].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      return sorted.length % 2
        ? sorted[mid]!
        : (sorted[mid - 1]! + sorted[mid]!) / 2;
    }┬╖
    function updateUrlState(): void {
      const params = new URLSearchParams(window.location.search);
      const newParams = new URLSearchParams();┬╖
      // Preserve config params
      if (params.get(\"dataset\")) newParams.set(\"dataset\", params.get(\"dataset\")!);
      if (params.get(\"pipelineId\"))
        newParams.set(\"pipelineId\", params.get(\"pipelineId\")!);┬╖
      // Add date range
      if (currentDateRange.start) {
        newParams.set(\"start\", currentDateRange.start.toISOString().split(\"T\")[0]!);
      }
      if (currentDateRange.end) {
        newParams.set(\"end\", currentDateRange.end.toISOString().split(\"T\")[0]!);
      }┬╖
      // Add active tab
      const activeTab = document.querySelector(\".tab.active\") as HTMLElement | null;
      if (activeTab && activeTab.dataset[\"tab\"] !== \"metrics\") {
        newParams.set(\"tab\", activeTab.dataset[\"tab\"]!);
      }┬╖
      // Add filters
      if (currentFilters.repos.length > 0) {
        newParams.set(\"repos\", currentFilters.repos.join(\",\"));
      }
      if (currentFilters.teams.length > 0) {
        newParams.set(\"teams\", currentFilters.teams.join(\",\"));
      }┬╖
      // Add comparison mode
      if (comparisonMode) {
        newParams.set(\"compare\", \"1\");
      }┬╖
      window.history.replaceState(
        {},
        \"\",
        `${window.location.pathname}?${newParams.toString()}`,
      );
    }┬╖
    function restoreStateFromUrl(): void {
      const params = new URLSearchParams(window.location.search);┬╖
      const startParam = params.get(\"start\");
      const endParam = params.get(\"end\");
      if (startParam && endParam) {
        currentDateRange = { start: new Date(startParam), end: new Date(endParam) };
        const dateRangeEl = elements[\"date-range\"] as HTMLSelectElement | null;
        if (dateRangeEl) {
          dateRangeEl.value = \"custom\";
          elements[\"custom-dates\"]?.classList.remove(\"hidden\");
        }
        if (elements[\"start-date\"]) elements[\"start-date\"].value = startParam;
        if (elements[\"end-date\"]) elements[\"end-date\"].value = endParam;
      }┬╖
      const tabParam = params.get(\"tab\");
      if (tabParam) {
        setTimeout(() => switchTab(tabParam), 0);
      }┬╖
      // Restore comparison mode
      const compareParam = params.get(\"compare\");
      if (compareParam === \"1\") {
        comparisonMode = true;
        elements[\"compare-toggle\"]?.classList.add(\"active\");
        elements[\"comparison-banner\"]?.classList.remove(\"hidden\");
      }
    }┬╖
    // ============================================================================
    // Initialize
    // ============================================================================┬╖
    if (document.readyState === \"loading\") {
      document.addEventListener(\"DOMContentLoaded\", init);
    } else {
      init();
    }
    "

      55 |         "resolveFromPipelineId(queryResult.value, targetProjectId)",
      56 |       );
    > 57 |       expect(dashboardCode).toContain(
         |                             ^
      58 |         "resolveFromPipelineId(sourceConfig.pipelineId, targetProjectId)",
      59 |       );
      60 |     });

      at Object.<anonymous> (tests/cross-project-settings.test.ts:57:29)

  ΓùÅ Cross-Project Settings ΓÇ║ settings.ts configuration ΓÇ║ should have SETTINGS_KEY_PROJECT constant matching dashboard

    expect(received).toContain(expected) // indexOf

    Expected substring: "SETTINGS_KEY_PROJECT = 'pr-insights-source-project'"
    Received string:    "/**
     * PR Insights Settings Page
     *
     * Allows users to configure:
     * - Source project (for cross-project access)
     * - Pipeline definition ID
     *
     * Settings are user-scoped (not project-scoped) for privacy.
     *
     * Project selection uses graceful degradation:
     * - Shows dropdown when vso.project scope allows listing projects
     * - Falls back to text input when listing isn't available
     */┬╖
    // Settings keys (must match dashboard.js)
    const SETTINGS_KEY_PROJECT = \"pr-insights-source-project\";
    const SETTINGS_KEY_PIPELINE = \"pr-insights-pipeline-id\";┬╖
    // State
    let dataService: IExtensionDataService | null = null;
    let projectDropdownAvailable = false;
    let projectList: any[] = [];┬╖
    /**
     * Initialize Azure DevOps Extension SDK.
     */
    async function initializeAdoSdk(): Promise<void> {
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error(\"Azure DevOps SDK initialization timed out\"));
        }, 10000);┬╖
        VSS.init({
          explicitNotifyLoaded: true,
          usePlatformScripts: true,
          usePlatformStyles: true,
        });┬╖
        VSS.ready(() => {
          clearTimeout(timeout);
          VSS.notifyLoadSucceeded();
          resolve();
        });
      });
    }┬╖
    /**
     * Initialize the settings page.
     */
    async function init(): Promise<void> {
      try {
        await initializeAdoSdk();┬╖
        // Get extension data service
        dataService = await VSS.getService(VSS.ServiceIds.ExtensionData);┬╖
        // Set current project as placeholder
        const webContext = VSS.getWebContext();
        const projectInput = document.getElementById(
          \"project-id\",
        ) as HTMLInputElement | null;
        if (projectInput && webContext?.project?.name) {
          projectInput.placeholder = `Current: ${webContext.project.name}`;
        }┬╖
        // Try to load project dropdown
        await tryLoadProjectDropdown();┬╖
        // Load saved settings
        await loadSettings();┬╖
        // Update status display
        await updateStatus();┬╖
        // Set up event listeners
        setupEventListeners();
      } catch (error: any) {
        console.error(\"Settings initialization failed:\", error);
        showStatus(\"Failed to initialize settings: \" + error.message, \"error\");
      }
    }┬╖
    /**
     * Try to load project dropdown. Degrades gracefully to text input.
     */
    async function tryLoadProjectDropdown(): Promise<void> {
      const dropdown = document.getElementById(
        \"project-select\",
      ) as HTMLSelectElement;
      const textInput = document.getElementById(\"project-id\") as HTMLInputElement;┬╖
      try {
        // Get projects using Core REST client
        const projects = await getOrganizationProjects();┬╖
        if (projects && projects.length > 0) {
          projectList = projects;
          projectDropdownAvailable = true;┬╖
          // Populate dropdown
          dropdown.innerHTML = '<option value=\"\">Current project (auto)</option>';
          for (const project of projects.sort((a: any, b: any) =>
            a.name.localeCompare(b.name),
          )) {
            const option = document.createElement(\"option\");
            option.value = project.id;
            option.textContent = `${project.name} (${project.id.substring(0, 8)}...)`;
            dropdown.appendChild(option);
          }┬╖
          // Show dropdown, hide text input
          dropdown.style.display = \"block\";
          textInput.style.display = \"none\";┬╖
          console.log(`Loaded ${projects.length} projects for dropdown`);
        } else {
          throw new Error(\"No projects returned\");
        }
      } catch (error: any) {
        console.log(
          \"Project dropdown unavailable, using text input:\",
          error.message,
        );
        projectDropdownAvailable = false;┬╖
        // Show text input, hide dropdown
        dropdown.style.display = \"none\";
        textInput.style.display = \"block\";
      }
    }┬╖
    /**
     * Get list of projects in the organization.
     * Requires vso.project scope.
     */
    async function getOrganizationProjects(): Promise<any[]> {
      return new Promise((resolve, reject) => {
        VSS.require([\"TFS/Core/RestClient\"], (CoreRestClient: any) => {
          try {
            const client = CoreRestClient.getClient();
            client
              .getProjects()
              .then((projects: any[]) => {
                resolve(projects || []);
              })
              .catch((error: any) => {
                reject(error);
              });
          } catch (error) {
            reject(error);
          }
        });
      });
    }┬╖
    /**
     * Load saved settings into form.
     */
    async function loadSettings(): Promise<void> {
      if (!dataService) return;┬╖
      try {
        const savedProjectId = await dataService.getValue<string>(
          SETTINGS_KEY_PROJECT,
          { scopeType: \"User\" },
        );
        const savedPipelineId = await dataService.getValue<number>(
          SETTINGS_KEY_PIPELINE,
          { scopeType: \"User\" },
        );┬╖
        // Set project
        if (savedProjectId) {
          if (projectDropdownAvailable) {
            const dropdown = document.getElementById(
              \"project-select\",
            ) as HTMLSelectElement;
            if (dropdown) dropdown.value = savedProjectId;
          } else {
            const textInput = document.getElementById(
              \"project-id\",
            ) as HTMLInputElement;
            if (textInput) textInput.value = savedProjectId;
          }
        }┬╖
        // Set pipeline ID
        const pipelineInput = document.getElementById(
          \"pipeline-id\",
        ) as HTMLInputElement;
        if (pipelineInput && savedPipelineId) {
          pipelineInput.value = savedPipelineId.toString();
        }
      } catch (error) {
        console.log(\"No saved settings found:\", error);
      }
    }┬╖
    /**
     * Get the selected project ID from either dropdown or text input.
     */
    function getSelectedProjectId(): string | null {
      if (projectDropdownAvailable) {
        const dropdown = document.getElementById(
          \"project-select\",
        ) as HTMLSelectElement;
        return dropdown.value || null;
      } else {
        const textInput = document.getElementById(\"project-id\") as HTMLInputElement;
        const value = textInput.value.trim();
        return value || null;
      }
    }┬╖
    /**
     * Save settings from form.
     */
    async function saveSettings(): Promise<void> {
      if (!dataService) return;┬╖
      const projectId = getSelectedProjectId();
      const pipelineInput = document.getElementById(
        \"pipeline-id\",
      ) as HTMLInputElement | null;
      const pipelineValue = pipelineInput?.value?.trim();┬╖
      try {
        // Save project ID
        await dataService.setValue(SETTINGS_KEY_PROJECT, projectId, {
          scopeType: \"User\",
        });┬╖
        // Save pipeline ID
        if (pipelineValue) {
          const pipelineId = parseInt(pipelineValue, 10);
          if (isNaN(pipelineId) || pipelineId <= 0) {
            showStatus(\"Pipeline ID must be a positive integer\", \"error\");
            return;
          }
          await dataService.setValue(SETTINGS_KEY_PIPELINE, pipelineId, {
            scopeType: \"User\",
          });
        } else {
          await dataService.setValue(SETTINGS_KEY_PIPELINE, null, {
            scopeType: \"User\",
          });
        }┬╖
        showStatus(\"Settings saved successfully\", \"success\");┬╖
        // Update status display
        await updateStatus();
      } catch (error: any) {
        console.error(\"Failed to save settings:\", error);
        showStatus(\"Failed to save settings: \" + error.message, \"error\");
      }
    }┬╖
    /**
     * Clear settings.
     */
    async function clearSettings(): Promise<void> {
      if (!dataService) return;┬╖
      // Clear form
      if (projectDropdownAvailable) {
        const dropdown = document.getElementById(
          \"project-select\",
        ) as HTMLSelectElement;
        if (dropdown) dropdown.value = \"\";
      } else {
        const textInput = document.getElementById(\"project-id\") as HTMLInputElement;
        if (textInput) textInput.value = \"\";
      }
      const pipelineInput = document.getElementById(
        \"pipeline-id\",
      ) as HTMLInputElement;
      if (pipelineInput) pipelineInput.value = \"\";┬╖
      try {
        await dataService.setValue(SETTINGS_KEY_PROJECT, null, {
          scopeType: \"User\",
        });
        await dataService.setValue(SETTINGS_KEY_PIPELINE, null, {
          scopeType: \"User\",
        });
        showStatus(
          \"Settings cleared - using current project with auto-discovery\",
          \"success\",
        );
        await updateStatus();
      } catch (error: any) {
        console.error(\"Failed to clear settings:\", error);
        showStatus(\"Failed to clear settings: \" + error.message, \"error\");
      }
    }┬╖
    /**
     * Update the status display with current configuration.
     */
    async function updateStatus(): Promise<void> {
      if (!dataService) return;┬╖
      const statusDisplay = document.getElementById(\"status-display\");
      if (!statusDisplay) return;┬╖
      try {
        const savedProjectId = await dataService.getValue<string>(
          SETTINGS_KEY_PROJECT,
          { scopeType: \"User\" },
        );
        const savedPipelineId = await dataService.getValue<number>(
          SETTINGS_KEY_PIPELINE,
          { scopeType: \"User\" },
        );
        const webContext = VSS.getWebContext();
        const currentProjectName = webContext?.project?.name || \"Unknown\";
        const currentProjectId = webContext?.project?.id;┬╖
        let html = \"\";┬╖
        // Current context
        html += `<p><strong>Current Project:</strong> ${escapeHtml(currentProjectName)}</p>`;┬╖
        // Source project configuration
        if (savedProjectId) {
          const projectName = getProjectNameById(savedProjectId);
          html += `<p><strong>Source Project:</strong> ${escapeHtml(projectName)} <code>${savedProjectId.substring(0, 8)}...</code></p>`;
        } else {
          html += `<p><strong>Source Project:</strong> <em>Same as current</em></p>`;
        }┬╖
        // Pipeline configuration with validation
        if (savedPipelineId) {
          html += `<p><strong>Pipeline Definition ID:</strong> ${savedPipelineId}`;┬╖
          // Validate the saved pipeline
          const targetProjectId = savedProjectId || currentProjectId;
          if (targetProjectId) {
            const validation = await validatePipeline(
              savedPipelineId,
              targetProjectId,
            );┬╖
            if (validation.valid) {
              html += ` <span class=\"status-valid\">Γ£ô Valid</span>`;
              html += `</p>`;
              html += `<p class=\"status-hint\">Pipeline: \"${escapeHtml(validation.name || \"\")}\" (Build #${validation.buildId})</p>`;
            } else {
              html += ` <span class=\"status-invalid\">ΓÜá∩╕Å Invalid</span>`;
              html += `</p>`;
              html += `<p class=\"status-warning\">ΓÜá∩╕Å ${escapeHtml(validation.error || \"\")}</p>`;
              html += `<p class=\"status-hint\">The dashboard will automatically clear this setting and re-discover pipelines. Consider clearing manually to configure a different pipeline.</p>`;
            }
          } else {
            html += `</p><p class=\"status-warning\">ΓÜá∩╕Å No project ID available for validation</p>`;
          }
        } else {
          html += `<p><strong>Mode:</strong> Auto-discovery</p>`;
          html += `<p class=\"status-hint\">The dashboard will automatically find pipelines with an \"aggregates\" artifact.</p>`;
        }┬╖
        // Dropdown availability
        if (projectDropdownAvailable) {
          html += `<p class=\"status-hint\">Γ£ô Project dropdown available (${projectList.length} projects)</p>`;
        } else {
          html += `<p class=\"status-hint\">Project dropdown not available - using text input</p>`;
        }┬╖
        statusDisplay.innerHTML = html;
      } catch (error: any) {
        statusDisplay.innerHTML = `<p class=\"status-error\">Failed to load status: ${escapeHtml(error.message)}</p>`;
      }
    }┬╖
    /**
     * Get project name by ID from the cached list.
     */
    function getProjectNameById(projectId: string): string {
      const project = projectList.find((p) => p.id === projectId);
      return project?.name || projectId;
    }┬╖
    /**
     * Validate if a pipeline exists and has successful builds with aggregates artifact.
     * Returns validation result with details.
     */
    async function validatePipeline(
      pipelineId: number,
      projectId: string,
    ): Promise<{
      valid: boolean;
      name?: string;
      buildId?: number;
      error?: string;
    }> {
      return new Promise((resolve) => {
        VSS.require([\"TFS/Build/RestClient\"], (BuildRestClient: any) => {
          try {
            const client = BuildRestClient.getClient();┬╖
            // Check if pipeline definition exists
            client
              .getDefinitions(
                projectId,
                null,
                null,
                null,
                2, // queryOrder: definitionNameAscending
                null,
                null,
                null,
                [pipelineId],
              )
              .then((definitions: any[]) => {
                if (!definitions || definitions.length === 0) {
                  resolve({
                    valid: false,
                    error: \"Pipeline definition not found (may have been deleted)\",
                  });
                  return;
                }┬╖
                const pipelineName = definitions[0].name;┬╖
                // Check for successful/partially-succeeded builds
                // resultFilter: 6 = Succeeded(2) | PartiallySucceeded(4)
                client
                  .getBuilds(
                    projectId,
                    [pipelineId],
                    null,
                    null,
                    null,
                    null,
                    null,
                    null,
                    2,
                    6,
                    null,
                    null,
                    1,
                  )
                  .then((builds: any[]) => {
                    if (!builds || builds.length === 0) {
                      resolve({
                        valid: false,
                        name: pipelineName,
                        error: \"No successful builds found\",
                      });
                      return;
                    }┬╖
                    resolve({
                      valid: true,
                      name: pipelineName,
                      buildId: builds[0].id,
                    });
                  })
                  .catch((e: any) => {
                    resolve({
                      valid: false,
                      error: `Build check failed: ${e.message}`,
                    });
                  });
              })
              .catch((e: any) => {
                resolve({
                  valid: false,
                  error: `Definition fetch failed: ${e.message}`,
                });
              });
          } catch (e: any) {
            resolve({ valid: false, error: `Validation error: ${e.message}` });
          }
        });
      });
    }┬╖
    /**
     * Discover pipelines with aggregates artifact in the current project.
     */
    async function discoverPipelines(): Promise<
      Array<{ id: number; name: string; buildId: number }>
    > {
      return new Promise((resolve) => {
        VSS.require([\"TFS/Build/RestClient\"], (BuildRestClient: any) => {
          try {
            const client = BuildRestClient.getClient();
            const webContext = VSS.getWebContext();
            const projectId = webContext.project?.id;
            if (!projectId) {
              resolve([]);
              return;
            }
            const matches: any[] = [];┬╖
            // Get pipeline definitions (limit for performance)
            client
              .getDefinitions(projectId, null, null, null, 2, 50)
              .then(async (definitions: any[]) => {
                for (const def of definitions) {
                  // Get latest successful/partially-succeeded build
                  try {
                    const builds = await client.getBuilds(
                      projectId,
                      [def.id],
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      2,
                      6,
                      null,
                      null,
                      1,
                    );┬╖
                    if (!builds || builds.length === 0) continue;┬╖
                    const latestBuild = builds[0];┬╖
                    // Check for aggregates artifact
                    const artifacts = await client.getArtifacts(
                      projectId,
                      latestBuild.id,
                    );
                    if (!artifacts.some((a: any) => a.name === \"aggregates\"))
                      continue;┬╖
                    matches.push({
                      id: def.id,
                      name: def.name,
                      buildId: latestBuild.id,
                    });
                  } catch (e) {
                    // Skip pipelines we can't access
                    console.debug(`Skipping pipeline ${def.name}:`, e);
                  }
                }
                resolve(matches);
              })
              .catch((e: any) => {
                console.error(\"Discovery: definitions fetch failed:\", e);
                resolve([]);
              });
          } catch (e) {
            console.error(\"Discovery error:\", e);
            resolve([]);
          }
        });
      });
    }┬╖
    /**
     * Run auto-discovery and show results to user.
     */
    async function runDiscovery(): Promise<void> {
      const statusDisplay = document.getElementById(\"status-display\");
      if (!statusDisplay) return;┬╖
      const originalContent = statusDisplay.innerHTML;
      statusDisplay.innerHTML =
        \"<p>≡ƒöì Discovering pipelines with aggregates artifact...</p>\";┬╖
      try {
        const matches = await discoverPipelines();┬╖
        if (matches.length === 0) {
          statusDisplay.innerHTML = `
                    <p class=\"status-warning\">ΓÜá∩╕Å No PR Insights pipelines found in the current project.</p>
                    <p class=\"status-hint\">Create a pipeline using pr-insights-pipeline.yml and run it at least once.</p>
                `;
          showStatus(\"No pipelines found with aggregates artifact\", \"warning\");
          return;
        }┬╖
        let html = `<p><strong>Found ${matches.length} pipeline(s):</strong></p><ul class=\"discovered-pipelines\">`;
        for (const match of matches) {
          html += `<li>
                    <strong>${escapeHtml(match.name)}</strong> (ID: ${match.id})
                    <button class=\"btn btn-small\" id=\"select-pipeline-${match.id}\">Use This</button>
                </li>`;
        }
        html += \"</ul>\";
        html +=
          '<p class=\"status-hint\">Click \"Use This\" to configure, or clear settings for auto-discovery.</p>';┬╖
        statusDisplay.innerHTML = html;┬╖
        // Add event listeners for discovered pipelines
        for (const match of matches) {
          document
            .getElementById(`select-pipeline-${match.id}`)
            ?.addEventListener(\"click\", () => {
              const pipelineInput = document.getElementById(
                \"pipeline-id\",
              ) as HTMLInputElement;
              if (pipelineInput) pipelineInput.value = match.id.toString();
              showStatus(
                `Pipeline ${match.id} selected - click Save to confirm`,
                \"info\",
              );
            });
        }┬╖
        showStatus(`Found ${matches.length} pipeline(s)`, \"success\");
      } catch (error: any) {
        statusDisplay.innerHTML = originalContent;
        showStatus(\"Discovery failed: \" + error.message, \"error\");
      }
    }┬╖
    /**
     * Show status message.
     */
    function showStatus(message: string, type = \"info\"): void {
      const statusEl = document.getElementById(\"status-message\");
      if (!statusEl) return;┬╖
      statusEl.textContent = message;
      statusEl.className = `status-message status-${type}`;┬╖
      // Clear after delay
      setTimeout(() => {
        statusEl.textContent = \"\";
        statusEl.className = \"status-message\";
      }, 5000);
    }┬╖
    /**
     * Escape HTML to prevent XSS.
     */
    function escapeHtml(text: string): string {
      const div = document.createElement(\"div\");
      div.textContent = text;
      return div.innerHTML;
    }┬╖
    /**
     * Set up event listeners.
     */
    function setupEventListeners(): void {
      document.getElementById(\"save-btn\")?.addEventListener(\"click\", saveSettings);
      document
        .getElementById(\"clear-btn\")
        ?.addEventListener(\"click\", clearSettings);
      document
        .getElementById(\"discover-btn\")
        ?.addEventListener(\"click\", runDiscovery);┬╖
      // Enter key saves
      document
        .getElementById(\"pipeline-id\")
        ?.addEventListener(\"keypress\", (e: KeyboardEvent) => {
          if (e.key === \"Enter\") {
            saveSettings();
          }
        });
      document
        .getElementById(\"project-id\")
        ?.addEventListener(\"keypress\", (e: KeyboardEvent) => {
          if (e.key === \"Enter\") {
            saveSettings();
          }
        });
    }┬╖
    // Initialize on load
    if (document.readyState === \"loading\") {
      document.addEventListener(\"DOMContentLoaded\", init);
    } else {
      init();
    }┬╖
    // Global exposure for potential inline handlers (though we use addEventListener now)
    (window as any).selectDiscoveredPipeline = (pipelineId: number) => {
      const pipelineInput = document.getElementById(
        \"pipeline-id\",
      ) as HTMLInputElement;
      if (pipelineInput) pipelineInput.value = pipelineId.toString();
      showStatus(`Pipeline ${pipelineId} selected - click Save to confirm`, \"info\");
    };
    "

      74 |
      75 |     it("should have SETTINGS_KEY_PROJECT constant matching dashboard", () => {
    > 76 |       expect(settingsCode).toContain(
         |                            ^
      77 |         "SETTINGS_KEY_PROJECT = 'pr-insights-source-project'",
      78 |       );
      79 |     });

      at Object.<anonymous> (tests/cross-project-settings.test.ts:76:28)

  ΓùÅ Cross-Project Settings ΓÇ║ settings.ts configuration ΓÇ║ should have SETTINGS_KEY_PIPELINE constant matching dashboard

    expect(received).toContain(expected) // indexOf

    Expected substring: "SETTINGS_KEY_PIPELINE = 'pr-insights-pipeline-id'"
    Received string:    "/**
     * PR Insights Settings Page
     *
     * Allows users to configure:
     * - Source project (for cross-project access)
     * - Pipeline definition ID
     *
     * Settings are user-scoped (not project-scoped) for privacy.
     *
     * Project selection uses graceful degradation:
     * - Shows dropdown when vso.project scope allows listing projects
     * - Falls back to text input when listing isn't available
     */┬╖
    // Settings keys (must match dashboard.js)
    const SETTINGS_KEY_PROJECT = \"pr-insights-source-project\";
    const SETTINGS_KEY_PIPELINE = \"pr-insights-pipeline-id\";┬╖
    // State
    let dataService: IExtensionDataService | null = null;
    let projectDropdownAvailable = false;
    let projectList: any[] = [];┬╖
    /**
     * Initialize Azure DevOps Extension SDK.
     */
    async function initializeAdoSdk(): Promise<void> {
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error(\"Azure DevOps SDK initialization timed out\"));
        }, 10000);┬╖
        VSS.init({
          explicitNotifyLoaded: true,
          usePlatformScripts: true,
          usePlatformStyles: true,
        });┬╖
        VSS.ready(() => {
          clearTimeout(timeout);
          VSS.notifyLoadSucceeded();
          resolve();
        });
      });
    }┬╖
    /**
     * Initialize the settings page.
     */
    async function init(): Promise<void> {
      try {
        await initializeAdoSdk();┬╖
        // Get extension data service
        dataService = await VSS.getService(VSS.ServiceIds.ExtensionData);┬╖
        // Set current project as placeholder
        const webContext = VSS.getWebContext();
        const projectInput = document.getElementById(
          \"project-id\",
        ) as HTMLInputElement | null;
        if (projectInput && webContext?.project?.name) {
          projectInput.placeholder = `Current: ${webContext.project.name}`;
        }┬╖
        // Try to load project dropdown
        await tryLoadProjectDropdown();┬╖
        // Load saved settings
        await loadSettings();┬╖
        // Update status display
        await updateStatus();┬╖
        // Set up event listeners
        setupEventListeners();
      } catch (error: any) {
        console.error(\"Settings initialization failed:\", error);
        showStatus(\"Failed to initialize settings: \" + error.message, \"error\");
      }
    }┬╖
    /**
     * Try to load project dropdown. Degrades gracefully to text input.
     */
    async function tryLoadProjectDropdown(): Promise<void> {
      const dropdown = document.getElementById(
        \"project-select\",
      ) as HTMLSelectElement;
      const textInput = document.getElementById(\"project-id\") as HTMLInputElement;┬╖
      try {
        // Get projects using Core REST client
        const projects = await getOrganizationProjects();┬╖
        if (projects && projects.length > 0) {
          projectList = projects;
          projectDropdownAvailable = true;┬╖
          // Populate dropdown
          dropdown.innerHTML = '<option value=\"\">Current project (auto)</option>';
          for (const project of projects.sort((a: any, b: any) =>
            a.name.localeCompare(b.name),
          )) {
            const option = document.createElement(\"option\");
            option.value = project.id;
            option.textContent = `${project.name} (${project.id.substring(0, 8)}...)`;
            dropdown.appendChild(option);
          }┬╖
          // Show dropdown, hide text input
          dropdown.style.display = \"block\";
          textInput.style.display = \"none\";┬╖
          console.log(`Loaded ${projects.length} projects for dropdown`);
        } else {
          throw new Error(\"No projects returned\");
        }
      } catch (error: any) {
        console.log(
          \"Project dropdown unavailable, using text input:\",
          error.message,
        );
        projectDropdownAvailable = false;┬╖
        // Show text input, hide dropdown
        dropdown.style.display = \"none\";
        textInput.style.display = \"block\";
      }
    }┬╖
    /**
     * Get list of projects in the organization.
     * Requires vso.project scope.
     */
    async function getOrganizationProjects(): Promise<any[]> {
      return new Promise((resolve, reject) => {
        VSS.require([\"TFS/Core/RestClient\"], (CoreRestClient: any) => {
          try {
            const client = CoreRestClient.getClient();
            client
              .getProjects()
              .then((projects: any[]) => {
                resolve(projects || []);
              })
              .catch((error: any) => {
                reject(error);
              });
          } catch (error) {
            reject(error);
          }
        });
      });
    }┬╖
    /**
     * Load saved settings into form.
     */
    async function loadSettings(): Promise<void> {
      if (!dataService) return;┬╖
      try {
        const savedProjectId = await dataService.getValue<string>(
          SETTINGS_KEY_PROJECT,
          { scopeType: \"User\" },
        );
        const savedPipelineId = await dataService.getValue<number>(
          SETTINGS_KEY_PIPELINE,
          { scopeType: \"User\" },
        );┬╖
        // Set project
        if (savedProjectId) {
          if (projectDropdownAvailable) {
            const dropdown = document.getElementById(
              \"project-select\",
            ) as HTMLSelectElement;
            if (dropdown) dropdown.value = savedProjectId;
          } else {
            const textInput = document.getElementById(
              \"project-id\",
            ) as HTMLInputElement;
            if (textInput) textInput.value = savedProjectId;
          }
        }┬╖
        // Set pipeline ID
        const pipelineInput = document.getElementById(
          \"pipeline-id\",
        ) as HTMLInputElement;
        if (pipelineInput && savedPipelineId) {
          pipelineInput.value = savedPipelineId.toString();
        }
      } catch (error) {
        console.log(\"No saved settings found:\", error);
      }
    }┬╖
    /**
     * Get the selected project ID from either dropdown or text input.
     */
    function getSelectedProjectId(): string | null {
      if (projectDropdownAvailable) {
        const dropdown = document.getElementById(
          \"project-select\",
        ) as HTMLSelectElement;
        return dropdown.value || null;
      } else {
        const textInput = document.getElementById(\"project-id\") as HTMLInputElement;
        const value = textInput.value.trim();
        return value || null;
      }
    }┬╖
    /**
     * Save settings from form.
     */
    async function saveSettings(): Promise<void> {
      if (!dataService) return;┬╖
      const projectId = getSelectedProjectId();
      const pipelineInput = document.getElementById(
        \"pipeline-id\",
      ) as HTMLInputElement | null;
      const pipelineValue = pipelineInput?.value?.trim();┬╖
      try {
        // Save project ID
        await dataService.setValue(SETTINGS_KEY_PROJECT, projectId, {
          scopeType: \"User\",
        });┬╖
        // Save pipeline ID
        if (pipelineValue) {
          const pipelineId = parseInt(pipelineValue, 10);
          if (isNaN(pipelineId) || pipelineId <= 0) {
            showStatus(\"Pipeline ID must be a positive integer\", \"error\");
            return;
          }
          await dataService.setValue(SETTINGS_KEY_PIPELINE, pipelineId, {
            scopeType: \"User\",
          });
        } else {
          await dataService.setValue(SETTINGS_KEY_PIPELINE, null, {
            scopeType: \"User\",
          });
        }┬╖
        showStatus(\"Settings saved successfully\", \"success\");┬╖
        // Update status display
        await updateStatus();
      } catch (error: any) {
        console.error(\"Failed to save settings:\", error);
        showStatus(\"Failed to save settings: \" + error.message, \"error\");
      }
    }┬╖
    /**
     * Clear settings.
     */
    async function clearSettings(): Promise<void> {
      if (!dataService) return;┬╖
      // Clear form
      if (projectDropdownAvailable) {
        const dropdown = document.getElementById(
          \"project-select\",
        ) as HTMLSelectElement;
        if (dropdown) dropdown.value = \"\";
      } else {
        const textInput = document.getElementById(\"project-id\") as HTMLInputElement;
        if (textInput) textInput.value = \"\";
      }
      const pipelineInput = document.getElementById(
        \"pipeline-id\",
      ) as HTMLInputElement;
      if (pipelineInput) pipelineInput.value = \"\";┬╖
      try {
        await dataService.setValue(SETTINGS_KEY_PROJECT, null, {
          scopeType: \"User\",
        });
        await dataService.setValue(SETTINGS_KEY_PIPELINE, null, {
          scopeType: \"User\",
        });
        showStatus(
          \"Settings cleared - using current project with auto-discovery\",
          \"success\",
        );
        await updateStatus();
      } catch (error: any) {
        console.error(\"Failed to clear settings:\", error);
        showStatus(\"Failed to clear settings: \" + error.message, \"error\");
      }
    }┬╖
    /**
     * Update the status display with current configuration.
     */
    async function updateStatus(): Promise<void> {
      if (!dataService) return;┬╖
      const statusDisplay = document.getElementById(\"status-display\");
      if (!statusDisplay) return;┬╖
      try {
        const savedProjectId = await dataService.getValue<string>(
          SETTINGS_KEY_PROJECT,
          { scopeType: \"User\" },
        );
        const savedPipelineId = await dataService.getValue<number>(
          SETTINGS_KEY_PIPELINE,
          { scopeType: \"User\" },
        );
        const webContext = VSS.getWebContext();
        const currentProjectName = webContext?.project?.name || \"Unknown\";
        const currentProjectId = webContext?.project?.id;┬╖
        let html = \"\";┬╖
        // Current context
        html += `<p><strong>Current Project:</strong> ${escapeHtml(currentProjectName)}</p>`;┬╖
        // Source project configuration
        if (savedProjectId) {
          const projectName = getProjectNameById(savedProjectId);
          html += `<p><strong>Source Project:</strong> ${escapeHtml(projectName)} <code>${savedProjectId.substring(0, 8)}...</code></p>`;
        } else {
          html += `<p><strong>Source Project:</strong> <em>Same as current</em></p>`;
        }┬╖
        // Pipeline configuration with validation
        if (savedPipelineId) {
          html += `<p><strong>Pipeline Definition ID:</strong> ${savedPipelineId}`;┬╖
          // Validate the saved pipeline
          const targetProjectId = savedProjectId || currentProjectId;
          if (targetProjectId) {
            const validation = await validatePipeline(
              savedPipelineId,
              targetProjectId,
            );┬╖
            if (validation.valid) {
              html += ` <span class=\"status-valid\">Γ£ô Valid</span>`;
              html += `</p>`;
              html += `<p class=\"status-hint\">Pipeline: \"${escapeHtml(validation.name || \"\")}\" (Build #${validation.buildId})</p>`;
            } else {
              html += ` <span class=\"status-invalid\">ΓÜá∩╕Å Invalid</span>`;
              html += `</p>`;
              html += `<p class=\"status-warning\">ΓÜá∩╕Å ${escapeHtml(validation.error || \"\")}</p>`;
              html += `<p class=\"status-hint\">The dashboard will automatically clear this setting and re-discover pipelines. Consider clearing manually to configure a different pipeline.</p>`;
            }
          } else {
            html += `</p><p class=\"status-warning\">ΓÜá∩╕Å No project ID available for validation</p>`;
          }
        } else {
          html += `<p><strong>Mode:</strong> Auto-discovery</p>`;
          html += `<p class=\"status-hint\">The dashboard will automatically find pipelines with an \"aggregates\" artifact.</p>`;
        }┬╖
        // Dropdown availability
        if (projectDropdownAvailable) {
          html += `<p class=\"status-hint\">Γ£ô Project dropdown available (${projectList.length} projects)</p>`;
        } else {
          html += `<p class=\"status-hint\">Project dropdown not available - using text input</p>`;
        }┬╖
        statusDisplay.innerHTML = html;
      } catch (error: any) {
        statusDisplay.innerHTML = `<p class=\"status-error\">Failed to load status: ${escapeHtml(error.message)}</p>`;
      }
    }┬╖
    /**
     * Get project name by ID from the cached list.
     */
    function getProjectNameById(projectId: string): string {
      const project = projectList.find((p) => p.id === projectId);
      return project?.name || projectId;
    }┬╖
    /**
     * Validate if a pipeline exists and has successful builds with aggregates artifact.
     * Returns validation result with details.
     */
    async function validatePipeline(
      pipelineId: number,
      projectId: string,
    ): Promise<{
      valid: boolean;
      name?: string;
      buildId?: number;
      error?: string;
    }> {
      return new Promise((resolve) => {
        VSS.require([\"TFS/Build/RestClient\"], (BuildRestClient: any) => {
          try {
            const client = BuildRestClient.getClient();┬╖
            // Check if pipeline definition exists
            client
              .getDefinitions(
                projectId,
                null,
                null,
                null,
                2, // queryOrder: definitionNameAscending
                null,
                null,
                null,
                [pipelineId],
              )
              .then((definitions: any[]) => {
                if (!definitions || definitions.length === 0) {
                  resolve({
                    valid: false,
                    error: \"Pipeline definition not found (may have been deleted)\",
                  });
                  return;
                }┬╖
                const pipelineName = definitions[0].name;┬╖
                // Check for successful/partially-succeeded builds
                // resultFilter: 6 = Succeeded(2) | PartiallySucceeded(4)
                client
                  .getBuilds(
                    projectId,
                    [pipelineId],
                    null,
                    null,
                    null,
                    null,
                    null,
                    null,
                    2,
                    6,
                    null,
                    null,
                    1,
                  )
                  .then((builds: any[]) => {
                    if (!builds || builds.length === 0) {
                      resolve({
                        valid: false,
                        name: pipelineName,
                        error: \"No successful builds found\",
                      });
                      return;
                    }┬╖
                    resolve({
                      valid: true,
                      name: pipelineName,
                      buildId: builds[0].id,
                    });
                  })
                  .catch((e: any) => {
                    resolve({
                      valid: false,
                      error: `Build check failed: ${e.message}`,
                    });
                  });
              })
              .catch((e: any) => {
                resolve({
                  valid: false,
                  error: `Definition fetch failed: ${e.message}`,
                });
              });
          } catch (e: any) {
            resolve({ valid: false, error: `Validation error: ${e.message}` });
          }
        });
      });
    }┬╖
    /**
     * Discover pipelines with aggregates artifact in the current project.
     */
    async function discoverPipelines(): Promise<
      Array<{ id: number; name: string; buildId: number }>
    > {
      return new Promise((resolve) => {
        VSS.require([\"TFS/Build/RestClient\"], (BuildRestClient: any) => {
          try {
            const client = BuildRestClient.getClient();
            const webContext = VSS.getWebContext();
            const projectId = webContext.project?.id;
            if (!projectId) {
              resolve([]);
              return;
            }
            const matches: any[] = [];┬╖
            // Get pipeline definitions (limit for performance)
            client
              .getDefinitions(projectId, null, null, null, 2, 50)
              .then(async (definitions: any[]) => {
                for (const def of definitions) {
                  // Get latest successful/partially-succeeded build
                  try {
                    const builds = await client.getBuilds(
                      projectId,
                      [def.id],
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      2,
                      6,
                      null,
                      null,
                      1,
                    );┬╖
                    if (!builds || builds.length === 0) continue;┬╖
                    const latestBuild = builds[0];┬╖
                    // Check for aggregates artifact
                    const artifacts = await client.getArtifacts(
                      projectId,
                      latestBuild.id,
                    );
                    if (!artifacts.some((a: any) => a.name === \"aggregates\"))
                      continue;┬╖
                    matches.push({
                      id: def.id,
                      name: def.name,
                      buildId: latestBuild.id,
                    });
                  } catch (e) {
                    // Skip pipelines we can't access
                    console.debug(`Skipping pipeline ${def.name}:`, e);
                  }
                }
                resolve(matches);
              })
              .catch((e: any) => {
                console.error(\"Discovery: definitions fetch failed:\", e);
                resolve([]);
              });
          } catch (e) {
            console.error(\"Discovery error:\", e);
            resolve([]);
          }
        });
      });
    }┬╖
    /**
     * Run auto-discovery and show results to user.
     */
    async function runDiscovery(): Promise<void> {
      const statusDisplay = document.getElementById(\"status-display\");
      if (!statusDisplay) return;┬╖
      const originalContent = statusDisplay.innerHTML;
      statusDisplay.innerHTML =
        \"<p>≡ƒöì Discovering pipelines with aggregates artifact...</p>\";┬╖
      try {
        const matches = await discoverPipelines();┬╖
        if (matches.length === 0) {
          statusDisplay.innerHTML = `
                    <p class=\"status-warning\">ΓÜá∩╕Å No PR Insights pipelines found in the current project.</p>
                    <p class=\"status-hint\">Create a pipeline using pr-insights-pipeline.yml and run it at least once.</p>
                `;
          showStatus(\"No pipelines found with aggregates artifact\", \"warning\");
          return;
        }┬╖
        let html = `<p><strong>Found ${matches.length} pipeline(s):</strong></p><ul class=\"discovered-pipelines\">`;
        for (const match of matches) {
          html += `<li>
                    <strong>${escapeHtml(match.name)}</strong> (ID: ${match.id})
                    <button class=\"btn btn-small\" id=\"select-pipeline-${match.id}\">Use This</button>
                </li>`;
        }
        html += \"</ul>\";
        html +=
          '<p class=\"status-hint\">Click \"Use This\" to configure, or clear settings for auto-discovery.</p>';┬╖
        statusDisplay.innerHTML = html;┬╖
        // Add event listeners for discovered pipelines
        for (const match of matches) {
          document
            .getElementById(`select-pipeline-${match.id}`)
            ?.addEventListener(\"click\", () => {
              const pipelineInput = document.getElementById(
                \"pipeline-id\",
              ) as HTMLInputElement;
              if (pipelineInput) pipelineInput.value = match.id.toString();
              showStatus(
                `Pipeline ${match.id} selected - click Save to confirm`,
                \"info\",
              );
            });
        }┬╖
        showStatus(`Found ${matches.length} pipeline(s)`, \"success\");
      } catch (error: any) {
        statusDisplay.innerHTML = originalContent;
        showStatus(\"Discovery failed: \" + error.message, \"error\");
      }
    }┬╖
    /**
     * Show status message.
     */
    function showStatus(message: string, type = \"info\"): void {
      const statusEl = document.getElementById(\"status-message\");
      if (!statusEl) return;┬╖
      statusEl.textContent = message;
      statusEl.className = `status-message status-${type}`;┬╖
      // Clear after delay
      setTimeout(() => {
        statusEl.textContent = \"\";
        statusEl.className = \"status-message\";
      }, 5000);
    }┬╖
    /**
     * Escape HTML to prevent XSS.
     */
    function escapeHtml(text: string): string {
      const div = document.createElement(\"div\");
      div.textContent = text;
      return div.innerHTML;
    }┬╖
    /**
     * Set up event listeners.
     */
    function setupEventListeners(): void {
      document.getElementById(\"save-btn\")?.addEventListener(\"click\", saveSettings);
      document
        .getElementById(\"clear-btn\")
        ?.addEventListener(\"click\", clearSettings);
      document
        .getElementById(\"discover-btn\")
        ?.addEventListener(\"click\", runDiscovery);┬╖
      // Enter key saves
      document
        .getElementById(\"pipeline-id\")
        ?.addEventListener(\"keypress\", (e: KeyboardEvent) => {
          if (e.key === \"Enter\") {
            saveSettings();
          }
        });
      document
        .getElementById(\"project-id\")
        ?.addEventListener(\"keypress\", (e: KeyboardEvent) => {
          if (e.key === \"Enter\") {
            saveSettings();
          }
        });
    }┬╖
    // Initialize on load
    if (document.readyState === \"loading\") {
      document.addEventListener(\"DOMContentLoaded\", init);
    } else {
      init();
    }┬╖
    // Global exposure for potential inline handlers (though we use addEventListener now)
    (window as any).selectDiscoveredPipeline = (pipelineId: number) => {
      const pipelineInput = document.getElementById(
        \"pipeline-id\",
      ) as HTMLInputElement;
      if (pipelineInput) pipelineInput.value = pipelineId.toString();
      showStatus(`Pipeline ${pipelineId} selected - click Save to confirm`, \"info\");
    };
    "

      80 |
      81 |     it("should have SETTINGS_KEY_PIPELINE constant matching dashboard", () => {
    > 82 |       expect(settingsCode).toContain(
         |                            ^
      83 |         "SETTINGS_KEY_PIPELINE = 'pr-insights-pipeline-id'",
      84 |       );
      85 |     });

      at Object.<anonymous> (tests/cross-project-settings.test.ts:82:28)

  ΓùÅ Cross-Project Settings ΓÇ║ settings.ts configuration ΓÇ║ should save project ID separately from pipeline ID

    expect(received).toContain(expected) // indexOf

    Expected substring: "SETTINGS_KEY_PROJECT, projectId, { scopeType: 'User' }"
    Received string:    "/**
     * PR Insights Settings Page
     *
     * Allows users to configure:
     * - Source project (for cross-project access)
     * - Pipeline definition ID
     *
     * Settings are user-scoped (not project-scoped) for privacy.
     *
     * Project selection uses graceful degradation:
     * - Shows dropdown when vso.project scope allows listing projects
     * - Falls back to text input when listing isn't available
     */┬╖
    // Settings keys (must match dashboard.js)
    const SETTINGS_KEY_PROJECT = \"pr-insights-source-project\";
    const SETTINGS_KEY_PIPELINE = \"pr-insights-pipeline-id\";┬╖
    // State
    let dataService: IExtensionDataService | null = null;
    let projectDropdownAvailable = false;
    let projectList: any[] = [];┬╖
    /**
     * Initialize Azure DevOps Extension SDK.
     */
    async function initializeAdoSdk(): Promise<void> {
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error(\"Azure DevOps SDK initialization timed out\"));
        }, 10000);┬╖
        VSS.init({
          explicitNotifyLoaded: true,
          usePlatformScripts: true,
          usePlatformStyles: true,
        });┬╖
        VSS.ready(() => {
          clearTimeout(timeout);
          VSS.notifyLoadSucceeded();
          resolve();
        });
      });
    }┬╖
    /**
     * Initialize the settings page.
     */
    async function init(): Promise<void> {
      try {
        await initializeAdoSdk();┬╖
        // Get extension data service
        dataService = await VSS.getService(VSS.ServiceIds.ExtensionData);┬╖
        // Set current project as placeholder
        const webContext = VSS.getWebContext();
        const projectInput = document.getElementById(
          \"project-id\",
        ) as HTMLInputElement | null;
        if (projectInput && webContext?.project?.name) {
          projectInput.placeholder = `Current: ${webContext.project.name}`;
        }┬╖
        // Try to load project dropdown
        await tryLoadProjectDropdown();┬╖
        // Load saved settings
        await loadSettings();┬╖
        // Update status display
        await updateStatus();┬╖
        // Set up event listeners
        setupEventListeners();
      } catch (error: any) {
        console.error(\"Settings initialization failed:\", error);
        showStatus(\"Failed to initialize settings: \" + error.message, \"error\");
      }
    }┬╖
    /**
     * Try to load project dropdown. Degrades gracefully to text input.
     */
    async function tryLoadProjectDropdown(): Promise<void> {
      const dropdown = document.getElementById(
        \"project-select\",
      ) as HTMLSelectElement;
      const textInput = document.getElementById(\"project-id\") as HTMLInputElement;┬╖
      try {
        // Get projects using Core REST client
        const projects = await getOrganizationProjects();┬╖
        if (projects && projects.length > 0) {
          projectList = projects;
          projectDropdownAvailable = true;┬╖
          // Populate dropdown
          dropdown.innerHTML = '<option value=\"\">Current project (auto)</option>';
          for (const project of projects.sort((a: any, b: any) =>
            a.name.localeCompare(b.name),
          )) {
            const option = document.createElement(\"option\");
            option.value = project.id;
            option.textContent = `${project.name} (${project.id.substring(0, 8)}...)`;
            dropdown.appendChild(option);
          }┬╖
          // Show dropdown, hide text input
          dropdown.style.display = \"block\";
          textInput.style.display = \"none\";┬╖
          console.log(`Loaded ${projects.length} projects for dropdown`);
        } else {
          throw new Error(\"No projects returned\");
        }
      } catch (error: any) {
        console.log(
          \"Project dropdown unavailable, using text input:\",
          error.message,
        );
        projectDropdownAvailable = false;┬╖
        // Show text input, hide dropdown
        dropdown.style.display = \"none\";
        textInput.style.display = \"block\";
      }
    }┬╖
    /**
     * Get list of projects in the organization.
     * Requires vso.project scope.
     */
    async function getOrganizationProjects(): Promise<any[]> {
      return new Promise((resolve, reject) => {
        VSS.require([\"TFS/Core/RestClient\"], (CoreRestClient: any) => {
          try {
            const client = CoreRestClient.getClient();
            client
              .getProjects()
              .then((projects: any[]) => {
                resolve(projects || []);
              })
              .catch((error: any) => {
                reject(error);
              });
          } catch (error) {
            reject(error);
          }
        });
      });
    }┬╖
    /**
     * Load saved settings into form.
     */
    async function loadSettings(): Promise<void> {
      if (!dataService) return;┬╖
      try {
        const savedProjectId = await dataService.getValue<string>(
          SETTINGS_KEY_PROJECT,
          { scopeType: \"User\" },
        );
        const savedPipelineId = await dataService.getValue<number>(
          SETTINGS_KEY_PIPELINE,
          { scopeType: \"User\" },
        );┬╖
        // Set project
        if (savedProjectId) {
          if (projectDropdownAvailable) {
            const dropdown = document.getElementById(
              \"project-select\",
            ) as HTMLSelectElement;
            if (dropdown) dropdown.value = savedProjectId;
          } else {
            const textInput = document.getElementById(
              \"project-id\",
            ) as HTMLInputElement;
            if (textInput) textInput.value = savedProjectId;
          }
        }┬╖
        // Set pipeline ID
        const pipelineInput = document.getElementById(
          \"pipeline-id\",
        ) as HTMLInputElement;
        if (pipelineInput && savedPipelineId) {
          pipelineInput.value = savedPipelineId.toString();
        }
      } catch (error) {
        console.log(\"No saved settings found:\", error);
      }
    }┬╖
    /**
     * Get the selected project ID from either dropdown or text input.
     */
    function getSelectedProjectId(): string | null {
      if (projectDropdownAvailable) {
        const dropdown = document.getElementById(
          \"project-select\",
        ) as HTMLSelectElement;
        return dropdown.value || null;
      } else {
        const textInput = document.getElementById(\"project-id\") as HTMLInputElement;
        const value = textInput.value.trim();
        return value || null;
      }
    }┬╖
    /**
     * Save settings from form.
     */
    async function saveSettings(): Promise<void> {
      if (!dataService) return;┬╖
      const projectId = getSelectedProjectId();
      const pipelineInput = document.getElementById(
        \"pipeline-id\",
      ) as HTMLInputElement | null;
      const pipelineValue = pipelineInput?.value?.trim();┬╖
      try {
        // Save project ID
        await dataService.setValue(SETTINGS_KEY_PROJECT, projectId, {
          scopeType: \"User\",
        });┬╖
        // Save pipeline ID
        if (pipelineValue) {
          const pipelineId = parseInt(pipelineValue, 10);
          if (isNaN(pipelineId) || pipelineId <= 0) {
            showStatus(\"Pipeline ID must be a positive integer\", \"error\");
            return;
          }
          await dataService.setValue(SETTINGS_KEY_PIPELINE, pipelineId, {
            scopeType: \"User\",
          });
        } else {
          await dataService.setValue(SETTINGS_KEY_PIPELINE, null, {
            scopeType: \"User\",
          });
        }┬╖
        showStatus(\"Settings saved successfully\", \"success\");┬╖
        // Update status display
        await updateStatus();
      } catch (error: any) {
        console.error(\"Failed to save settings:\", error);
        showStatus(\"Failed to save settings: \" + error.message, \"error\");
      }
    }┬╖
    /**
     * Clear settings.
     */
    async function clearSettings(): Promise<void> {
      if (!dataService) return;┬╖
      // Clear form
      if (projectDropdownAvailable) {
        const dropdown = document.getElementById(
          \"project-select\",
        ) as HTMLSelectElement;
        if (dropdown) dropdown.value = \"\";
      } else {
        const textInput = document.getElementById(\"project-id\") as HTMLInputElement;
        if (textInput) textInput.value = \"\";
      }
      const pipelineInput = document.getElementById(
        \"pipeline-id\",
      ) as HTMLInputElement;
      if (pipelineInput) pipelineInput.value = \"\";┬╖
      try {
        await dataService.setValue(SETTINGS_KEY_PROJECT, null, {
          scopeType: \"User\",
        });
        await dataService.setValue(SETTINGS_KEY_PIPELINE, null, {
          scopeType: \"User\",
        });
        showStatus(
          \"Settings cleared - using current project with auto-discovery\",
          \"success\",
        );
        await updateStatus();
      } catch (error: any) {
        console.error(\"Failed to clear settings:\", error);
        showStatus(\"Failed to clear settings: \" + error.message, \"error\");
      }
    }┬╖
    /**
     * Update the status display with current configuration.
     */
    async function updateStatus(): Promise<void> {
      if (!dataService) return;┬╖
      const statusDisplay = document.getElementById(\"status-display\");
      if (!statusDisplay) return;┬╖
      try {
        const savedProjectId = await dataService.getValue<string>(
          SETTINGS_KEY_PROJECT,
          { scopeType: \"User\" },
        );
        const savedPipelineId = await dataService.getValue<number>(
          SETTINGS_KEY_PIPELINE,
          { scopeType: \"User\" },
        );
        const webContext = VSS.getWebContext();
        const currentProjectName = webContext?.project?.name || \"Unknown\";
        const currentProjectId = webContext?.project?.id;┬╖
        let html = \"\";┬╖
        // Current context
        html += `<p><strong>Current Project:</strong> ${escapeHtml(currentProjectName)}</p>`;┬╖
        // Source project configuration
        if (savedProjectId) {
          const projectName = getProjectNameById(savedProjectId);
          html += `<p><strong>Source Project:</strong> ${escapeHtml(projectName)} <code>${savedProjectId.substring(0, 8)}...</code></p>`;
        } else {
          html += `<p><strong>Source Project:</strong> <em>Same as current</em></p>`;
        }┬╖
        // Pipeline configuration with validation
        if (savedPipelineId) {
          html += `<p><strong>Pipeline Definition ID:</strong> ${savedPipelineId}`;┬╖
          // Validate the saved pipeline
          const targetProjectId = savedProjectId || currentProjectId;
          if (targetProjectId) {
            const validation = await validatePipeline(
              savedPipelineId,
              targetProjectId,
            );┬╖
            if (validation.valid) {
              html += ` <span class=\"status-valid\">Γ£ô Valid</span>`;
              html += `</p>`;
              html += `<p class=\"status-hint\">Pipeline: \"${escapeHtml(validation.name || \"\")}\" (Build #${validation.buildId})</p>`;
            } else {
              html += ` <span class=\"status-invalid\">ΓÜá∩╕Å Invalid</span>`;
              html += `</p>`;
              html += `<p class=\"status-warning\">ΓÜá∩╕Å ${escapeHtml(validation.error || \"\")}</p>`;
              html += `<p class=\"status-hint\">The dashboard will automatically clear this setting and re-discover pipelines. Consider clearing manually to configure a different pipeline.</p>`;
            }
          } else {
            html += `</p><p class=\"status-warning\">ΓÜá∩╕Å No project ID available for validation</p>`;
          }
        } else {
          html += `<p><strong>Mode:</strong> Auto-discovery</p>`;
          html += `<p class=\"status-hint\">The dashboard will automatically find pipelines with an \"aggregates\" artifact.</p>`;
        }┬╖
        // Dropdown availability
        if (projectDropdownAvailable) {
          html += `<p class=\"status-hint\">Γ£ô Project dropdown available (${projectList.length} projects)</p>`;
        } else {
          html += `<p class=\"status-hint\">Project dropdown not available - using text input</p>`;
        }┬╖
        statusDisplay.innerHTML = html;
      } catch (error: any) {
        statusDisplay.innerHTML = `<p class=\"status-error\">Failed to load status: ${escapeHtml(error.message)}</p>`;
      }
    }┬╖
    /**
     * Get project name by ID from the cached list.
     */
    function getProjectNameById(projectId: string): string {
      const project = projectList.find((p) => p.id === projectId);
      return project?.name || projectId;
    }┬╖
    /**
     * Validate if a pipeline exists and has successful builds with aggregates artifact.
     * Returns validation result with details.
     */
    async function validatePipeline(
      pipelineId: number,
      projectId: string,
    ): Promise<{
      valid: boolean;
      name?: string;
      buildId?: number;
      error?: string;
    }> {
      return new Promise((resolve) => {
        VSS.require([\"TFS/Build/RestClient\"], (BuildRestClient: any) => {
          try {
            const client = BuildRestClient.getClient();┬╖
            // Check if pipeline definition exists
            client
              .getDefinitions(
                projectId,
                null,
                null,
                null,
                2, // queryOrder: definitionNameAscending
                null,
                null,
                null,
                [pipelineId],
              )
              .then((definitions: any[]) => {
                if (!definitions || definitions.length === 0) {
                  resolve({
                    valid: false,
                    error: \"Pipeline definition not found (may have been deleted)\",
                  });
                  return;
                }┬╖
                const pipelineName = definitions[0].name;┬╖
                // Check for successful/partially-succeeded builds
                // resultFilter: 6 = Succeeded(2) | PartiallySucceeded(4)
                client
                  .getBuilds(
                    projectId,
                    [pipelineId],
                    null,
                    null,
                    null,
                    null,
                    null,
                    null,
                    2,
                    6,
                    null,
                    null,
                    1,
                  )
                  .then((builds: any[]) => {
                    if (!builds || builds.length === 0) {
                      resolve({
                        valid: false,
                        name: pipelineName,
                        error: \"No successful builds found\",
                      });
                      return;
                    }┬╖
                    resolve({
                      valid: true,
                      name: pipelineName,
                      buildId: builds[0].id,
                    });
                  })
                  .catch((e: any) => {
                    resolve({
                      valid: false,
                      error: `Build check failed: ${e.message}`,
                    });
                  });
              })
              .catch((e: any) => {
                resolve({
                  valid: false,
                  error: `Definition fetch failed: ${e.message}`,
                });
              });
          } catch (e: any) {
            resolve({ valid: false, error: `Validation error: ${e.message}` });
          }
        });
      });
    }┬╖
    /**
     * Discover pipelines with aggregates artifact in the current project.
     */
    async function discoverPipelines(): Promise<
      Array<{ id: number; name: string; buildId: number }>
    > {
      return new Promise((resolve) => {
        VSS.require([\"TFS/Build/RestClient\"], (BuildRestClient: any) => {
          try {
            const client = BuildRestClient.getClient();
            const webContext = VSS.getWebContext();
            const projectId = webContext.project?.id;
            if (!projectId) {
              resolve([]);
              return;
            }
            const matches: any[] = [];┬╖
            // Get pipeline definitions (limit for performance)
            client
              .getDefinitions(projectId, null, null, null, 2, 50)
              .then(async (definitions: any[]) => {
                for (const def of definitions) {
                  // Get latest successful/partially-succeeded build
                  try {
                    const builds = await client.getBuilds(
                      projectId,
                      [def.id],
                      null,
                      null,
                      null,
                      null,
                      null,
                      null,
                      2,
                      6,
                      null,
                      null,
                      1,
                    );┬╖
                    if (!builds || builds.length === 0) continue;┬╖
                    const latestBuild = builds[0];┬╖
                    // Check for aggregates artifact
                    const artifacts = await client.getArtifacts(
                      projectId,
                      latestBuild.id,
                    );
                    if (!artifacts.some((a: any) => a.name === \"aggregates\"))
                      continue;┬╖
                    matches.push({
                      id: def.id,
                      name: def.name,
                      buildId: latestBuild.id,
                    });
                  } catch (e) {
                    // Skip pipelines we can't access
                    console.debug(`Skipping pipeline ${def.name}:`, e);
                  }
                }
                resolve(matches);
              })
              .catch((e: any) => {
                console.error(\"Discovery: definitions fetch failed:\", e);
                resolve([]);
              });
          } catch (e) {
            console.error(\"Discovery error:\", e);
            resolve([]);
          }
        });
      });
    }┬╖
    /**
     * Run auto-discovery and show results to user.
     */
    async function runDiscovery(): Promise<void> {
      const statusDisplay = document.getElementById(\"status-display\");
      if (!statusDisplay) return;┬╖
      const originalContent = statusDisplay.innerHTML;
      statusDisplay.innerHTML =
        \"<p>≡ƒöì Discovering pipelines with aggregates artifact...</p>\";┬╖
      try {
        const matches = await discoverPipelines();┬╖
        if (matches.length === 0) {
          statusDisplay.innerHTML = `
                    <p class=\"status-warning\">ΓÜá∩╕Å No PR Insights pipelines found in the current project.</p>
                    <p class=\"status-hint\">Create a pipeline using pr-insights-pipeline.yml and run it at least once.</p>
                `;
          showStatus(\"No pipelines found with aggregates artifact\", \"warning\");
          return;
        }┬╖
        let html = `<p><strong>Found ${matches.length} pipeline(s):</strong></p><ul class=\"discovered-pipelines\">`;
        for (const match of matches) {
          html += `<li>
                    <strong>${escapeHtml(match.name)}</strong> (ID: ${match.id})
                    <button class=\"btn btn-small\" id=\"select-pipeline-${match.id}\">Use This</button>
                </li>`;
        }
        html += \"</ul>\";
        html +=
          '<p class=\"status-hint\">Click \"Use This\" to configure, or clear settings for auto-discovery.</p>';┬╖
        statusDisplay.innerHTML = html;┬╖
        // Add event listeners for discovered pipelines
        for (const match of matches) {
          document
            .getElementById(`select-pipeline-${match.id}`)
            ?.addEventListener(\"click\", () => {
              const pipelineInput = document.getElementById(
                \"pipeline-id\",
              ) as HTMLInputElement;
              if (pipelineInput) pipelineInput.value = match.id.toString();
              showStatus(
                `Pipeline ${match.id} selected - click Save to confirm`,
                \"info\",
              );
            });
        }┬╖
        showStatus(`Found ${matches.length} pipeline(s)`, \"success\");
      } catch (error: any) {
        statusDisplay.innerHTML = originalContent;
        showStatus(\"Discovery failed: \" + error.message, \"error\");
      }
    }┬╖
    /**
     * Show status message.
     */
    function showStatus(message: string, type = \"info\"): void {
      const statusEl = document.getElementById(\"status-message\");
      if (!statusEl) return;┬╖
      statusEl.textContent = message;
      statusEl.className = `status-message status-${type}`;┬╖
      // Clear after delay
      setTimeout(() => {
        statusEl.textContent = \"\";
        statusEl.className = \"status-message\";
      }, 5000);
    }┬╖
    /**
     * Escape HTML to prevent XSS.
     */
    function escapeHtml(text: string): string {
      const div = document.createElement(\"div\");
      div.textContent = text;
      return div.innerHTML;
    }┬╖
    /**
     * Set up event listeners.
     */
    function setupEventListeners(): void {
      document.getElementById(\"save-btn\")?.addEventListener(\"click\", saveSettings);
      document
        .getElementById(\"clear-btn\")
        ?.addEventListener(\"click\", clearSettings);
      document
        .getElementById(\"discover-btn\")
        ?.addEventListener(\"click\", runDiscovery);┬╖
      // Enter key saves
      document
        .getElementById(\"pipeline-id\")
        ?.addEventListener(\"keypress\", (e: KeyboardEvent) => {
          if (e.key === \"Enter\") {
            saveSettings();
          }
        });
      document
        .getElementById(\"project-id\")
        ?.addEventListener(\"keypress\", (e: KeyboardEvent) => {
          if (e.key === \"Enter\") {
            saveSettings();
          }
        });
    }┬╖
    // Initialize on load
    if (document.readyState === \"loading\") {
      document.addEventListener(\"DOMContentLoaded\", init);
    } else {
      init();
    }┬╖
    // Global exposure for potential inline handlers (though we use addEventListener now)
    (window as any).selectDiscoveredPipeline = (pipelineId: number) => {
      const pipelineInput = document.getElementById(
        \"pipeline-id\",
      ) as HTMLInputElement;
      if (pipelineInput) pipelineInput.value = pipelineId.toString();
      showStatus(`Pipeline ${pipelineId} selected - click Save to confirm`, \"info\");
    };
    "

      100 |
      101 |     it("should save project ID separately from pipeline ID", () => {
    > 102 |       expect(settingsCode).toContain(
          |                            ^
      103 |         "SETTINGS_KEY_PROJECT, projectId, { scopeType: 'User' }",
      104 |       );
      105 |       expect(settingsCode).toContain(

      at Object.<anonymous> (tests/cross-project-settings.test.ts:102:28)

  ΓùÅ Cross-Project Settings ΓÇ║ settings keys consistency ΓÇ║ should use the same settings keys in both files

    expect(received).toBe(expected) // Object.is equality

    Expected: "pr-insights-source-project"
    Received: undefined

      131 |       )?.[1];
      132 |
    > 133 |       expect(dashboardProjectKey).toBe("pr-insights-source-project");
          |                                   ^
      134 |       expect(settingsProjectKey).toBe("pr-insights-source-project");
      135 |       expect(dashboardProjectKey).toBe(settingsProjectKey);
      136 |

      at Object.<anonymous> (tests/cross-project-settings.test.ts:133:35)

PASS tests/date-range-warning.test.ts
  Date-Range Warning Modal (Phase 4)
    ΓêÜ modal shows for date range > 365 days (27 ms)
    ΓêÜ clicking "Adjust Range" returns false (cancels load) (7 ms)
    ΓêÜ clicking "Continue Anyway" returns true (proceeds with load) (5 ms)
    ΓêÜ modal does not show for date range <= 365 days (4 ms)
    ΓêÜ modal displays correct day count (6 ms)
    ΓêÜ modal can be shown multiple times (6 ms)

PASS tests/dataset-loader-nested.test.ts
  DatasetLoader Nested Layout Resolution
    DATASET_CANDIDATE_PATHS
      ΓêÜ includes only supported candidate paths in priority order (2 ms)
    resolveDatasetRoot
      ΓêÜ finds manifest at root (base URL) (3 ms)
      ΓêÜ finds manifest in aggregates/ subdirectory (1 ms)
      ΓêÜ deprecated aggregates/aggregates layout is NOT supported
      ΓêÜ returns null when manifest not found in any candidate (1 ms)
      ΓêÜ handles network errors gracefully and continues probing (1 ms)
      ΓêÜ caches result and returns same value on subsequent calls (1 ms)
      ΓêÜ works with empty base URL (1 ms)
    loadManifest with nested layouts
      ΓêÜ auto-resolves dataset root before loading manifest (1 ms)
      ΓêÜ uses resolved effective base URL for all subsequent paths
    resolvePath with effective base URL
      ΓêÜ uses effective base URL after resolution (1 ms)
      ΓêÜ falls back to base URL when resolution finds nothing

PASS tests/dashboard.test.ts
  Dashboard Rendering
    renderPredictions
      ΓêÜ handles null input safely (never throws) (21 ms)
      ΓêÜ handles undefined input safely (never throws) (14 ms)
      ΓêÜ renders stub warning when is_stub=true (42 ms)
      ΓêÜ does not render stub warning when is_stub=false (9 ms)
      ΓêÜ handles null container safely (5 ms)
    renderAIInsights
      ΓêÜ groups insights by severity correctly (62 ms)
      ΓêÜ handles null input safely (never throws) (39 ms)
      ΓêÜ handles undefined input safely (never throws) (3 ms)
      ΓêÜ renders stub warning when is_stub=true (2 ms)
    Error State Rendering
      ΓêÜ Missing state shows "Not generated yet" message for predictions (4 ms)
      ΓêÜ Invalid state shows "Unable to display" + diagnostic code for predictions (4 ms)
      ΓêÜ Empty state shows "No data yet" message for insights (3 ms)
      ΓêÜ Invalid state shows "Unable to display" + diagnostic code for insights (4 ms)
      ΓêÜ rendering functions handle null container (never throw) (3 ms)
    Date-Range Warning UX
      ΓêÜ Range > 365 days ΓåÆ modal visible, load blocked (14 ms)
      ΓêÜ "Adjust Range" click ΓåÆ modal hidden, returns false (load cancelled) (39 ms)
      ΓêÜ "Continue" click ΓåÆ modal hidden, returns true (load proceeds) (57 ms)
      ΓêÜ Modal displays correct day count (4 ms)
      ΓêÜ Modal can be shown multiple times (5 ms)
      applyCustomDates integration
        ΓêÜ Range <= 365 days ΓåÆ no modal, load proceeds immediately (8 ms)
        ΓêÜ Range exactly 366 days ΓåÆ modal shown (2 ms)
        ΓêÜ Large range + user cancels ΓåÆ load cancelled (2 ms)
  Utility Functions
    formatDuration
      ΓêÜ formats minutes correctly (1 ms)
      ΓêÜ formats hours correctly
      ΓêÜ formats days correctly
      ΓêÜ rounds minutes properly
    median
      ΓêÜ calculates median for odd-length arrays (1 ms)
      ΓêÜ calculates median for even-length arrays
      ΓêÜ handles edge cases (1 ms)
  Sprint 1: Trend Deltas & Metrics
    calculateMetrics
      ΓêÜ calculates metrics from rollups correctly
      ΓêÜ handles empty rollups (2 ms)
      ΓêÜ handles null/undefined rollups
      ΓêÜ handles missing fields in rollups (1 ms)
      ΓêÜ filters out null cycle time values
    calculatePercentChange
      ΓêÜ calculates positive change correctly
      ΓêÜ calculates negative change correctly (1 ms)
      ΓêÜ returns null for zero previous value
      ΓêÜ returns null for null/undefined values (1 ms)
      ΓêÜ handles zero current value
    getPreviousPeriod
      ΓêÜ calculates previous period correctly for 30-day range (1 ms)
      ΓêÜ calculates previous period correctly for 90-day range
      ΓêÜ handles year boundaries
    renderDelta
      ΓêÜ renders positive delta with up arrow (4 ms)
      ΓêÜ renders negative delta with down arrow (3 ms)
      ΓêÜ renders neutral delta for small changes (7 ms)
      ΓêÜ applies inverse logic for cycle time (lower is better) (3 ms)
      ΓêÜ clears element for null percentChange (3 ms)
      ΓêÜ handles null element without throwing (1 ms)
      ΓêÜ handles boundary value of exactly 2% (6 ms)
      ΓêÜ handles boundary value of -2% (6 ms)
  Sprint 3: Sparklines & Moving Average
    calculateMovingAverage
      ΓêÜ calculates 4-week moving average correctly (2 ms)
      ΓêÜ handles custom window size (29 ms)
      ΓêÜ handles array shorter than window
      ΓêÜ handles empty array
      ΓêÜ handles single element (4 ms)
    extractSparklineData
      ΓêÜ extracts all metric arrays from rollups (1 ms)
      ΓêÜ handles missing fields with defaults (1 ms)
      ΓêÜ filters out null/undefined cycle times (1 ms)
      ΓêÜ returns empty arrays for null/undefined input (1 ms)
    renderSparkline
      ΓêÜ renders SVG with path elements (7 ms)
      ΓêÜ limits to last 8 data points (2 ms)
      ΓêÜ clears element for insufficient data (1 ms)
      ΓêÜ clears element for null values (1 ms)
      ΓêÜ handles null element without throwing
      ΓêÜ handles flat data (all same values) (2 ms)
      ΓêÜ includes viewBox attribute for proper scaling (2 ms)
  Sprint 4: Charts & Tooltips
    addChartTooltips
      ΓêÜ attaches event listeners to chart dots (6 ms)
      ΓêÜ hides tooltip on mouseleave (5 ms)
      ΓêÜ updates tooltip content on different dot hover (4 ms)
    renderCycleTimeTrend
      ΓêÜ renders no-data message for empty rollups (6 ms)
      ΓêÜ renders no-data message for single rollup (6 ms)
    renderReviewerActivity
      ΓêÜ renders no-data message for empty rollups (1 ms)
      ΓêÜ renders no-data message when all reviewers_count are zero (1 ms)
  Sprint 5: Comparison Mode & Export
    showToast
      ΓêÜ creates toast with success type (5 ms)
      ΓêÜ creates toast with error type (4 ms)
      ΓêÜ defaults to success type (3 ms)
      ΓêÜ removes toast after 3 seconds (8 ms)
    exportToCsv
      ΓêÜ generates valid CSV content (2 ms)
      ΓêÜ handles missing fields gracefully (1 ms)
      ΓêÜ shows error toast for empty data
      ΓêÜ shows error toast for null data (1 ms)
    downloadRawDataZip
      ΓêÜ shows error when buildId is not available (2 ms)
      ΓêÜ shows error when artifact is not found (2 ms)
      ΓêÜ shows error when download URL is missing (2 ms)
      ΓêÜ adds format=zip to URL if not present (3 ms)
      ΓêÜ preserves format=zip if already present (1 ms)
      ΓêÜ handles 403 permission denied (23 ms)
      ΓêÜ handles 401 unauthorized (1 ms)
      ΓêÜ handles other fetch errors (1 ms)
      ΓêÜ hides export menu when called (2 ms)
    Comparison Mode State
      ΓêÜ toggles comparison mode on button click (32 ms)
      ΓêÜ exits comparison mode (5 ms)
    updateComparisonBanner
      ΓêÜ updates banner with formatted date ranges (35 ms)
    URL State Management
      ΓêÜ serializes date range to URL params (2 ms)
      ΓêÜ serializes filters to URL params
      ΓêÜ includes comparison mode flag
      ΓêÜ omits empty values
  Client-Side Filtering (applyFiltersToRollups)
    ΓêÜ returns original rollups when no filters are active
    ΓêÜ filters by repository using by_repository slices (1 ms)
    ΓêÜ aggregates metrics across multiple selected repos (2 ms)
    ΓêÜ returns zeroed metrics when selected repos not found (1 ms)
    ΓêÜ returns original rollup when no slices available for filter
    ΓêÜ filters by team using by_team slices (1 ms)
    ΓêÜ handles null cycle time values in aggregation
    ΓêÜ preserves other rollup fields when filtering
  Sprint 2: Filter Management
    createFilterChip
      ΓêÜ creates repo chip with correct structure
      ΓêÜ creates team chip with correct structure
    Filter UI Updates
      ΓêÜ shows clear button when filters are active (7 ms)
      ΓêÜ hides clear button when no filters (3 ms)
      ΓêÜ clears all filters on clear button click (15 ms)
    restoreFiltersFromUrl
      ΓêÜ restores repo filters from URL params (3 ms)
      ΓêÜ restores team filters from URL params (2 ms)
      ΓêÜ handles missing URL params gracefully (2 ms)
      ΓêÜ handles invalid filter values gracefully (repos not in dimensions) (4 ms)
      ΓêÜ ignores unknown URL query keys (4 ms)
      ΓêÜ handles malformed URL params gracefully (2 ms)
    URL State Round-Trip
      ΓêÜ round-trip preserves filter state (2 ms)
      ΓêÜ stable ordering in serialization (1 ms)
      ΓêÜ round-trip with date range (1 ms)
      ΓêÜ empty state produces empty URL
    populateFilterDropdowns
      ΓêÜ populates repo dropdown from dimensions (4 ms)
      ΓêÜ populates team dropdown from dimensions (3 ms)
      ΓêÜ hides filter group when no dimensions available (2 ms)
  Local Mode Detection
    isLocalMode
      ΓêÜ returns false when LOCAL_DASHBOARD_MODE is not set (1 ms)
      ΓêÜ returns true when LOCAL_DASHBOARD_MODE is true
      ΓêÜ returns false when LOCAL_DASHBOARD_MODE is false
      ΓêÜ returns false when LOCAL_DASHBOARD_MODE is a non-boolean truthy value (1 ms)
      ΓêÜ returns false when LOCAL_DASHBOARD_MODE is 1
    getLocalDatasetPath
      ΓêÜ returns default path when DATASET_PATH is not set
      ΓêÜ returns configured path when DATASET_PATH is set (1 ms)
      ΓêÜ returns DATASET_PATH even if empty string
    Local Mode Initialization Path
      ΓêÜ creates DatasetLoader with correct path in local mode
      ΓêÜ sets currentBuildId to null in local mode (1 ms)
  Version Adapter Pattern
    normalizeRollup
      ΓêÜ handles null input
      ΓêÜ handles undefined input
      ΓêÜ handles non-object input (1 ms)
      ΓêÜ preserves existing fields
      ΓêÜ provides defaults for missing fields (old schema) (1 ms)
      ΓêÜ does not override existing null values (1 ms)
      ΓêÜ does not override zero values
      ΓêÜ preserves by_repository slices when present
      ΓêÜ preserves by_team slices when present
    normalizeRollups
      ΓêÜ handles null input
      ΓêÜ handles undefined input (1 ms)
      ΓêÜ handles non-array input
      ΓêÜ handles empty array
      ΓêÜ normalizes all rollups in array (1 ms)
      ΓêÜ handles mixed valid and invalid entries
    Backward Compatibility Scenarios
      ΓêÜ v1.0 rollup (minimal fields) normalizes correctly (1 ms)
      ΓêÜ v1.1 rollup (with cycle times) normalizes correctly
      ΓêÜ v1.2 rollup (with contributor counts) normalizes correctly (1 ms)
      ΓêÜ v1.3 rollup (current with slices) stays unchanged

  console.error
    [DatasetLoader] Invalid predictions schema: Unsupported schema version: 99

    [0m [90m 809 |[39m       [36mconst[39m validationResult [33m=[39m [36mthis[39m[33m.[39mvalidatePredictionsSchema(predictions)[33m;[39m
     [90m 810 |[39m       [36mif[39m ([33m![39mvalidationResult[33m.[39mvalid) {
    [31m[1m>[22m[39m[90m 811 |[39m         console[33m.[39merror(
     [90m     |[39m                 [31m[1m^[22m[39m
     [90m 812 |[39m           [32m"[DatasetLoader] Invalid predictions schema:"[39m[33m,[39m
     [90m 813 |[39m           validationResult[33m.[39merror[33m,[39m
     [90m 814 |[39m         )[33m;[39m[0m

      at DatasetLoader.loadPredictions (ui/dataset-loader.ts:811:17)
      at Object.<anonymous> (tests/dataset-loader.test.ts:226:22)

PASS tests/local-mode-integration.test.ts
  Local Mode Integration
    UI State Changes
      ΓêÜ hides download button in local mode (32 ms)
      ΓêÜ displays "Local Dashboard" in header (32 ms)
    Dataset Loading
      ΓêÜ requests dataset from configured DATASET_PATH (14 ms)
      ΓêÜ uses default path when DATASET_PATH not set (4 ms)
    Error Handling
      ΓêÜ shows error state when dataset-manifest.json missing (6 ms)
    Mode Detection
      ΓêÜ isLocalMode returns true when LOCAL_DASHBOARD_MODE is true (2 ms)
      ΓêÜ isLocalMode returns false for non-boolean truthy values (2 ms)
      ΓêÜ getLocalDatasetPath returns DATASET_PATH or default (7 ms)

  console.error
    [DatasetLoader] Invalid predictions schema: Unsupported schema version: 99

    [0m [90m 809 |[39m       [36mconst[39m validationResult [33m=[39m [36mthis[39m[33m.[39mvalidatePredictionsSchema(predictions)[33m;[39m
     [90m 810 |[39m       [36mif[39m ([33m![39mvalidationResult[33m.[39mvalid) {
    [31m[1m>[22m[39m[90m 811 |[39m         console[33m.[39merror(
     [90m     |[39m                 [31m[1m^[22m[39m
     [90m 812 |[39m           [32m"[DatasetLoader] Invalid predictions schema:"[39m[33m,[39m
     [90m 813 |[39m           validationResult[33m.[39merror[33m,[39m
     [90m 814 |[39m         )[33m;[39m[0m

      at DatasetLoader.loadPredictions (ui/dataset-loader.ts:811:17)
      at Object.<anonymous> (tests/dataset-loader.test.ts:273:24)

  console.error
    [DatasetLoader] Invalid insights schema: Unsupported schema version: 99

    [0m [90m 858 |[39m       [36mconst[39m validationResult [33m=[39m [36mthis[39m[33m.[39mvalidateInsightsSchema(insights)[33m;[39m
     [90m 859 |[39m       [36mif[39m ([33m![39mvalidationResult[33m.[39mvalid) {
    [31m[1m>[22m[39m[90m 860 |[39m         console[33m.[39merror(
     [90m     |[39m                 [31m[1m^[22m[39m
     [90m 861 |[39m           [32m"[DatasetLoader] Invalid insights schema:"[39m[33m,[39m
     [90m 862 |[39m           validationResult[33m.[39merror[33m,[39m
     [90m 863 |[39m         )[33m;[39m[0m

      at DatasetLoader.loadInsights (ui/dataset-loader.ts:860:17)
      at Object.<anonymous> (tests/dataset-loader.test.ts:321:22)

PASS tests/dataset-loader.test.ts
  DatasetLoader
    validatePredictionsSchema
      ΓêÜ returns { valid: true } for valid input (2 ms)
      ΓêÜ returns { valid: false, error } for missing data
      ΓêÜ returns { valid: false, error } for missing schema_version (1 ms)
      ΓêÜ returns { valid: false, error } for unsupported schema version
      ΓêÜ returns { valid: false, error } for missing forecasts array (1 ms)
      ΓêÜ returns { valid: false, error } for invalid forecast structure
    validateInsightsSchema
      ΓêÜ returns { valid: true } for valid input (1 ms)
      ΓêÜ returns typed error object, never throws (1 ms)
      ΓêÜ returns { valid: false, error } for missing schema_version (1 ms)
      ΓêÜ returns { valid: false, error } for missing insights array (1 ms)
      ΓêÜ returns { valid: false, error } for invalid insight structure
    loadPredictions state machine
      ΓêÜ returns { state: "disabled" } when feature flag is false (1 ms)
      ΓêÜ returns { state: "missing" } on 404 (1 ms)
      ΓêÜ returns { state: "auth" } on 401
      ΓêÜ returns { state: "auth" } on 403 (1 ms)
      ΓêÜ returns { state: "invalid" } on schema failure (174 ms)
      ΓêÜ returns { state: "ok", data } on success
      ΓêÜ always returns typed state object (never null or undefined) (25 ms)
    loadInsights state machine
      ΓêÜ returns { state: "disabled" } when feature flag is false (1 ms)
      ΓêÜ returns { state: "missing" } on 404
      ΓêÜ returns { state: "auth" } on 401
      ΓêÜ returns { state: "invalid" } on schema failure (7 ms)
      ΓêÜ returns { state: "ok", data } on success (2 ms)
    isFeatureEnabled
      ΓêÜ returns false when manifest is not loaded
      ΓêÜ returns true when feature flag is true
      ΓêÜ returns false when feature flag is false (1 ms)

PASS tests/api-patterns.test.ts
  Build API Call Patterns
    getDefinitions queryOrder requirement
      ΓêÜ should verify ALL getDefinitions calls in dashboard.ts have queryOrder at position 5 (15 ms)
      ΓêÜ should verify ALL getDefinitions calls in settings.ts have queryOrder at position 5 (2 ms)
      ΓêÜ should have at least 3 getDefinitions calls in dashboard.ts with correct pattern (1 ms)
      ΓêÜ should document the API parameter signature for reference (1 ms)
    DefinitionQueryOrder enum values
      ΓêÜ should have definitionNameAscending = 2
      ΓêÜ should use definitionNameAscending (2) as the standard queryOrder value (6 ms)

PASS tests/ado-sdk.test.ts (5.012 s)
  ADO SDK Mocks
    createSdkMock
      ΓêÜ creates mock with default values (23 ms)
      ΓêÜ allows custom access token (1 ms)
      ΓêÜ allows custom web context (1 ms)
      ΓêÜ provides required SDK methods (1 ms)
    createBuildApiMock
      ΓêÜ returns successful runs and artifacts for SUCCESS scenario (1 ms)
      ΓêÜ returns empty runs for NO_RUNS scenario (1 ms)
      ΓêÜ returns empty artifacts for NO_ARTIFACTS scenario (1 ms)
      ΓêÜ throws 403 for PERMISSION_DENIED scenario (1 ms)
      ΓêÜ throws 404 for NOT_FOUND scenario (1 ms)
      ΓêÜ throws 503 for TRANSIENT_ERROR scenario
      ΓêÜ generates artifact content URLs (1 ms)
    installSdkMocks
      ΓêÜ installs SDK on global object (1 ms)
      ΓêÜ returns the created SDK (1 ms)
    BuildApiScenarios
      ΓêÜ defines all required scenarios

PASS tests/auth-pattern.test.ts (5.07 s)
  ArtifactClient Authentication Pattern
    initialize()
      ΓêÜ should use VSS.getAccessToken() for authentication (13 ms)
      ΓêÜ should NOT use VSS.getService() for authentication (2 ms)
      ΓêÜ should extract token from getAccessToken result correctly (1 ms)
      ΓêÜ should handle getAccessToken returning token in correct format (1 ms)
    SDK ServiceIds verification
      ΓêÜ should verify AuthTokenService is NOT in bundled SDK ServiceIds
      ΓêÜ should verify VSS.getAccessToken exists as the correct auth method
    authenticated fetch behavior
      ΓêÜ should use Bearer token in Authorization header (1 ms)

  console.log
    [DatasetLoader] Found manifest at: E:\projects\ado-git-repo-insights\extension\tests\fixtures\legacy-datasets/dataset-manifest.json

      at DatasetLoader.resolveDatasetRoot (ui/dataset-loader.ts:360:19)

  console.log
    [DatasetLoader] Found manifest at: E:\projects\ado-git-repo-insights\extension\tests\fixtures\legacy-datasets/dataset-manifest.json

      at DatasetLoader.resolveDatasetRoot (ui/dataset-loader.ts:360:19)

  console.log
    [DatasetLoader] Found manifest at: E:\projects\ado-git-repo-insights\extension\tests\fixtures\legacy-datasets/dataset-manifest.json

      at DatasetLoader.resolveDatasetRoot (ui/dataset-loader.ts:360:19)

  console.log
    [DatasetLoader] Found manifest at: E:\projects\ado-git-repo-insights\extension\tests\fixtures\legacy-datasets/dataset-manifest.json

      at DatasetLoader.resolveDatasetRoot (ui/dataset-loader.ts:360:19)

  console.log
    [DatasetLoader] Found manifest at: E:\projects\ado-git-repo-insights\extension\tests\fixtures\legacy-datasets/dataset-manifest.json

      at DatasetLoader.resolveDatasetRoot (ui/dataset-loader.ts:360:19)

  console.log
    [DatasetLoader] Found manifest at: E:\projects\ado-git-repo-insights\extension\tests\fixtures\legacy-datasets/dataset-manifest.json

      at DatasetLoader.resolveDatasetRoot (ui/dataset-loader.ts:360:19)

PASS tests/version-adapter-integration.test.ts (5.116 s)
  Version Adapter Integration
    getWeeklyRollups (synchronous loading)
      ΓêÜ normalizes v1.0 rollup (minimal fields) (82 ms)
      ΓêÜ normalizes v1.1 rollup (with cycle times) (4 ms)
      ΓêÜ normalizes v1.2 rollup (with contributors) (3 ms)
      ΓêÜ preserves current schema without data loss (2 ms)
    getWeeklyRollupsWithProgress (concurrent loading)
      ΓêÜ normalizes rollups in concurrent path (3 ms)
    Graceful degradation
      ΓêÜ handles malformed rollup gracefully (3 ms)

  console.warn
    Could not clear stale setting: Error: Storage error
        at Object.<anonymous> (E:\projects\ado-git-repo-insights\extension\tests\production-issues.test.ts:393:47)
        at Promise.then.completed (E:\projects\ado-git-repo-insights\extension\node_modules\jest-circus\build\utils.js:298:28)
        at new Promise (<anonymous>)
        at callAsyncCircusFn (E:\projects\ado-git-repo-insights\extension\node_modules\jest-circus\build\utils.js:231:10)
        at _callCircusTest (E:\projects\ado-git-repo-insights\extension\node_modules\jest-circus\build\run.js:316:40)
        at processTicksAndRejections (node:internal/process/task_queues:103:5)
        at _runTest (E:\projects\ado-git-repo-insights\extension\node_modules\jest-circus\build\run.js:252:3)
        at _runTestsForDescribeBlock (E:\projects\ado-git-repo-insights\extension\node_modules\jest-circus\build\run.js:126:9)
        at _runTestsForDescribeBlock (E:\projects\ado-git-repo-insights\extension\node_modules\jest-circus\build\run.js:121:9)
        at _runTestsForDescribeBlock (E:\projects\ado-git-repo-insights\extension\node_modules\jest-circus\build\run.js:121:9)
        at run (E:\projects\ado-git-repo-insights\extension\node_modules\jest-circus\build\run.js:71:3)
        at runAndTransformResultsToJestFormat (E:\projects\ado-git-repo-insights\extension\node_modules\jest-circus\build\legacy-code-todo-rewrite\jestAdapterInit.js:122:21)
        at jestAdapter (E:\projects\ado-git-repo-insights\extension\node_modules\jest-circus\build\legacy-code-todo-rewrite\jestAdapter.js:79:19)
        at runTestInternal (E:\projects\ado-git-repo-insights\extension\node_modules\jest-runner\build\runTest.js:367:16)
        at runTest (E:\projects\ado-git-repo-insights\extension\node_modules\jest-runner\build\runTest.js:444:34)
        at Object.worker (E:\projects\ado-git-repo-insights\extension\node_modules\jest-runner\build\testWorker.js:106:12)

    [0m [90m 400 |[39m           })[33m;[39m
     [90m 401 |[39m         } [36mcatch[39m (e) {
    [31m[1m>[22m[39m[90m 402 |[39m           console[33m.[39mwarn([32m"Could not clear stale setting:"[39m[33m,[39m e)[33m;[39m
     [90m     |[39m                   [31m[1m^[22m[39m
     [90m 403 |[39m           [90m// Don't rethrow - this is best-effort cleanup[39m
     [90m 404 |[39m         }
     [90m 405 |[39m       }[33m;[39m[0m

      at clearStalePipelineSetting (tests/production-issues.test.ts:402:19)
      at Object.<anonymous> (tests/production-issues.test.ts:408:7)

PASS tests/production-issues.test.ts (5.127 s)
  Issue 1: PartiallySucceeded Builds Acceptance
    resultFilter bitmask
      ΓêÜ should use resultFilter=6 to include both Succeeded and PartiallySucceeded (10 ms)
      ΓêÜ resultFilter=2 excludes PartiallySucceeded builds
      ΓêÜ resultFilter=6 includes PartiallySucceeded builds
      ΓêÜ resultFilter=6 includes Succeeded builds (1 ms)
      ΓêÜ resultFilter=6 excludes Failed builds
    Build filtering logic
      ΓêÜ old resultFilter=2 would miss first-run PartiallySucceeded builds (2 ms)
      ΓêÜ new resultFilter=6 includes first-run PartiallySucceeded builds (1 ms)
      ΓêÜ new resultFilter=6 still excludes Failed and Canceled builds (1 ms)
    First-run scenario simulation
      ΓêÜ first run build should be detected with new resultFilter
      ΓêÜ subsequent successful runs should still be detected
    Error message clarity
      ΓêÜ error message mentions PartiallySucceeded as acceptable
      ΓêÜ error message explains why first runs may be partial
  Issue 2: Stale Settings and Auto-Discovery Fallback
    Settings persistence behavior
      ΓêÜ Extension Data Service settings persist across reinstalls (1 ms)
    Configuration resolution with fallback
      ΓêÜ uses saved pipelineId when valid (1 ms)
      ΓêÜ falls back to discovery when saved pipelineId is invalid (1 ms)
      ΓêÜ clears stale setting automatically on fallback
      ΓêÜ does NOT fall back when query pipelineId fails (explicit override) (25 ms)
      ΓêÜ uses discovery when no settings exist
    clearStalePipelineSetting behavior
      ΓêÜ sets pipeline setting to null
      ΓêÜ handles errors gracefully without throwing (81 ms)
    Settings page validation
      ΓêÜ returns valid=true for existing pipeline with builds
      ΓêÜ returns valid=false when pipeline definition not found (deleted) (1 ms)
      ΓêÜ returns valid=false when no successful builds exist
    Re-discover pipelines functionality
      ΓêÜ discovers pipelines with aggregates artifact (1 ms)
      ΓêÜ returns empty when no pipelines have aggregates
      ΓêÜ skips pipelines with no successful builds
    End-to-end scenario: Extension reinstall
      ΓêÜ automatically discovers new pipeline after reinstall (1 ms)
      ΓêÜ next load uses discovery directly after stale setting cleared
  Combined: First-run PartiallySucceeded + Auto-discovery
    ΓêÜ discovers first-run PartiallySucceeded build after reinstall (1 ms)
    ΓêÜ old resultFilter would have missed first-run after reinstall
  Regression Prevention
    resultFilter value must be 6
      ΓêÜ resolveFromPipelineId should use resultFilter=6
      ΓêÜ discoverInsightsPipelines should use resultFilter=6
    Fallback behavior must be preserved
      ΓêÜ saved pipeline errors should trigger discovery fallback (1 ms)
      ΓêÜ query param errors should NOT trigger discovery fallback
    Settings clearing must be automatic
      ΓêÜ stale settings should be cleared on fallback (1 ms)
  Phase 5 Feature Flag (Predictions & AI Insights)
    Feature flag behavior
      ΓêÜ ENABLE_PHASE5_FEATURES should be true (Phase 5 enabled)
      ΓêÜ Phase 5 tabs should be hidden when feature flag is false
      ΓêÜ Phase 5 tabs should be visible when feature flag is true (1 ms)
    initializePhase5Features function
      ΓêÜ does not modify tabs when flag is false
      ΓêÜ shows tabs when flag is true
    Coming Soon state
      ΓêÜ Phase 5 tabs have "hidden" class by default in HTML (20 ms)
      ΓêÜ Phase 5 tabs have "phase5-tab" marker class (5 ms)
      ΓêÜ Phase 5 content shows "Coming Soon" message (5 ms)
      ΓêÜ Phase 5 content has "coming-soon" CSS class (3 ms)
    Regression prevention
      ΓêÜ Phase 5 feature flag constant must exist
      ΓêÜ When Phase 5 is enabled, tabs should become visible (1 ms)

PASS tests/fixtures.test.ts (5.188 s)
  Golden Fixtures
    Fixture files exist
      ΓêÜ has dataset-manifest.json (7 ms)
      ΓêÜ has dimensions.json (1 ms)
      ΓêÜ has weekly rollup fixture
      ΓêÜ has predictions fixture (1 ms)
      ΓêÜ has insights fixture
    Fixture schema validation
      ΓêÜ manifest has required schema versions (1 ms)
      ΓêÜ manifest has required feature flags (1 ms)
      ΓêÜ predictions fixture passes schema validation (1 ms)
      ΓêÜ insights fixture passes schema validation
    Fixture content validation
      ΓêÜ weekly rollup has expected structure (1 ms)
      ΓêÜ dimensions has filter values (1 ms)
      ΓêÜ predictions has forecasts array
      ΓêÜ insights has all severity levels (1 ms)

PASS tests/chunked-loading.test.ts (5.581 s)
  Phase 4: Chunked Loading
    fetchSemaphore
      ΓêÜ enforces max 4 concurrent fetches (16 ms)
      ΓêÜ processes queue in FIFO order (30 ms)
    createRollupCache with injected clock
      ΓêÜ returns cached value within TTL (2 ms)
      ΓêÜ expires cache after TTL (2 ms)
      ΓêÜ evicts oldest by touchedAt when at capacity (6 ms)
      ΓêÜ throws if cache key missing required fields (30 ms)
    getWeeklyRollupsWithProgress
      ΓêÜ returns explicit missingWeeks[] for 404s (20 ms)
      ΓêÜ returns explicit failedWeeks[] for 5xx after retry (215 ms)
      ΓêÜ throws AUTH_REQUIRED if authError && data.length === 0 (1 ms)
      ΓêÜ returns degraded state if partial auth success (1 ms)
      ΓêÜ calls onProgress with correct semantics (1 ms)
      ΓêÜ retries go through semaphore (214 ms)
      ΓêÜ stress test: randomized completion order with fixed seed (169 ms)

  console.log
    {"test":"fixture_generation_1k","duration_ms":1187.4844999999996,"budget_ms":10000,"baseline_ms":5000}

      at Object.<anonymous> (tests/performance.test.ts:76:13)

  console.log
    {"test":"manifest_parse","duration_ms":0.5082000000002154,"budget_ms":50,"baseline_ms":10}

      at Object.<anonymous> (tests/performance.test.ts:121:13)

  console.log
    {"test":"bulk_json_parse","duration_ms":7.721599999999853,"budget_ms":500,"baseline_ms":100,"files_parsed":50}

      at Object.<anonymous> (tests/performance.test.ts:165:13)

  console.log
    {"test":"memory_footprint","memory_delta_mb":0.0663299560546875,"budget_mb":20,"baseline_mb":10}

      at Object.<anonymous> (tests/performance.test.ts:223:13)

  console.warn
    [PERF] 1000pr-fixture-gen: 538.01ms vs baseline 335.00ms (60.6% change) - WARNING

    [0m [90m 338 |[39m           [36mthrow[39m [36mnew[39m [33mError[39m([32m`${message} - REGRESSION DETECTED`[39m)[33m;[39m
     [90m 339 |[39m         } [36melse[39m {
    [31m[1m>[22m[39m[90m 340 |[39m           console[33m.[39mwarn([32m`${message} - WARNING`[39m)[33m;[39m
     [90m     |[39m                   [31m[1m^[22m[39m
     [90m 341 |[39m         }
     [90m 342 |[39m       } [36melse[39m {
     [90m 343 |[39m         console[33m.[39mlog(message)[33m;[39m[0m

      at checkRegression (tests/performance.test.ts:340:19)
      at Object.<anonymous> (tests/performance.test.ts:376:7)

  console.log
    {"test":"fixture_generation_1000pr","duration_ms":538.0146000000004,"budget_ms":10000,"baseline_ms":335}

      at Object.<anonymous> (tests/performance.test.ts:378:15)

  console.log
    [PERF] 1000pr-manifest-parse: 0.15ms vs baseline 10.00ms (-98.5% change)

      at checkRegression (tests/performance.test.ts:343:17)

  console.log
    [PERF] 1000pr-bulk-parse: 5.22ms vs baseline 100.00ms (-94.8% change)

      at checkRegression (tests/performance.test.ts:343:17)

  console.warn
    [PERF] 5000pr-fixture-gen: 551.45ms vs baseline 345.00ms (59.8% change) - WARNING

    [0m [90m 338 |[39m           [36mthrow[39m [36mnew[39m [33mError[39m([32m`${message} - REGRESSION DETECTED`[39m)[33m;[39m
     [90m 339 |[39m         } [36melse[39m {
    [31m[1m>[22m[39m[90m 340 |[39m           console[33m.[39mwarn([32m`${message} - WARNING`[39m)[33m;[39m
     [90m     |[39m                   [31m[1m^[22m[39m
     [90m 341 |[39m         }
     [90m 342 |[39m       } [36melse[39m {
     [90m 343 |[39m         console[33m.[39mlog(message)[33m;[39m[0m

      at checkRegression (tests/performance.test.ts:340:19)
      at Object.<anonymous> (tests/performance.test.ts:376:7)

  console.log
    {"test":"fixture_generation_5000pr","duration_ms":551.445099999999,"budget_ms":50000,"baseline_ms":345}

      at Object.<anonymous> (tests/performance.test.ts:378:15)

  console.log
    [PERF] 5000pr-manifest-parse: 0.16ms vs baseline 12.00ms (-98.7% change)

      at checkRegression (tests/performance.test.ts:343:17)

  console.log
    [PERF] 5000pr-bulk-parse: 5.61ms vs baseline 224.00ms (-97.5% change)

      at checkRegression (tests/performance.test.ts:343:17)

  console.warn
    [PERF] 10000pr-fixture-gen: 582.41ms vs baseline 341.00ms (70.8% change) - WARNING

    [0m [90m 338 |[39m           [36mthrow[39m [36mnew[39m [33mError[39m([32m`${message} - REGRESSION DETECTED`[39m)[33m;[39m
     [90m 339 |[39m         } [36melse[39m {
    [31m[1m>[22m[39m[90m 340 |[39m           console[33m.[39mwarn([32m`${message} - WARNING`[39m)[33m;[39m
     [90m     |[39m                   [31m[1m^[22m[39m
     [90m 341 |[39m         }
     [90m 342 |[39m       } [36melse[39m {
     [90m 343 |[39m         console[33m.[39mlog(message)[33m;[39m[0m

      at checkRegression (tests/performance.test.ts:340:19)
      at Object.<anonymous> (tests/performance.test.ts:376:7)

  console.log
    {"test":"fixture_generation_10000pr","duration_ms":582.4146999999975,"budget_ms":100000,"baseline_ms":341}

      at Object.<anonymous> (tests/performance.test.ts:378:15)

  console.log
    [PERF] 10000pr-manifest-parse: 0.15ms vs baseline 15.00ms (-99.0% change)

      at checkRegression (tests/performance.test.ts:343:17)

  console.log
    [PERF] 10000pr-bulk-parse: 5.60ms vs baseline 316.00ms (-98.2% change)

      at checkRegression (tests/performance.test.ts:343:17)

PASS tests/performance.test.ts (14.287 s)
  Performance Baseline Tests (Simplified)
    ΓêÜ 1k PR fixture generation completes within budget (1237 ms)
    ΓêÜ manifest parsing completes within budget (2 ms)
    ΓêÜ bulk JSON parsing (all rollups) completes within budget (10 ms)
    ΓêÜ memory footprint for 1k dataset remains within ceiling (2 ms)
  Scaling Performance at 1000 PRs
    ΓêÜ 1000 PR fixture generation within budget (2774 ms)
    ΓêÜ 1000 PR manifest parse within budget (2 ms)
    ΓêÜ 1000 PR bulk JSON parse scales sub-linearly (29 ms)
  Scaling Performance at 5000 PRs
    ΓêÜ 5000 PR fixture generation within budget (2797 ms)
    ΓêÜ 5000 PR manifest parse within budget (2 ms)
    ΓêÜ 5000 PR bulk JSON parse scales sub-linearly (35 ms)
  Scaling Performance at 10000 PRs
    ΓêÜ 10000 PR fixture generation within budget (2877 ms)
    ΓêÜ 10000 PR manifest parse within budget (2 ms)
    ΓêÜ 10000 PR bulk JSON parse scales sub-linearly (29 ms)

Test Suites: 1 failed, 18 passed, 19 total
Tests:       10 failed, 376 passed, 386 total
Snapshots:   0 total
Time:        16.66 s
Ran all test suites.
