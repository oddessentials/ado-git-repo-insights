/**
 * Dataset Loader Module
 *
 * Implements the dataset-contract.md specification.
 * This module is the ONLY data layer - fully dataset-driven,
 * usable by both extension UI and future CLI dashboard.
 */
/**
 * Candidate paths to search for dataset-manifest.json.
 * CRITICAL: Only flat layout supported (manifest at root OR in aggregates/).
 * Double-nesting (aggregates/aggregates) is DEPRECATED and will hard-fail.
 * Order matters: first match wins.
 */
export declare const DATASET_CANDIDATE_PATHS: string[];
/**
 * Error message for deprecated double-nested layout.
 */
export declare const DEPRECATED_LAYOUT_ERROR: string;
/**
 * Interface for Rollup data structure.
 */
export interface Rollup {
  week: string;
  pr_count: number;
  cycle_time_p50: number | null;
  cycle_time_p90: number | null;
  authors_count: number;
  reviewers_count: number;
  by_repository: Record<string, number> | null;
  by_team: Record<string, number> | null;
  [key: string]: unknown;
}
/**
 * Version Adapter Pattern (Phase 7.4)
 *
 * Normalizes rollup data across schema versions, providing sensible defaults
 * for missing fields in older datasets. This ensures backward compatibility
 * when loading datasets generated by older versions of the pipeline.
 */
export declare const ROLLUP_FIELD_DEFAULTS: {
  readonly pr_count: 0;
  readonly cycle_time_p50: null;
  readonly cycle_time_p90: null;
  readonly authors_count: 0;
  readonly reviewers_count: 0;
  readonly by_repository: null;
  readonly by_team: null;
};
/**
 * Normalize a single rollup object to ensure all expected fields exist.
 * @param rollup - Raw rollup data from JSON
 * @returns Normalized rollup with all expected fields
 */
export declare function normalizeRollup(rollup: any): Rollup;
/**
 * Normalize an array of rollup objects.
 * @param rollups - Array of raw rollup data
 * @returns Normalized rollups
 */
export declare function normalizeRollups(
  rollups: any[] | null | undefined,
): Rollup[];
/**
 * Semaphore for bounded concurrent fetching (Phase 4).
 * All fetches and retries MUST acquire through this singleton.
 */
export declare const fetchSemaphore: {
  maxConcurrent: number;
  maxRetries: number;
  retryDelayMs: number;
  active: number;
  queue: Array<() => void>;
  /**
   * Acquire a semaphore slot. Blocks until slot available.
   * @returns {Promise<void>}
   */
  acquire(): Promise<void>;
  /**
   * Release a semaphore slot. Unblocks next waiter if any.
   */
  release(): void;
  /**
   * Get current state (for testing).
   * @returns {{ active: number, queued: number }}
   */
  getState(): {
    active: number;
    queued: number;
  };
  /**
   * Reset semaphore state (for testing).
   */
  reset(): void;
};
/**
 * LRU Cache interface.
 */
export interface RollupCache {
  maxSize: number;
  ttlMs: number;
  clock: () => number;
  makeKey(params: {
    week: string;
    org: string;
    project: string;
    repo: string;
    branch?: string;
    apiVersion?: string;
  }): string;
  get(key: string): any;
  set(key: string, value: any): void;
  has(key: string): boolean;
  clear(): void;
  size(): number;
}
/**
 * Create an LRU cache with TTL and bounded size (Phase 4).
 * @param clock - Injected time source (default: Date.now)
 * @returns Cache instance
 */
export declare function createRollupCache(clock?: () => number): RollupCache;
export interface ProgressEvent {
  loaded: number;
  total: number;
  currentWeek: string | null;
}
export interface RollupResult {
  data: Rollup[];
  missingWeeks: string[];
  failedWeeks: string[];
  partial: boolean;
  authError: boolean;
  degraded: boolean;
}
/**
 * Core interface for data loading.
 * Shared by both direct (fetch-based) and authenticated (ADO artifact-based) loaders.
 */
export interface IDatasetLoader {
  loadManifest(): Promise<any>;
  loadDimensions(): Promise<any>;
  getWeeklyRollups(startDate: Date, endDate: Date): Promise<Rollup[]>;
  getDistributions(startDate: Date, endDate: Date): Promise<any[]>;
  getCoverage(): any;
  getDefaultRangeDays(): number;
  loadPredictions?(): Promise<any>;
  loadInsights?(): Promise<any>;
}
/**
 * Dataset loader state
 */
export declare class DatasetLoader implements IDatasetLoader {
  protected baseUrl: string;
  protected effectiveBaseUrl: string | null;
  protected manifest: any | null;
  protected dimensions: any | null;
  protected rollupCache: Map<string, Rollup>;
  protected distributionCache: Map<string, any>;
  constructor(baseUrl?: string);
  /**
   * Resolve the dataset root by probing candidate paths for manifest.
   * Caches the result for subsequent path resolutions.
   * @returns The effective base URL or null if not found
   */
  resolveDatasetRoot(): Promise<string | null>;
  /**
   * Load and validate the dataset manifest.
   * Automatically resolves nested dataset root before loading.
   */
  loadManifest(): Promise<any>;
  /**
   * Validate manifest schema versions.
   */
  protected validateManifest(manifest: any): void;
  /**
   * Load dimensions (filter values).
   */
  loadDimensions(): Promise<any>;
  /**
   * Get weekly rollups for a date range.
   * Implements lazy loading with caching.
   */
  getWeeklyRollups(startDate: Date, endDate: Date): Promise<Rollup[]>;
  /**
   * Get weekly rollups with concurrent fetching, progress reporting, and caching (Phase 4).
   */
  getWeeklyRollupsWithProgress(
    startDate: Date,
    endDate: Date,
    context: {
      org: string;
      project: string;
      repo: string;
      branch?: string;
      apiVersion?: string;
    },
    onProgress?: (event: ProgressEvent) => void,
    cache?: RollupCache | null,
  ): Promise<RollupResult>;
  /**
   * Fetch a single week with semaphore control and bounded retry.
   */
  protected _fetchWeekWithRetry(
    weekStr: string,
    indexEntry: any,
    context: any,
    cache: RollupCache,
  ): Promise<
    | {
        week: string;
        status: "ok";
        data: Rollup;
      }
    | {
        week: string;
        status: "auth" | "missing" | "failed";
        error?: any;
      }
  >;
  /**
   * Delay helper for retry backoff.
   */
  protected _delay(ms: number): Promise<void>;
  /**
   * Get yearly distributions for a date range.
   */
  getDistributions(startDate: Date, endDate: Date): Promise<any[]>;
  /**
   * Check if a feature is enabled in the dataset.
   */
  isFeatureEnabled(feature: string): boolean;
  /**
   * Get dataset coverage info.
   */
  getCoverage(): any;
  /**
   * Get default date range days.
   */
  getDefaultRangeDays(): number;
  /**
   * Load predictions data (Phase 3.5).
   */
  loadPredictions(): Promise<any>;
  /**
   * Load AI insights data (Phase 3.5).
   */
  loadInsights(): Promise<any>;
  /**
   * Validate predictions schema.
   */
  protected validatePredictionsSchema(predictions: any): {
    valid: boolean;
    error?: string;
  };
  /**
   * Validate insights schema.
   */
  protected validateInsightsSchema(insights: any): {
    valid: boolean;
    error?: string;
  };
  /**
   * Resolve a relative path to full URL.
   * Uses effectiveBaseUrl if resolved, otherwise falls back to baseUrl.
   */
  protected resolvePath(relativePath: string): string;
  /**
   * Get ISO week strings for a date range.
   */
  getWeeksInRange(start: Date, end: Date): string[];
  /**
   * Get ISO week string for a date.
   */
  getISOWeek(date: Date): string;
}
